var iz=Object.defineProperty;var oz=(t,e,n)=>e in t?iz(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n;var Ln=(t,e,n)=>oz(t,typeof e!="symbol"?e+"":e,n);function uz(t,e){for(var n=0;n<e.length;n++){const s=e[n];if(typeof s!="string"&&!Array.isArray(s)){for(const r in s)if(r!=="default"&&!(r in t)){const a=Object.getOwnPropertyDescriptor(s,r);a&&Object.defineProperty(t,r,a.get?a:{enumerable:!0,get:()=>s[r]})}}}return Object.freeze(Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))s(r);new MutationObserver(r=>{for(const a of r)if(a.type==="childList")for(const i of a.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&s(i)}).observe(document,{childList:!0,subtree:!0});function n(r){const a={};return r.integrity&&(a.integrity=r.integrity),r.referrerPolicy&&(a.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?a.credentials="include":r.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function s(r){if(r.ep)return;r.ep=!0;const a=n(r);fetch(r.href,a)}})();/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lz=1e-7,cz=1e-4;class fI{constructor(e,n){this.backend=e,this.dataMover=n,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,n){this.dataIdsCount++,this.data.set(e,n)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class gg{refCount(e){return Pn("refCount")}incRef(e){return Pn("incRef")}timerAvailable(){return!0}time(e){return Pn("time")}read(e){return Pn("read")}readSync(e){return Pn("readSync")}readToGPU(e,n){return Pn("readToGPU")}numDataIds(){return Pn("numDataIds")}disposeData(e,n){return Pn("disposeData")}write(e,n,s){return Pn("write")}move(e,n,s,r,a){return Pn("move")}createTensorFromGPUData(e,n,s){return Pn("createTensorFromGPUData")}memory(){return Pn("memory")}floatPrecision(){return Pn("floatPrecision")}epsilon(){return this.floatPrecision()===32?lz:cz}dispose(){return Pn("dispose")}}function Pn(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dz(t){let e=t.length,n=0;for(;e>0;)n=Math.random()*e|0,e--,Di(t,e,n)}function Za(t,e,n){return Math.max(t,Math.min(e,n))}function yg(t){return t%2===0?t:t+1}function Di(t,e,n){const s=t[e];t[e]=t[n],t[n]=s}function hz(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n];return e}function O(t,e){if(!t)throw new Error(typeof e=="string"?e:e())}function Zn(t,e,n=""){O(tt(t,e),()=>n+` Shapes ${t} and ${e} must match`)}function io(t){O(t!=null,()=>"The input to the tensor constructor must be a non-null value.")}function se(t){if(t.length===0)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function pz(t,e){if(t===e)return!0;if(t==null||e==null||t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==null&&e[n]!==null&&t[n]!==e[n])return!1;return!0}function tt(t,e){if(t===e)return!0;if(t==null||e==null||t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function qi(t){return t%1===0}function nm(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function Bi(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function Ww(t,e=r=>0,n,s){return new Promise((r,a)=>{let i=0;const o=()=>{if(t()){r();return}i++;const u=e(i);if(n!=null&&i>=n){a();return}s!=null?s(o,u):setTimeout(o,u)};o()})}function mI(t,e){let n=1,s=-1;for(let a=0;a<t.length;++a)if(t[a]>=0)n*=t[a];else if(t[a]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${a}`);s=a}else if(t[a]<0)throw Error(`Shapes can not be < 0. Found ${t[a]} at dim ${a}`);if(s===-1){if(e>0&&e!==n)throw Error(`Size(${e}) must match the product of shape ${t}`);return t}if(n===0)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(e%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${n}`);const r=t.slice();return r[s]=e/n,r}function Ye(t,e){const n=e.length;return t=t==null?e.map((s,r)=>r):[].concat(t),O(t.every(s=>s>=-n&&s<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`),O(t.every(s=>qi(s)),()=>`All values in axis param must be integers but got axis ${t}`),t.map(s=>s<0?n+s:s)}function fa(t,e){const n=[],s=[],r=e!=null&&Array.isArray(e)&&e.length===0,a=e==null||r?null:Ye(e,t).sort();let i=0;for(let o=0;o<t.length;++o){if(a!=null){if(a[i]===o&&t[o]!==1)throw new Error(`Can't squeeze axis ${o} since its dim '${t[o]}' is not 1`);(a[i]==null||a[i]>o)&&t[o]===1&&(n.push(t[o]),s.push(o)),a[i]<=o&&i++}t[o]!==1&&(n.push(t[o]),s.push(o))}return{newShape:n,keptDims:s}}function dn(t,e){return zt(t,e)}function zt(t,e){let n=null;if(t==null||t==="float32")n=new Float32Array(e);else if(t==="int32")n=new Int32Array(e);else if(t==="bool")n=new Uint8Array(e);else if(t==="string")n=new Array(e);else throw new Error(`Unknown data type ${t}`);return n}function fz(t,e){for(let n=0;n<t.length;n++){const s=t[n];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${e} being uploaded contains ${s}.`)}}function mz(t){return t==="bool"||t==="complex64"||t==="float32"||t==="int32"||t==="string"}function gI(t,e){return!(e==="complex64"||e==="float32"&&t!=="complex64"||e==="int32"&&t!=="float32"&&t!=="complex64"||e==="bool"&&t==="bool")}function Lc(t){if(t==="float32"||t==="int32")return 4;if(t==="complex64")return 8;if(t==="bool")return 1;throw new Error(`Unknown dtype ${t}`)}function gz(t){if(t==null)return 0;let e=0;return t.forEach(n=>e+=n.length),e}function wu(t){return typeof t=="string"||t instanceof String}function yz(t){return typeof t=="boolean"}function sm(t){return typeof t=="number"}function oo(t){return Array.isArray(t)?oo(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray?"int32":sm(t)?"float32":wu(t)?"string":yz(t)?"bool":"float32"}function rm(t){return!!(t&&t.constructor&&t.call&&t.apply)}function am(t,e){for(let n=e;n<t;++n)if(t%n===0)return n;return t}function Ae(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let s=e-3;s>=0;--s)n[s]=n[s+1]*t[s+1];return n}function yI(t,e,n,s=!1){const r=new Array;if(e.length===1){const a=e[0]*(s?2:1);for(let i=0;i<a;i++)r[i]=n[t+i]}else{const a=e[0],i=e.slice(1),o=i.reduce((u,l)=>u*l)*(s?2:1);for(let u=0;u<a;u++)r[u]=yI(t+u*o,i,n,s)}return r}function ws(t,e,n=!1){if(t.length===0)return e[0];const s=t.reduce((r,a)=>r*a)*(n?2:1);if(s===0)return[];if(s!==e.length)throw new Error(`[${t}] does not match the input size ${e.length}${n?" for a complex tensor":""}.`);return yI(0,t,e,n)}function bz(t,e){if(Array.isArray(t))return t;if(e==="float32")return t instanceof Float32Array?t:new Float32Array(t);if(e==="int32")return t instanceof Int32Array?t:new Int32Array(t);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(t));throw new Error(`Unknown dtype ${e}`)}function bg(t,e){const n=xn(t,e);for(let s=0;s<n.length;s++)n[s]=1;return n}function xn(t,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(t);if(e==="int32")return new Int32Array(t);if(e==="bool")return new Uint8Array(t);throw new Error(`Unknown data type ${e}`)}function bI(t,e){const n=t.reduce((s,r)=>s*r,1);if(e==null||e==="float32")return ws(t,new Float32Array(n));if(e==="int32")return ws(t,new Int32Array(n));if(e==="bool")return ws(t,new Uint8Array(n));throw new Error(`Unknown data type ${e}`)}function is(t){t.forEach(e=>{O(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`)})}function cr(t,e,n){if(e===0)return 0;if(e===1)return t[0];let s=t[t.length-1];for(let r=0;r<t.length-1;++r)s+=n[r]*t[r];return s}function uo(t,e,n){if(e===0)return[];if(e===1)return[t];const s=new Array(e);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(t/n[r]),t-=s[r]*n[r];return s[s.length-1]=t,s}function Qa(t){return t&&t.then&&typeof t.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uw="tfjsflags";class xz{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=wz,this.populateURLFlags()}setPlatform(e,n){this.platform!=null&&(te().getBool("IS_TEST")||te().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=n}registerFlag(e,n,s){if(this.flagRegistry[e]={evaluationFn:n,setHook:s},this.urlFlags[e]!=null){const r=this.urlFlags[e];te().getBool("IS_TEST")||te().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${r}.`),this.set(e,r)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const n=this.evaluateFlag(e);if(Qa(n))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=n,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,n){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=n,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(n)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);Uw in e&&e[Uw].split(",").forEach(s=>{const[r,a]=s.split(":");this.urlFlags[r]=vz(r,a)})}}function wz(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...s)=>($z(e,s[0],s[1]),s.join("="))),e}function $z(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}function vz(t,e){const n=e.toLowerCase();return n==="true"||n==="false"?n==="true":`${+n}`===n?+n:e}function te(){return xI}let xI=null;function Sz(t){xI=t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Pp;function wI(){if(Pp==null){let t;if(typeof window<"u")t=window;else if(typeof global<"u")t=global;else if(typeof process<"u")t=process;else if(typeof self<"u")t=self;else throw new Error("Could not find a global object");Pp=t}return Pp}function Iz(){const t=wI();return t._tfGlobals==null&&(t._tfGlobals=new Map),t._tfGlobals}function xg(t,e){const n=Iz();if(n.has(t))return n.get(t);{const s=e();return n.set(t,s),n.get(t)}}const wd="Abs",$u="Acos",vu="Acosh",lo="Add",$d="AddN",wg="All",$g="Any",vd="ArgMax",Sd="ArgMin",Su="Asin",Iu="Asinh",_u="Atan",ku="Atanh",Cu="Atan2",Id="AvgPool",vg="AvgPoolGrad",_d="AvgPool3D",Sg="AvgPool3DGrad",kd="BatchMatMul",Cd="BatchToSpaceND",Ig="Bincount",Td="BitwiseAnd",_z="BroadcastTo",_g="BroadcastArgs",Tu="Cast",Nu="Ceil",Eu="ClipByValue",kg="Complex",Nd="ComplexAbs",Ed="Concat",Ad="Conv2D",Cg="Conv2DBackpropFilter",Rd="Conv2DBackpropInput",Dd="Conv3D",Tg="Conv3DBackpropFilterV2",Ng="Conv3DBackpropInputV2",Au="Cos",Ru="Cosh",Eg="Cumprod",Od="Cumsum",Ag="CropAndResize",Rg="DenseBincount",Dg="DepthToSpace",Fd="DepthwiseConv2dNative",Og="DepthwiseConv2dNativeBackpropFilter",Fg="DepthwiseConv2dNativeBackpropInput",zg="Diag",zd="Dilation2D",im="Dilation2DBackpropInput",om="Dilation2DBackpropFilter",kz="Draw",Du="RealDiv",Lg="Einsum",Ou="Elu",Pg="EluGrad",Fu="Erf",Ld="Equal",zu="Exp",Pd="ExpandDims",Lu="Expm1",Bg="FFT",Mg="Fill",Vg="FlipLeftRight",Pu="Floor",Bu="FloorDiv",Bd="FusedBatchNorm",Md="GatherV2",Wg="GatherNd",Vd="Greater",Mu="GreaterEqual",Vu="Identity",Ug="IFFT",Gg="Imag",Wu="IsFinite",Uu="IsInf",Gu="IsNan",Wd="LeakyRelu",Ud="Less",Gd="LessEqual",Hg="LinSpace",Hu="Log",qu="Log1p",Hd="LogicalAnd",qd="LogicalNot",jd="LogicalOr",Cz="LogSoftmax",Kd="LRN",qg="LRNGrad",Xd="Max",ju="Maximum",Yd="MaxPool",jg="MaxPoolGrad",Zd="MaxPool3D",Kg="MaxPool3DGrad",Xg="MaxPoolWithArgmax",Qd="Mean",Jd="Min",Ku="Minimum",eh="MirrorPad",Xu="Mod",Yg="Multinomial",Yu="Multiply",th="Neg",nh="NotEqual",Zg="NonMaxSuppressionV3",Qg="NonMaxSuppressionV4",Jg="NonMaxSuppressionV5",sh="OnesLike",rh="OneHot",ah="Pack",ih="PadV2",Zu="Pow",oh="Prelu",uh="Prod",ey="RaggedGather",ty="RaggedRange",ny="RaggedTensorToTensor",sy="Range",ry="Real",Qu="Reciprocal",Ju="Relu",lh="Reshape",ch="ResizeNearestNeighbor",ay="ResizeNearestNeighborGrad",dh="ResizeBilinear",iy="ResizeBilinearGrad",el="Relu6",hh="Reverse",tl="Round",nl="Rsqrt",oy="ScatterNd",uy="TensorScatterUpdate",ly="SearchSorted",ph="Select",sl="Selu",fh="Slice",rl="Sin",al="Sinh",il="Sign",ol="Sigmoid",ul="Softplus",ll="Sqrt",mh="Sum",gh="SpaceToBatchND",yh="SplitV",bh="Softmax",cy="SparseFillEmptyRows",dy="SparseReshape",hy="SparseSegmentMean",py="SparseSegmentSum",fy="SparseToDense",cl="SquaredDifference",my="Square",xh="StaticRegexReplace",gy="StridedSlice",yy="StringNGrams",by="StringSplit",xy="StringToHashBucketFast",dl="Sub",hl="Tan",pl="Tanh",fl="Tile",wy="TopK",$y="Transform",Mi="Transpose",vy="Unique",wh="Unpack",$h="UnsortedSegmentSum",vh="ZerosLike",ml="Step",um="FromPixels",Sy="RotateWithOffset",Pc="_FusedMatMul",Bc="FusedConv2D",Mc="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ts(...t){te().getBool("IS_TEST")||te().getBool("PROD")||console.warn(...t)}function Tz(...t){te().getBool("IS_TEST")||te().getBool("PROD")||console.log(...t)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vc=xg("kernelRegistry",()=>new Map),lm=xg("gradRegistry",()=>new Map);function cm(t,e){const n=vI(t,e);return Vc.get(n)}function Gw(t){return lm.get(t)}function Hw(t){const e=Vc.entries(),n=[];for(;;){const{done:s,value:r}=e.next();if(s)break;const[a,i]=r,[o]=a.split("_");o===t&&n.push(i)}return n}function $I(t){const{kernelName:e,backendName:n}=t,s=vI(e,n);Vc.has(s)&&ts(`The kernel '${e}' for backend '${n}' is already registered`),Vc.set(s,t)}function Nz(t){const{kernelName:e}=t;lm.has(e)&&te().getBool("DEBUG")&&ts(`Overriding the gradient for '${e}'`),lm.set(e,t)}function vI(t,e){return`${e}_${t}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SI(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray}function Ez(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}function Az(t){if(Object.prototype.hasOwnProperty.call(t,"__esModule"))return t;var e=t.default;if(typeof e=="function"){var n=function s(){return this instanceof s?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};n.prototype=e.prototype}else n={};return Object.defineProperty(n,"__esModule",{value:!0}),Object.keys(t).forEach(function(s){var r=Object.getOwnPropertyDescriptor(t,s);Object.defineProperty(n,s,r.get?r:{enumerable:!0,get:function(){return t[s]}})}),n}var Bp,qw;function Rz(){if(qw)return Bp;qw=1,Bp=e;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function e(I,E,z){this.low=I|0,this.high=E|0,this.unsigned=!!z}e.prototype.__isLong__,Object.defineProperty(e.prototype,"__isLong__",{value:!0});function n(I){return(I&&I.__isLong__)===!0}e.isLong=n;var s={},r={};function a(I,E){var z,P,H;return E?(I>>>=0,(H=0<=I&&I<256)&&(P=r[I],P)?P:(z=o(I,(I|0)<0?-1:0,!0),H&&(r[I]=z),z)):(I|=0,(H=-128<=I&&I<128)&&(P=s[I],P)?P:(z=o(I,I<0?-1:0,!1),H&&(s[I]=z),z))}e.fromInt=a;function i(I,E){if(isNaN(I))return E?b:y;if(E){if(I<0)return b;if(I>=f)return C}else{if(I<=-m)return N;if(I+1>=m)return k}return I<0?i(-I,E).neg():o(I%p|0,I/p|0,E)}e.fromNumber=i;function o(I,E,z){return new e(I,E,z)}e.fromBits=o;var u=Math.pow;function l(I,E,z){if(I.length===0)throw Error("empty string");if(I==="NaN"||I==="Infinity"||I==="+Infinity"||I==="-Infinity")return y;if(typeof E=="number"?(z=E,E=!1):E=!!E,z=z||10,z<2||36<z)throw RangeError("radix");var P;if((P=I.indexOf("-"))>0)throw Error("interior hyphen");if(P===0)return l(I.substring(1),E,z).neg();for(var H=i(u(z,8)),G=y,W=0;W<I.length;W+=8){var L=Math.min(8,I.length-W),B=parseInt(I.substring(W,W+L),z);if(L<8){var Y=i(u(z,L));G=G.mul(Y).add(i(B))}else G=G.mul(H),G=G.add(i(B))}return G.unsigned=E,G}e.fromString=l;function c(I,E){return typeof I=="number"?i(I,E):typeof I=="string"?l(I,E):o(I.low,I.high,typeof E=="boolean"?E:I.unsigned)}e.fromValue=c;var d=65536,h=1<<24,p=d*d,f=p*p,m=f/2,g=a(h),y=a(0);e.ZERO=y;var b=a(0,!0);e.UZERO=b;var $=a(1);e.ONE=$;var w=a(1,!0);e.UONE=w;var v=a(-1);e.NEG_ONE=v;var k=o(-1,2147483647,!1);e.MAX_VALUE=k;var C=o(-1,-1,!0);e.MAX_UNSIGNED_VALUE=C;var N=o(0,-2147483648,!1);e.MIN_VALUE=N;var A=e.prototype;return A.toInt=function(){return this.unsigned?this.low>>>0:this.low},A.toNumber=function(){return this.unsigned?(this.high>>>0)*p+(this.low>>>0):this.high*p+(this.low>>>0)},A.toString=function(E){if(E=E||10,E<2||36<E)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(N)){var z=i(E),P=this.div(z),H=P.mul(z).sub(this);return P.toString(E)+H.toInt().toString(E)}else return"-"+this.neg().toString(E);for(var G=i(u(E,6),this.unsigned),W=this,L="";;){var B=W.div(G),Y=W.sub(B.mul(G)).toInt()>>>0,ne=Y.toString(E);if(W=B,W.isZero())return ne+L;for(;ne.length<6;)ne="0"+ne;L=""+ne+L}},A.getHighBits=function(){return this.high},A.getHighBitsUnsigned=function(){return this.high>>>0},A.getLowBits=function(){return this.low},A.getLowBitsUnsigned=function(){return this.low>>>0},A.getNumBitsAbs=function(){if(this.isNegative())return this.eq(N)?64:this.neg().getNumBitsAbs();for(var E=this.high!=0?this.high:this.low,z=31;z>0&&(E&1<<z)==0;z--);return this.high!=0?z+33:z+1},A.isZero=function(){return this.high===0&&this.low===0},A.eqz=A.isZero,A.isNegative=function(){return!this.unsigned&&this.high<0},A.isPositive=function(){return this.unsigned||this.high>=0},A.isOdd=function(){return(this.low&1)===1},A.isEven=function(){return(this.low&1)===0},A.equals=function(E){return n(E)||(E=c(E)),this.unsigned!==E.unsigned&&this.high>>>31===1&&E.high>>>31===1?!1:this.high===E.high&&this.low===E.low},A.eq=A.equals,A.notEquals=function(E){return!this.eq(E)},A.neq=A.notEquals,A.ne=A.notEquals,A.lessThan=function(E){return this.comp(E)<0},A.lt=A.lessThan,A.lessThanOrEqual=function(E){return this.comp(E)<=0},A.lte=A.lessThanOrEqual,A.le=A.lessThanOrEqual,A.greaterThan=function(E){return this.comp(E)>0},A.gt=A.greaterThan,A.greaterThanOrEqual=function(E){return this.comp(E)>=0},A.gte=A.greaterThanOrEqual,A.ge=A.greaterThanOrEqual,A.compare=function(E){if(n(E)||(E=c(E)),this.eq(E))return 0;var z=this.isNegative(),P=E.isNegative();return z&&!P?-1:!z&&P?1:this.unsigned?E.high>>>0>this.high>>>0||E.high===this.high&&E.low>>>0>this.low>>>0?-1:1:this.sub(E).isNegative()?-1:1},A.comp=A.compare,A.negate=function(){return!this.unsigned&&this.eq(N)?N:this.not().add($)},A.neg=A.negate,A.add=function(E){n(E)||(E=c(E));var z=this.high>>>16,P=this.high&65535,H=this.low>>>16,G=this.low&65535,W=E.high>>>16,L=E.high&65535,B=E.low>>>16,Y=E.low&65535,ne=0,M=0,Z=0,J=0;return J+=G+Y,Z+=J>>>16,J&=65535,Z+=H+B,M+=Z>>>16,Z&=65535,M+=P+L,ne+=M>>>16,M&=65535,ne+=z+W,ne&=65535,o(Z<<16|J,ne<<16|M,this.unsigned)},A.subtract=function(E){return n(E)||(E=c(E)),this.add(E.neg())},A.sub=A.subtract,A.multiply=function(E){if(this.isZero())return y;if(n(E)||(E=c(E)),t){var z=t.mul(this.low,this.high,E.low,E.high);return o(z,t.get_high(),this.unsigned)}if(E.isZero())return y;if(this.eq(N))return E.isOdd()?N:y;if(E.eq(N))return this.isOdd()?N:y;if(this.isNegative())return E.isNegative()?this.neg().mul(E.neg()):this.neg().mul(E).neg();if(E.isNegative())return this.mul(E.neg()).neg();if(this.lt(g)&&E.lt(g))return i(this.toNumber()*E.toNumber(),this.unsigned);var P=this.high>>>16,H=this.high&65535,G=this.low>>>16,W=this.low&65535,L=E.high>>>16,B=E.high&65535,Y=E.low>>>16,ne=E.low&65535,M=0,Z=0,J=0,oe=0;return oe+=W*ne,J+=oe>>>16,oe&=65535,J+=G*ne,Z+=J>>>16,J&=65535,J+=W*Y,Z+=J>>>16,J&=65535,Z+=H*ne,M+=Z>>>16,Z&=65535,Z+=G*Y,M+=Z>>>16,Z&=65535,Z+=W*B,M+=Z>>>16,Z&=65535,M+=P*ne+H*Y+G*B+W*L,M&=65535,o(J<<16|oe,M<<16|Z,this.unsigned)},A.mul=A.multiply,A.divide=function(E){if(n(E)||(E=c(E)),E.isZero())throw Error("division by zero");if(t){if(!this.unsigned&&this.high===-2147483648&&E.low===-1&&E.high===-1)return this;var z=(this.unsigned?t.div_u:t.div_s)(this.low,this.high,E.low,E.high);return o(z,t.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?b:y;var P,H,G;if(this.unsigned){if(E.unsigned||(E=E.toUnsigned()),E.gt(this))return b;if(E.gt(this.shru(1)))return w;G=b}else{if(this.eq(N)){if(E.eq($)||E.eq(v))return N;if(E.eq(N))return $;var W=this.shr(1);return P=W.div(E).shl(1),P.eq(y)?E.isNegative()?$:v:(H=this.sub(E.mul(P)),G=P.add(H.div(E)),G)}else if(E.eq(N))return this.unsigned?b:y;if(this.isNegative())return E.isNegative()?this.neg().div(E.neg()):this.neg().div(E).neg();if(E.isNegative())return this.div(E.neg()).neg();G=y}for(H=this;H.gte(E);){P=Math.max(1,Math.floor(H.toNumber()/E.toNumber()));for(var L=Math.ceil(Math.log(P)/Math.LN2),B=L<=48?1:u(2,L-48),Y=i(P),ne=Y.mul(E);ne.isNegative()||ne.gt(H);)P-=B,Y=i(P,this.unsigned),ne=Y.mul(E);Y.isZero()&&(Y=$),G=G.add(Y),H=H.sub(ne)}return G},A.div=A.divide,A.modulo=function(E){if(n(E)||(E=c(E)),t){var z=(this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,E.low,E.high);return o(z,t.get_high(),this.unsigned)}return this.sub(this.div(E).mul(E))},A.mod=A.modulo,A.rem=A.modulo,A.not=function(){return o(~this.low,~this.high,this.unsigned)},A.and=function(E){return n(E)||(E=c(E)),o(this.low&E.low,this.high&E.high,this.unsigned)},A.or=function(E){return n(E)||(E=c(E)),o(this.low|E.low,this.high|E.high,this.unsigned)},A.xor=function(E){return n(E)||(E=c(E)),o(this.low^E.low,this.high^E.high,this.unsigned)},A.shiftLeft=function(E){return n(E)&&(E=E.toInt()),(E&=63)===0?this:E<32?o(this.low<<E,this.high<<E|this.low>>>32-E,this.unsigned):o(0,this.low<<E-32,this.unsigned)},A.shl=A.shiftLeft,A.shiftRight=function(E){return n(E)&&(E=E.toInt()),(E&=63)===0?this:E<32?o(this.low>>>E|this.high<<32-E,this.high>>E,this.unsigned):o(this.high>>E-32,this.high>=0?0:-1,this.unsigned)},A.shr=A.shiftRight,A.shiftRightUnsigned=function(E){if(n(E)&&(E=E.toInt()),E&=63,E===0)return this;var z=this.high;if(E<32){var P=this.low;return o(P>>>E|z<<32-E,z>>>E,this.unsigned)}else return E===32?o(z,0,this.unsigned):o(z>>>E-32,0,this.unsigned)},A.shru=A.shiftRightUnsigned,A.shr_u=A.shiftRightUnsigned,A.toSigned=function(){return this.unsigned?o(this.low,this.high,!1):this},A.toUnsigned=function(){return this.unsigned?this:o(this.low,this.high,!0)},A.toBytes=function(E){return E?this.toBytesLE():this.toBytesBE()},A.toBytesLE=function(){var E=this.high,z=this.low;return[z&255,z>>>8&255,z>>>16&255,z>>>24,E&255,E>>>8&255,E>>>16&255,E>>>24]},A.toBytesBE=function(){var E=this.high,z=this.low;return[E>>>24,E>>>16&255,E>>>8&255,E&255,z>>>24,z>>>16&255,z>>>8&255,z&255]},e.fromBytes=function(E,z,P){return P?e.fromBytesLE(E,z):e.fromBytesBE(E,z)},e.fromBytesLE=function(E,z){return new e(E[0]|E[1]<<8|E[2]<<16|E[3]<<24,E[4]|E[5]<<8|E[6]<<16|E[7]<<24,z)},e.fromBytesBE=function(E,z){return new e(E[4]<<24|E[5]<<16|E[6]<<8|E[7],E[0]<<24|E[1]<<16|E[2]<<8|E[3],z)},Bp}var II=Rz();const _I=Ez(II),Dz=uz({__proto__:null,default:_I},[II]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pa=_I||Dz;function Sh(t){return Pa.fromString(t,!0,16)}const kI=Sh("c3a5c85c97cb3127"),La=Sh("b492b66fbe98f273"),In=Sh("9ae16a3b2f90404f");function dm(t){return t.xor(t.shru(47))}function CI(t,e,n){const s=t.slice(e,e+n);return Pa.fromBytes(Array.from(s),!0,!0)}function vt(t,e){return CI(t,e,8)}function jw(t,e){return CI(t,e,4)}function en(t,e){return e===0?t:t.shru(e).or(t.shl(64-e))}function Jr(t,e,n=Sh("9ddfea08eb382d69")){let s=t.xor(e).mul(n);s=s.xor(s.shru(47));let r=e.xor(s).mul(n);return r=r.xor(r.shru(47)),r=r.mul(n),r}function Oz(t,e,n,s,r,a){r=r.add(t),a=en(a.add(r).add(s),21);const i=r;return r=r.add(e),r=r.add(n),a=a.add(en(r,44)),[r.add(s),a.add(i)]}function Yl(t,e,n,s){return Oz(vt(t,e),vt(t,e+8),vt(t,e+16),vt(t,e+24),n,s)}function Fz(t,e=t.length){if(e>=8){const n=In.add(e*2),s=vt(t,0).add(In),r=vt(t,e-8),a=en(r,37).mul(n).add(s),i=en(s,25).add(r).mul(n);return Jr(a,i,n)}if(e>=4){const n=In.add(e*2),s=jw(t,0);return Jr(s.shl(3).add(e),jw(t,e-4),n)}if(e>0){const n=t[0],s=t[e>>1],r=t[e-1],a=n+(s<<8),i=e+(r<<2);return dm(In.mul(a).xor(kI.mul(i))).mul(In)}return In}function zz(t,e=t.length){const n=In.add(e*2),s=vt(t,0).mul(La),r=vt(t,8),a=vt(t,e-8).mul(n),i=vt(t,e-16).mul(In);return Jr(en(s.add(r),43).add(en(a,30)).add(i),s.add(en(r.add(In),18)).add(a),n)}function Lz(t,e=t.length){const n=In.add(e*2),s=vt(t,0).mul(In),r=vt(t,8),a=vt(t,e-8).mul(n),i=vt(t,e-16).mul(In),o=en(s.add(r),43).add(en(a,30)).add(i),u=Jr(o,s.add(en(r.add(In),18)).add(a),n),l=vt(t,16).mul(n),c=vt(t,24),d=o.add(vt(t,e-32)).mul(n),h=u.add(vt(t,e-24)).mul(n);return Jr(en(l.add(c),43).add(en(d,30)).add(h),l.add(en(c.add(s),18)).add(d),n)}function Pz(t,e=t.length){const n=Pa.fromNumber(81,!0);if(e<=32)return e<=16?Fz(t,e):zz(t,e);if(e<=64)return Lz(t,e);let s=n,r=n.mul(La).add(113),a=dm(r.mul(In).add(113)).mul(In),i=[Pa.UZERO,Pa.UZERO],o=[Pa.UZERO,Pa.UZERO];s=s.mul(In).add(vt(t,0));let u=0;const l=(e-1>>6)*64,c=l+(e-1&63)-63;do s=en(s.add(r).add(i[0]).add(vt(t,u+8)),37).mul(La),r=en(r.add(i[1]).add(vt(t,u+48)),42).mul(La),s=s.xor(o[1]),r=r.add(i[0]).add(vt(t,u+40)),a=en(a.add(o[0]),33).mul(La),i=Yl(t,u,i[1].mul(La),s.add(o[0])),o=Yl(t,u+32,a.add(o[1]),r.add(vt(t,u+16))),[a,s]=[s,a],u+=64;while(u!==l);const d=La.add(a.and(255).shl(1));return u=c,o[0]=o[0].add(e-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),s=en(s.add(r).add(i[0]).add(vt(t,u+8)),37).mul(d),r=en(r.add(i[1]).add(vt(t,u+48)),42).mul(d),s=s.xor(o[1].mul(9)),r=r.add(i[0].mul(9).add(vt(t,u+40))),a=en(a.add(o[0]),33).mul(d),i=Yl(t,u,i[1].mul(d),s.add(o[0])),o=Yl(t,u+32,a.add(o[1]),r.add(vt(t,u+16))),[a,s]=[s,a],Jr(Jr(i[0],o[0],d).add(dm(r).mul(kI)).add(a),Jr(i[1],o[1],d).add(s),d)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ma(t,e){return e==="string"?ea(t):mi([t],e)}function Bz(t,e){return t instanceof Float32Array&&e==="float32"||t instanceof Int32Array&&e==="int32"||t instanceof Uint8Array&&e==="bool"}function mi(t,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=Ja(t)),te().getBool("DEBUG")&&fz(t,e),Bz(t,e))return t;if(e==null||e==="float32"||e==="complex64")return new Float32Array(t);if(e==="int32")return new Int32Array(t);if(e==="bool"){const n=new Uint8Array(t.length);for(let s=0;s<n.length;++s)Math.round(t[s])!==0&&(n[s]=1);return n}else throw new Error(`Unknown data type ${e}`)}function Rn(){return te().platform.now()}function ea(t,e="utf-8"){return e=e||"utf-8",te().platform.encode(t,e)}function sa(t,e="utf-8"){return e=e||"utf-8",te().platform.decode(t,e)}function vs(t){return te().platform.isTypedArray!=null?te().platform.isTypedArray(t):SI(t)}function Ja(t,e=[],n=!1){if(e==null&&(e=[]),typeof t=="boolean"||typeof t=="number"||typeof t=="string"||Qa(t)||t==null||vs(t)&&n)e.push(t);else if(Array.isArray(t)||vs(t))for(let s=0;s<t.length;++s)Ja(t[s],e,n);else{let s=-1;for(const r of Object.keys(t))/^([1-9]+[0-9]*|0)$/.test(r)&&(s=Math.max(s,Number(r)));for(let r=0;r<=s;r++)Ja(t[r],e,n)}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mz{constructor(e,n){this.backendTimer=e,this.logger=n,n==null&&(this.logger=new Wz)}profileKernel(e,n,s){let r;const a=()=>{r=s()};let i;const o=Rn();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(a);else{a();for(const l of r)l.dataSync();i=Promise.resolve({kernelMs:Rn()-o})}if(te().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let l=0;l<r.length;l++){const c=r[l];c.data().then(d=>{Vz(d,c.dtype,e)})}return{kernelName:e,outputs:r,inputs:n,timeMs:i.then(l=>l.kernelMs),extraInfo:i.then(l=>l.getExtraProfileInfo!=null?l.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:n,outputs:s,timeMs:r,inputs:a,extraInfo:i}=e;s.forEach(o=>{Promise.all([o.data(),r,i]).then(u=>{this.logger.logKernelProfile(n,o,u[0],u[1],a,u[2])})})}}function Vz(t,e,n){if(e!=="float32")return!1;for(let s=0;s<t.length;s++){const r=t[s];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}class Wz{logKernelProfile(e,n,s,r,a,i){const o=typeof r=="number"?Bi(`${r}ms`,9):r.error,u=Bi(e,25),l=n.rank,c=n.size,d=Bi(n.shape.toString(),14);let h="";for(const p in a){const f=a[p];if(f!=null){const m=f.shape||n.shape,g=m.length;h+=`${p}: ${g}D ${g>0?m:""} `}}console.log(`%c${u}	%c${o}	%c${l}D ${d}	%c${c}	%c${h}	%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uz(t,e,n){const s={},r={};for(let u=0;u<e.length;u++)s[e[u].id]=!0;for(let u=0;u<t.length;u++){const l=t[u],c=l.inputs;for(const d in c){const h=c[d];let p=!1;for(let f=0;f<e.length;f++)if(s[h.id]){l.outputs.forEach(m=>s[m.id]=!0),p=!0,r[l.id]=!0;break}if(p)break}}const a={};a[n.id]=!0;const i={};for(let u=t.length-1;u>=0;u--){const l=t[u],c=l.inputs;for(let d=0;d<l.outputs.length;d++)if(a[l.outputs[d].id]){for(const h in c)a[c[h].id]=!0,i[l.id]=!0;break}}const o=[];for(let u=0;u<t.length;u++){const l=t[u];if(r[l.id]&&i[l.id]){const c={};for(const h in l.inputs){const p=l.inputs[h];s[p.id]&&(c[h]=p)}const d=Object.assign({},l);d.inputs=c,d.outputs=l.outputs,o.push(d)}}return o}function Gz(t,e,n,s){for(let r=e.length-1;r>=0;r--){const a=e[r],i=[];if(a.outputs.forEach(u=>{const l=t[u.id];l!=null?i.push(l):i.push(null)}),a.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const o=a.gradient(i);for(const u in a.inputs){if(!(u in o))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(o)}.`);const l=n(()=>o[u]());if(l.dtype!=="float32")throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${l.dtype}'`);const c=a.inputs[u];if(!tt(l.shape,c.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${u}' has shape '${l.shape}', which does not match the shape of the input '${c.shape}'`);if(t[c.id]==null)t[c.id]=l;else{const d=t[c.id];t[c.id]=s(d,l),d.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kw=20,No=3,Mp=7;function Hz(t,e,n,s){const r=Ae(e),a=qz(t,e,n,r),i=e.length,o=Ic(t,e,n,r,a),u=["Tensor"];return s&&(u.push(`  dtype: ${n}`),u.push(`  rank: ${i}`),u.push(`  shape: [${e}]`),u.push("  values:")),u.push(o.map(l=>"    "+l).join(`
`)),u.join(`
`)}function qz(t,e,n,s){const r=se(e),a=s[s.length-1],i=new Array(a).fill(0),o=e.length,u=n==="complex64"?Ho(t):t;if(o>1)for(let l=0;l<r/a;l++){const c=l*a;for(let d=0;d<a;d++)i[d]=Math.max(i[d],Go(u[c+d],0,n).length)}return i}function Go(t,e,n){let s;return Array.isArray(t)?s=`${parseFloat(t[0].toFixed(Mp))} + ${parseFloat(t[1].toFixed(Mp))}j`:wu(t)?s=`'${t}'`:n==="bool"?s=TI(t):s=parseFloat(t.toFixed(Mp)).toString(),Bi(s,e)}function TI(t){return t===0?"false":"true"}function Ic(t,e,n,s,r,a=!0){const i=n==="complex64"?2:1,o=e[0],u=e.length;if(u===0){if(n==="complex64"){const m=Ho(t);return[Go(m[0],0,n)]}return n==="bool"?[TI(t[0])]:[t[0].toString()]}if(u===1){if(o>Kw){const g=No*i;let y=Array.from(t.slice(0,g)),b=Array.from(t.slice((o-No)*i,o*i));return n==="complex64"&&(y=Ho(y),b=Ho(b)),["["+y.map(($,w)=>Go($,r[w],n)).join(", ")+", ..., "+b.map(($,w)=>Go($,r[o-No+w],n)).join(", ")+"]"]}return["["+(n==="complex64"?Ho(t):Array.from(t)).map((g,y)=>Go(g,r[y],n)).join(", ")+"]"]}const l=e.slice(1),c=s.slice(1),d=s[0]*i,h=[];if(o>Kw){for(let m=0;m<No;m++){const g=m*d,y=g+d;h.push(...Ic(t.slice(g,y),l,n,c,r,!1))}h.push("...");for(let m=o-No;m<o;m++){const g=m*d,y=g+d;h.push(...Ic(t.slice(g,y),l,n,c,r,m===o-1))}}else for(let m=0;m<o;m++){const g=m*d,y=g+d;h.push(...Ic(t.slice(g,y),l,n,c,r,m===o-1))}const p=u===2?",":"";h[0]="["+(o>0?h[0]+p:"");for(let m=1;m<h.length-1;m++)h[m]=" "+h[m]+p;let f=`,
`;for(let m=2;m<u;m++)f+=`
`;return h[h.length-1]=" "+h[h.length-1]+"]"+(a?"":f),h}function Ho(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jt{constructor(e,n,s){if(this.dtype=n,this.shape=e.slice(),this.size=se(e),s!=null){const r=s.length;O(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(n==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||zt(n,this.size),this.strides=Ae(e)}set(e,...n){n.length===0&&(n=[0]),O(n.length===this.rank,()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`);const s=this.locToIndex(n);this.values[s]=e}get(...e){e.length===0&&(e=[0]);let n=0;for(const r of e){if(r<0||r>=this.shape[n]){const a=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(a)}n++}let s=e[e.length-1];for(let r=0;r<e.length-1;++r)s+=this.strides[r]*e[r];return this.values[s]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let n=e[e.length-1];for(let s=0;s<e.length-1;++s)n+=this.strides[s]*e[s];return n}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const n=new Array(this.shape.length);for(let s=0;s<n.length-1;++s)n[s]=Math.floor(e/this.strides[s]),e-=n[s]*this.strides[s];return n[n.length-1]=e,n}get rank(){return this.shape.length}toTensor(){return Vs().makeTensor(this.values,this.shape,this.dtype)}}let Vs=null,Oi=null;function jz(t){Vs=t}function Kz(t){Oi=t}class _t{constructor(e,n,s,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=n||"float32",this.size=se(e),this.strides=Ae(e),this.dataId=s,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return Oi.buffer(this.shape,this.dtype,e)}bufferSync(){return Oi.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return ws(this.shape,e,this.dtype==="complex64")}arraySync(){return ws(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=Vs().read(this.dataId);if(this.dtype==="string"){const n=await e;try{return n.map(s=>sa(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Vs().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Vs().readSync(this.dataId);if(this.dtype==="string")try{return e.map(n=>sa(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Vs().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Vs().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Oi.print(this,e)}clone(){return this.throwIfDisposed(),Oi.clone(this)}toString(e=!1){const n=this.dataSync();return Hz(n,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Oi.cast(this,e)}variable(e=!0,n,s){return this.throwIfDisposed(),Vs().makeVariable(this,e,n,s)}}Object.defineProperty(_t,Symbol.hasInstance,{value:t=>!!t&&t.data!=null&&t.dataSync!=null&&t.throwIfDisposed!=null});function ae(){return xg("Tensor",()=>_t)}ae();class Wc extends _t{constructor(e,n,s,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=n,this.name=s}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!tt(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Vs().disposeTensor(this),this.dataId=e.dataId,Vs().incRef(this,null)}dispose(){Vs().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Wc,Symbol.hasInstance,{value:t=>t instanceof _t&&t.assign!=null&&t.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Xw;(function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"})(Xw||(Xw={}));var hm;(function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"})(hm||(hm={}));var pm;(function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"})(pm||(pm={}));var fm;(function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"})(fm||(fm={}));var mm;(function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"})(mm||(mm={}));const Xz={float32:fm,int32:hm,bool:pm,complex64:mm};function Hn(t,e){if(t==="string"||e==="string"){if(t==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return Xz[t][e]}function Iy(t){return Hn(t,"int32")}function NI(t){return t!=null&&typeof t=="object"&&"texture"in t&&t.texture instanceof WebGLTexture}function EI(t){return typeof GPUBuffer<"u"&&t!=null&&typeof t=="object"&&"buffer"in t&&t.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dt(t,e){if(t.dtype===e.dtype)return[t,e];const n=Hn(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function Yz(t,e){O(t.dtype===e.dtype,()=>`The dtypes of the first(${t.dtype}) and second(${e.dtype}) input must match`)}function AI(t){const e=[];return RI(t,e,new Set),e}function RI(t,e,n){if(t==null)return;if(t instanceof _t){e.push(t);return}if(!Zz(t))return;const s=t;for(const r in s){const a=s[r];n.has(a)||(n.add(a),RI(a,e,n))}}function Zz(t){return Array.isArray(t)||typeof t=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vp(t){return t.kernelName!=null}class Yw{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class ji{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Yw}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let n=0;n<e.length;n++){const s=e[n];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:n}=this.initializeBackend(e);if(n)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,n,s=1){return e in this.registryFactory?(ts(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:n,priority:s},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:n,asyncInit:s}=this.initializeBackend(e);if(!(s?await n:n))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new Mz(this.backendInstance),!0}setupRegisteredKernels(){Hw(this.backendName).forEach(n=>{n.setupFunc!=null&&n.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){Hw(e).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const n=this.registryFactory[e];if(n==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=n.factory();if(s&&!(s instanceof gg)&&typeof s.then=="function"){const r=++this.pendingBackendInitId,a=s.then(i=>r<this.pendingBackendInitId?!1:(this.registry[e]=i,this.pendingBackendInit=null,!0)).catch(i=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,ts(`Initialization of backend ${e} failed`),ts(i.stack||i.message)),!1));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}else return this.registry[e]=s,{success:!0,asyncInit:!1}}catch(s){return ts(`Initialization of backend ${e} failed`),ts(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,n)=>this.registryFactory[n].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let n=0;n<e.length;n++){const s=e[n],{success:r,asyncInit:a}=this.initializeBackend(s);if(a||r)return{name:s,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,n){const s=this.state.tensorInfo.get(n),r=s.backend,a=this.readSync(n),i=r.refCount(n);r.disposeData(n,!0),s.backend=e,e.move(n,a,s.shape,s.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,n){let s=null;if(n==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");n=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}let r;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(r),()=>(r=n(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(e,n,s){e();try{const r=s();return n(),r}catch(r){throw n(),r}}nextTensorId(){return ji.nextTensorId++}nextVariableId(){return ji.nextVariableId++}clone(e){const n=q.runKernel(Vu,{x:e}),s={x:e},r=i=>({x:()=>{const o="float32",u={x:i},l={dtype:o};return q.runKernel(Tu,u,l)}}),a=[];return this.addTapeNode(this.state.activeScope.name,s,[n],r,a,{}),n}runKernel(e,n,s){if(this.backendName==null&&this.backend,!(cm(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:n,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,n,s){const r=this.backend.numDataIds();let a=0;s.forEach(u=>{a+=u.dtype==="complex64"?3:1});const i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=r-n-a-i;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${e}'`)}runKernelFunc(e){let n,s=[];const r=this.isTapeOn(),a=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName==null&&this.backend;let u;const l=Vp(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(Vp(e)){const{kernelName:f,inputs:m,attrs:g}=e;this.backendName==null&&this.backend;const y=cm(f,this.backendName);O(y!=null,()=>`Cannot find registered kernel '${f}' for backend '${this.backendName}'`),o=()=>{const b=this.backend.numDataIds();u=y.kernelFunc({inputs:m,attrs:g,backend:this.backend});const $=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(f,b,$);const w=$.map(v=>v.rank!=null?v:this.makeTensorFromTensorInfo(v));if(r){const v=this.getTensorsForGradient(f,m,w);s=this.saveTensorsForBackwardMode(v)}return w}}else{const{forwardFunc:f}=e,m=g=>{r&&(s=g.map(y=>this.keep(this.clone(y))))};o=()=>{const g=this.backend.numDataIds();u=this.tidy(()=>f(this.backend,m));const y=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,g,y),y}}const{inputs:c,attrs:d}=e,h=Vp(e)?null:e.backwardsFunc;let p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=o():(p=this.profiler.profileKernel(l,c,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),n=p.outputs)}),r&&this.addTapeNode(l,c,n,h,s,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(f=>c[f]!=null?c[f].shape:null),outputShapes:n.map(f=>f.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(u)?n:n[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,n,s){const r=Gw(e);if(r!=null){const a=r.inputsToSave||[],i=r.outputsToSave||[];let o;r.saveAllInputs?(O(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(n).map(l=>n[l])):o=a.map(l=>n[l]);const u=s.filter((l,c)=>i[c]);return o.concat(u)}return[]}makeTensor(e,n,s,r){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",r=r||this.backend;let a=e;s==="string"&&wu(e[0])&&(a=e.map(u=>ea(u)));const i=r.write(a,n,s),o=new _t(n,s,i,this.nextTensorId());if(this.trackTensor(o,r),s==="string"){const u=this.state.tensorInfo.get(i),l=gz(a);this.state.numBytes+=l-u.bytes,u.bytes=l}return o}makeTensorFromDataId(e,n,s,r){s=s||"float32";const a={dataId:e,shape:n,dtype:s};return this.makeTensorFromTensorInfo(a,r)}makeTensorFromTensorInfo(e,n){const{dataId:s,shape:r,dtype:a}=e,i=new _t(r,a,s,this.nextTensorId());return this.trackTensor(i,n),i}makeVariable(e,n=!0,s,r){s=s||this.nextVariableId().toString(),r!=null&&r!==e.dtype&&(e=e.cast(r));const a=new Wc(e,n,s,this.nextTensorId());if(this.state.registeredVariables[a.name]!=null)throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(e,n){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let s=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(s=e.size*Lc(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:n||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof Wc||this.track(e)}incRef(e,n){this.trackTensor(e,n),this.backend.incRef(e.dataId)}removeDataId(e,n){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===n&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const n=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const s=e.size*Lc(e.dtype);this.state.numBytes-=s}n.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,n.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const n=this.state.registeredVariables[e];this.disposeVariable(n)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const n=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,n,s,r,a,i){const o={id:this.state.nextTapeNodeId++,kernelName:e,inputs:n,outputs:s,saved:a},u=Gw(e);u!=null&&(r=u.gradFunc),r!=null&&(o.gradient=l=>(l=l.map((c,d)=>{if(c==null){const h=s[d],p=xn(h.size,h.dtype);return this.makeTensor(p,h.shape,h.dtype)}return c}),r(l.length>1?l:l[0],a,i))),this.state.activeTape.push(o)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(n.name=e),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(e){const n=AI(e),s=new Set(n.map(a=>a.id));for(let a=0;a<this.state.activeScope.track.length;a++){const i=this.state.activeScope.track[a];!i.kept&&!s.has(i.id)&&i.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(a=>{!a.kept&&a.scopeId===r.id&&this.track(a)})}gradients(e,n,s,r=!1){if(O(n.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const a=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));O(a instanceof _t,()=>"The result y returned by f() must be a tensor.");const i=Uz(this.state.activeTape,n,a);if(!r&&i.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const o={};o[a.id]=s??Qz(a.shape),Gz(o,i,l=>this.tidy(l),Jz);const u=n.map(l=>o[l.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(l=>{for(const c of l.saved)c.dispose()}),this.state.activeTape=null),{value:a,grads:u}})}customGrad(e){return O(rm(e),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{O(n.every(o=>o instanceof _t),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const r={};n.forEach((o,u)=>{r[u]=o});const a=(o,u)=>(s=e(...n,u),O(s.value instanceof _t,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),O(rm(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),i=(o,u)=>{const l=s.gradFunc(o,u),c=Array.isArray(l)?l:[l];O(c.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),O(c.every(h=>h instanceof _t),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const d={};return c.forEach((h,p)=>{d[p]=()=>h}),d};return this.runKernelFunc({forwardFunc:a,backwardsFunc:i,inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,n){return this.state.tensorInfo.get(e).backend.readToGPU(e,n)}async time(e){const n=Rn(),s=await this.backend.time(e);return s.wallMs=Rn()-n,s}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Yw;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}ji.nextTensorId=0;ji.nextVariableId=0;function Qz(t){const e=bg(se(t),"float32");return q.makeTensor(e,t,"float32")}function DI(){const t=wI();if(t._tfengine==null){const e=new xz(t);t._tfengine=new ji(e)}return Sz(t._tfengine.ENV),jz(()=>t._tfengine),t._tfengine}const q=DI();function Jz(t,e){const n={a:t,b:e};return q.runKernel(lo,n)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eL(){return typeof navigator<"u"&&navigator!=null}function OI(t){if(t||eL()){if(t||(t=navigator),t.product==="ReactNative")return!0;const e=t.userAgent||t.vendor||(typeof window<"u"?window.opera:"");if(!e){const n=t;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function FI(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fn=te();Fn.registerFlag("DEBUG",()=>!1,t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Fn.registerFlag("IS_BROWSER",()=>FI());Fn.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");Fn.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Fn.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));Fn.registerFlag("PROD",()=>!1);Fn.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Fn.getBool("DEBUG"));Fn.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Fn.registerFlag("IS_TEST",()=>!1);Fn.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Fn.getBool("DEBUG"));Fn.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Fn.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Fn.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ga(t,e){let n=t;if(vs(t))return e==="string"?[]:[t.length];if(NI(t)){const r=t.channels||"RGBA";return[t.height,t.width*r.length]}else if(EI(t))return[t.buffer.size/(e==null?4:Lc(e))];if(!Array.isArray(t))return[];const s=[];for(;Array.isArray(n)||vs(n)&&e!=="string";)s.push(n.length),n=n[0];return Array.isArray(t)&&te().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&zI(t,s,[]),s}function zI(t,e,n){if(n=n||[],!Array.isArray(t)&&!vs(t)){O(e.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}O(e.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`),O(t.length===e[0],()=>`Element arr[${n.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`);const s=e.slice(1);for(let r=0;r<t.length;++r)zI(t[r],s,n.concat(r))}function Zw(t,e,n,s){if(t!=="string_or_numeric"){if(t==null)throw new Error("Expected dtype cannot be null.");if(t!=="numeric"&&t!==e||t==="numeric"&&e==="string")throw new Error(`Argument '${n}' passed to '${s}' must be ${t} tensor, but got ${e} tensor`)}}function F(t,e,n,s="numeric"){if(t instanceof ae())return Zw(s,t.dtype,e,n),t;let r=oo(t);if(r!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),Zw(s,r,e,n),t==null||!vs(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string"){const u=t==null?"null":t.constructor.name;throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${u}'`)}const a=ga(t,r);!vs(t)&&!Array.isArray(t)&&(t=[t]);const o=r!=="string"?mi(t,r):Ja(t,[],!0);return q.makeTensor(o,a,r)}function Uc(t,e,n,s="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map((a,i)=>F(a,`${e}[${i}]`,n,s))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LI="__op";function U(t){const e=Object.keys(t);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let n=e[0];const s=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+LI;const r=(...a)=>{q.startScope(n);try{const i=s(...a);return Qa(i)&&console.error("Cannot return a Promise inside of tidy."),q.endScope(i),i}catch(i){throw q.endScope(null),i}};return Object.defineProperty(r,"name",{value:n,configurable:!0}),r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tL(t,e){const n=F(t,"real","complex"),s=F(e,"imag","complex");Zn(n.shape,s.shape,`real and imag shapes, ${n.shape} and ${s.shape}, must match in call to tf.complex().`);const r={real:n,imag:s};return q.runKernel(kg,r)}const ra=U({complex_:tL});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ya(t,e,n,s){if(s==null)s=oo(t);else if(s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(EI(t)||NI(t)){if(s!=="float32"&&s!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return q.backend.createTensorFromGPUData(t,e||n,s)}if(!vs(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){is(e);const r=se(e),a=se(n);O(r===a,()=>`Based on the provided shape, [${e}], the tensor should have ${r} values but has ${a}`);for(let i=0;i<n.length;++i){const o=n[i],u=i===n.length-1?o!==se(e.slice(i)):!0;O(n[i]===e[i]||!u,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `)}}return!vs(t)&&!Array.isArray(t)&&(t=[t]),e=e||n,t=s!=="string"?mi(t,s):Ja(t,[],!0),q.makeTensor(t,e,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hs(t,e,n){const s=ga(t,n);return ya(t,e,s,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ei={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class Qs{static join(e){return new Qs(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(s=>vs(s)?s.buffer:s),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let n=0;for(let s=0;s<e.length;s++){const r=e[s];s!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const a=n+r.byteLength;this.shards.push({buffer:r,start:n,end:a}),n=a}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,n=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,n=isNaN(Number(n))?0:n,e=Math.max(0,e),n=Math.min(this.byteLength,n),n<=e)return new ArrayBuffer(0);const s=this.findShardForByte(e);if(s===-1)throw new Error(`Could not find start shard for byte ${e}`);const r=n-e,a=new ArrayBuffer(r),i=new Uint8Array(a);let o=0;for(let u=s;u<this.shards.length;u++){const l=this.shards[u],d=e+o-l.start,h=o,f=Math.min(n,l.end)-l.start,m=new Uint8Array(l.buffer,d,f-d);if(i.set(m,h),o+=m.length,n<l.end)break}return a}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function n(r){return e<r.start?-1:e>=r.end?1:0}if(n(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const s=nL(this.shards,n);return s===-1?-1:(this.previousShardIndex=s,this.previousShardIndex)}}function nL(t,e){let n=0,s=t.length;for(;n<=s;){const r=Math.floor((s-n)/2)+n,a=e(t[r]);if(a===0)return r;a<0?s=r:n=r+1}return-1}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ar(){return q}function Qw(){return q.memory()}function ee(t,e){return q.tidy(t,e)}function Ve(t){AI(t).forEach(n=>n.dispose())}function tn(t){return q.keep(t)}function sL(){return q.ready()}function rL(){return q.backendName}function PI(t,e,n=1){return q.registerBackend(t,e,n)}function BI(){return q.backend}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aa=4;async function gm(t,e){const n=[],s=[],r=Array.isArray(t)?t.map(i=>i.name):Object.keys(t);for(let i=0;i<r.length;++i){const o=r[i],u=Array.isArray(t)?t[i].tensor:t[o];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${o}': ${u.dtype}`);const l={name:o,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){const c=new Promise(async d=>{const h=await u.bytes(),p=h.reduce((g,y)=>g+y.length,0)+aa*h.length,f=new Uint8Array(p);let m=0;for(let g=0;g<h.length;g++){const y=h[g],b=new Uint8Array(new Uint32Array([y.length]).buffer);f.set(b,m),m+=aa,f.set(y,m),m+=y.length}d(f)});s.push(c)}else s.push(u.data());e!=null&&(l.group=e),n.push(l)}const a=await Promise.all(s);return{data:oL(a),specs:n}}function MI(t,e){const n=new Qs(t),s={};let r=0;for(const a of e){const i=aL(a,(o,u)=>n.slice(r+o,r+u));s[a.name]=VI(a,n.slice(r,r+i)),r+=i}return s}function aL(t,e){const n=se(t.shape);let s;if("quantization"in t){const r=t.quantization;s=ei[r.dtype]}else if(t.dtype==="string"){let r=0;for(let a=0;a<n;a++)r+=aa+new Uint32Array(e(r,r+aa))[0];return r}else s=ei[t.dtype];return n*s}async function iL(t,e){const n=se(t.shape);let s;if("quantization"in t){const r=t.quantization;s=ei[r.dtype]}else if(t.dtype==="string"){let r=0;for(let a=0;a<n;a++)r+=aa+new Uint32Array(await e(r,r+aa))[0];return r}else s=ei[t.dtype];return n*s}function VI(t,e){const n=t.name,s=t.dtype,r=t.shape,a=se(r);let i,o=0;if("quantization"in t){const u=t.quantization;if(u.dtype==="uint8"||u.dtype==="uint16"){if(!("min"in u&&"scale"in u))throw new Error(`Weight ${t.name} with quantization ${u.dtype} doesn't have corresponding metadata min and scale.`)}else if(u.dtype==="float16"){if(s!=="float32")throw new Error(`Weight ${t.name} is quantized with ${u.dtype} which only supports weights of type float32 not ${s}.`)}else throw new Error(`Weight ${t.name} has unknown quantization dtype ${u.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const l=ei[u.dtype],c=u.dtype==="uint8"?new Uint8Array(e):new Uint16Array(e);if(s==="float32")if(u.dtype==="uint8"||u.dtype==="uint16"){i=new Float32Array(c.length);for(let d=0;d<c.length;d++){const h=c[d];i[d]=h*u.scale+u.min}}else if(u.dtype==="float16")i=pL()(c);else throw new Error(`Unsupported quantization type ${u.dtype} for weight type float32.`);else if(s==="int32"){if(u.dtype!=="uint8"&&u.dtype!=="uint16")throw new Error(`Unsupported quantization type ${u.dtype} for weight type int32.`);i=new Int32Array(c.length);for(let d=0;d<c.length;d++){const h=c[d];i[d]=Math.round(h*u.scale+u.min)}}else throw new Error(`Unsupported dtype in weight '${n}': ${s}`);o+=a*l}else if(s==="string"){const u=se(t.shape);i=[];for(let l=0;l<u;l++){const c=new Uint32Array(e.slice(o,o+aa))[0];o+=aa;const d=new Uint8Array(e.slice(o,o+c));i.push(d),o+=c}}else{const u=ei[s];if(s==="float32")i=new Float32Array(e);else if(s==="int32")i=new Int32Array(e);else if(s==="bool")i=new Uint8Array(e);else if(s==="complex64"){i=new Float32Array(e);const l=new Float32Array(i.length/2),c=new Float32Array(i.length/2);for(let f=0;f<l.length;f++)l[f]=i[f*2],c[f]=i[f*2+1];const d=Hs(l,r,"float32"),h=Hs(c,r,"float32"),p=ra(d,h);return d.dispose(),h.dispose(),p}else throw new Error(`Unsupported dtype in weight '${n}': ${s}`);o+=a*u}return Hs(i,r,s)}async function Jw(t,e,n){let s=new Uint8Array(e);for(;s.byteLength<n;){const{done:r,value:a}=await t.read();if(r&&a==null){const o=n-s.byteLength;throw new Error(`Reader is done but ${o} bytes are still expected`)}const i=new Uint8Array(s.length+a.byteLength);i.set(s,0),i.set(new Uint8Array(a),s.length),s=i}return s.buffer}async function WI(t,e){const n={},s=t.getReader();let r=new ArrayBuffer(0);for(const a of e){const i=await iL(a,async(l,c)=>(r=await Jw(s,r,c),r.slice(l,c)));r=await Jw(s,r,i);const o=r.slice(0,i);r=r.slice(i);const u=VI(a,o);if(n[a.name]=u,rL()==="webgpu"){const l=BI();"uploadToGPU"in l&&se(u.shape)>=te().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&l.uploadToGPU(u.dataId)}}return n}function oL(t){if(t===null)throw new Error(`Invalid input value: ${JSON.stringify(t)}`);let e=0;const n=[];t.forEach(a=>{if(e+=a.byteLength,n.push(a.byteLength===a.buffer.byteLength?a:new a.constructor(a)),!(a instanceof Float32Array||a instanceof Int32Array||a instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${a.constructor.name}`)});const s=new Uint8Array(e);let r=0;return n.forEach(a=>{s.set(new Uint8Array(a.buffer),r),r+=a.byteLength}),s.buffer}const _y=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function e1(t){return _y?Buffer.byteLength(t,"utf8"):new Blob([t]).size}function uL(t){if(_y)return Buffer.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let s=0,r=e.length;s<r;s++)n+=String.fromCharCode(e[s]);return btoa(n)}function lL(t){if(_y){const s=Buffer.from(t,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let s=0;s<e.length;++s)n.set([e.charCodeAt(s)],s);return n.buffer}function UI(t){return Qs.join(t)}function t1(t){for(t=t.trim();t.endsWith("/");)t=t.slice(0,t.length-1);const n=t.split("/");return n[n.length-1]}function GI(t,e){const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:e};return t.signature!=null&&(n.signature=t.signature),t.userDefinedMetadata!=null&&(n.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(n.modelInitializer=t.modelInitializer),t.initializerSignature!=null&&(n.initializerSignature=t.initializerSignature),t.trainingConfig!=null&&(n.trainingConfig=t.trainingConfig),n}function HI(t,e,n){const s={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};if(t.trainingConfig!=null&&(s.trainingConfig=t.trainingConfig),t.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");s.weightSpecs=e,s.weightData=n}return t.signature!=null&&(s.signature=t.signature),t.userDefinedMetadata!=null&&(s.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(s.modelInitializer=t.modelInitializer),t.initializerSignature!=null&&(s.initializerSignature=t.initializerSignature),s}async function ky(t,e){let n,s;return t.weightsManifest!=null&&([n,s]=await e(t.weightsManifest)),HI(t,n,s)}function gl(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:t.modelTopology==null?0:e1(JSON.stringify(t.modelTopology)),weightSpecsBytes:t.weightSpecs==null?0:e1(JSON.stringify(t.weightSpecs)),weightDataBytes:t.weightData==null?0:new Qs(t.weightData).byteLength}}function ym(t){const e=[];for(const n of t)e.push(...n.weights);return e}function cL(){const t=n=>{let s=n<<13,r=0;for(;(s&8388608)===0;)r-=8388608,s<<=1;return s&=-8388609,r+=947912704,s|r},e=new Uint32Array(2048);e[0]=0;for(let n=1;n<1024;n++)e[n]=t(n);for(let n=1024;n<2048;n++)e[n]=939524096+(n-1024<<13);return e}function dL(){const t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let e=1;e<31;e++)t[e]=e<<23;for(let e=33;e<63;e++)t[e]=2147483648+(e-32<<23);return t}function hL(){const t=new Uint32Array(64);for(let e=0;e<64;e++)t[e]=1024;return t[0]=t[32]=0,t}function pL(){const t=cL(),e=dL(),n=hL();return s=>{const r=new ArrayBuffer(4*s.length),a=new Uint32Array(r);for(let i=0;i<s.length;i++){const o=s[i],u=t[n[o>>10]+(o&1023)]+e[o>>10];a[i]=u}return new Float32Array(r)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Tt{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Tt.instance==null&&(Tt.instance=new Tt),Tt.instance}static registerSaveRouter(e){Tt.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Tt.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Tt.getHandlers(e,"save")}static getLoadHandlers(e,n){return Tt.getHandlers(e,"load",n)}static getHandlers(e,n,s){const r=[];return(n==="load"?Tt.getInstance().loadRouters:Tt.getInstance().saveRouters).forEach(i=>{const o=i(e,s);o!==null&&r.push(o)}),r}}const fL=t=>Tt.registerSaveRouter(t),mL=t=>Tt.registerLoadRouter(t),qI=t=>Tt.getSaveHandlers(t),gL=(t,e)=>Tt.getLoadHandlers(t,e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bm="tensorflowjs",xm=1,Ha="models_store",Yr="model_info_store";function jI(){if(!te().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t=typeof window>"u"?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function wm(t){const e=t.result;e.createObjectStore(Ha,{keyPath:"modelPath"}),e.createObjectStore(Yr,{keyPath:"modelPath"})}class ti{constructor(e){if(this.indexedDB=jI(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,n){return new Promise((s,r)=>{const a=this.indexedDB.open(bm,xm);a.onupgradeneeded=()=>wm(a),a.onsuccess=()=>{const i=a.result;if(n==null){const o=i.transaction(Ha,"readonly"),l=o.objectStore(Ha).get(this.modelPath);l.onsuccess=()=>{if(l.result==null)return i.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(l.result.modelArtifacts)},l.onerror=c=>(i.close(),r(l.error)),o.oncomplete=()=>i.close()}else{n.weightData=Qs.join(n.weightData);const o=gl(n),u=i.transaction(Yr,"readwrite");let l=u.objectStore(Yr),c;try{c=l.put({modelPath:this.modelPath,modelArtifactsInfo:o})}catch(h){return r(h)}let d;c.onsuccess=()=>{d=i.transaction(Ha,"readwrite");const h=d.objectStore(Ha);let p;try{p=h.put({modelPath:this.modelPath,modelArtifacts:n,modelArtifactsInfo:o})}catch(f){return r(f)}p.onsuccess=()=>s({modelArtifactsInfo:o}),p.onerror=f=>{l=u.objectStore(Yr);const m=l.delete(this.modelPath);m.onsuccess=()=>(i.close(),r(p.error)),m.onerror=g=>(i.close(),r(p.error))}},c.onerror=h=>(i.close(),r(c.error)),u.oncomplete=()=>{d==null?i.close():d.oncomplete=()=>i.close()}}},a.onerror=i=>r(a.error)})}}ti.URL_SCHEME="indexeddb://";const KI=t=>te().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(ti.URL_SCHEME)?yL(t.slice(ti.URL_SCHEME.length)):null;Tt.registerSaveRouter(KI);Tt.registerLoadRouter(KI);function yL(t){return new ti(t)}function bL(t){return t.startsWith(ti.URL_SCHEME)?t.slice(ti.URL_SCHEME.length):t}class xL{constructor(){this.indexedDB=jI()}async listModels(){return new Promise((e,n)=>{const s=this.indexedDB.open(bm,xm);s.onupgradeneeded=()=>wm(s),s.onsuccess=()=>{const r=s.result,a=r.transaction(Yr,"readonly"),o=a.objectStore(Yr).getAll();o.onsuccess=()=>{const u={};for(const l of o.result)u[l.modelPath]=l.modelArtifactsInfo;e(u)},o.onerror=u=>(r.close(),n(o.error)),a.oncomplete=()=>r.close()},s.onerror=r=>n(s.error)})}async removeModel(e){return e=bL(e),new Promise((n,s)=>{const r=this.indexedDB.open(bm,xm);r.onupgradeneeded=()=>wm(r),r.onsuccess=()=>{const a=r.result,i=a.transaction(Yr,"readwrite"),o=i.objectStore(Yr),u=o.get(e);let l;u.onsuccess=()=>{if(u.result==null)return a.close(),s(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const c=o.delete(e),d=()=>{l=a.transaction(Ha,"readwrite");const p=l.objectStore(Ha).delete(e);p.onsuccess=()=>n(u.result.modelArtifactsInfo),p.onerror=f=>s(u.error)};c.onsuccess=d,c.onerror=h=>(d(),a.close(),s(u.error))}},u.onerror=c=>(a.close(),s(u.error)),i.oncomplete=()=>{l==null?a.close():l.oncomplete=()=>a.close()}},r.onerror=a=>s(r.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kr="/",Fi="tensorflowjs_models",XI="info",wL="model_topology",$L="weight_specs",vL="weight_data",SL="model_metadata";function YI(t){return{info:[Fi,t,XI].join(kr),topology:[Fi,t,wL].join(kr),weightSpecs:[Fi,t,$L].join(kr),weightData:[Fi,t,vL].join(kr),modelMetadata:[Fi,t,SL].join(kr)}}function ZI(t){for(const e of Object.values(t))window.localStorage.removeItem(e)}function IL(t){const e=t.split(kr);if(e.length<3)throw new Error(`Invalid key format: ${t}`);return e.slice(1,e.length-1).join(kr)}function _L(t){return t.startsWith(ni.URL_SCHEME)?t.slice(ni.URL_SCHEME.length):t}class ni{constructor(e){if(!te().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=YI(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(e.modelTopology),s=JSON.stringify(e.weightSpecs),r=gl(e),a=Qs.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,uL(a));const i={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(i)),{modelArtifactsInfo:r}}catch{throw ZI(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const n={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);n.modelTopology=s;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);n.weightSpecs=r;const a=this.LS.getItem(this.keys.modelMetadata);if(a!=null){const o=JSON.parse(a);n.format=o.format,n.generatedBy=o.generatedBy,n.convertedBy=o.convertedBy,o.signature!=null&&(n.signature=o.signature),o.userDefinedMetadata!=null&&(n.userDefinedMetadata=o.userDefinedMetadata),o.modelInitializer!=null&&(n.modelInitializer=o.modelInitializer),o.initializerSignature!=null&&(n.initializerSignature=o.initializerSignature),o.trainingConfig!=null&&(n.trainingConfig=o.trainingConfig)}const i=this.LS.getItem(this.keys.weightData);if(i==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return n.weightData=lL(i),n}}ni.URL_SCHEME="localstorage://";const QI=t=>te().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(ni.URL_SCHEME)?kL(t.slice(ni.URL_SCHEME.length)):null;Tt.registerSaveRouter(QI);Tt.registerLoadRouter(QI);function kL(t){return new ni(t)}class CL{constructor(){O(te().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),O(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},n=Fi+kr,s=kr+XI;for(let r=0;r<this.LS.length;++r){const a=this.LS.key(r);if(a.startsWith(n)&&a.endsWith(s)){const i=IL(a);e[i]=JSON.parse(this.LS.getItem(a))}}return e}async removeModel(e){e=_L(e);const n=YI(e);if(this.LS.getItem(n.info)==null)throw new Error(`Cannot find model at path '${e}'`);const s=JSON.parse(this.LS.getItem(n.info));return ZI(n),s}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vi="://";class Sn{constructor(){this.managers={}}static getInstance(){return Sn.instance==null&&(Sn.instance=new Sn),Sn.instance}static registerManager(e,n){O(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Vi)&&(e=e.slice(0,e.indexOf(Vi))),O(e.length>0,()=>"scheme must not be an empty string.");const s=Sn.getInstance();O(s.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),s.managers[e]=n}static getManager(e){const n=Sn.getInstance().managers[e];if(n==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return n}static getSchemes(){return Object.keys(Sn.getInstance().managers)}}function _c(t){if(t.indexOf(Vi)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Sn.getSchemes().join(",")}`);return{scheme:t.split(Vi)[0],path:t.split(Vi)[1]}}async function JI(t,e,n=!1){O(t!==e,()=>`Old path and new path are the same: '${t}'`);const s=Tt.getLoadHandlers(t);O(s.length>0,()=>`Copying failed because no load handler is found for source URL ${t}.`),O(s.length<2,()=>`Copying failed because more than one (${s.length}) load handlers for source URL ${t}.`);const r=s[0],a=Tt.getSaveHandlers(e);O(a.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),O(a.length<2,()=>`Copying failed because more than one (${s.length}) save handlers for destination URL ${e}.`);const i=a[0],o=_c(t).scheme,u=_c(t).path,l=o===_c(t).scheme,c=await r.load();n&&l&&await Sn.getManager(o).removeModel(u);const d=await i.save(c);return n&&!l&&await Sn.getManager(o).removeModel(u),d.modelArtifactsInfo}async function TL(){const t=Sn.getSchemes(),e={};for(const n of t){const s=await Sn.getManager(n).listModels();for(const r in s){const a=n+Vi+r;e[a]=s[r]}}return e}async function NL(t){const e=_c(t);return Sn.getManager(e.scheme).removeModel(e.path)}async function EL(t,e){return JI(t,e,!1)}async function AL(t,e){return JI(t,e,!0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RL{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,n){return fetch(e,n)}now(){return performance.now()}encode(e,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${n}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,n){return new TextDecoder(n).decode(e)}setTimeoutCustom(e,n){if(typeof window>"u"||!te().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,n);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},n),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const r=this.functionRefs[s.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return SI(e)}}if(te().get("IS_BROWSER")){te().setPlatform("browser",new RL);try{Sn.registerManager(ni.URL_SCHEME,new CL)}catch{}try{Sn.registerManager(ti.URL_SCHEME,new xL)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DL={importFetch:()=>require("node-fetch")};let Wp;class OL{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,n){return te().global.fetch!=null?te().global.fetch(e,n):(Wp==null&&(Wp=DL.importFetch()),Wp(e,n))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${n}`);return this.textEncoder.encode(e)}decode(e,n){return e.length===0?"":new this.util.TextDecoder(n).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}te().get("IS_NODE")&&!te().get("IS_BROWSER")&&te().setPlatform("node",new OL);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qe(t,e="float32",n){return e=e||"float32",is(t),new jt(t,e,n)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FL(t,e){const n=F(t,"x","cast");if(!mz(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&n.dtype!=="string"||e!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:n},r={dtype:e};return q.runKernel(Tu,s,r)}const ge=U({cast_:FL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zL(t){const n={x:F(t,"x","clone","string_or_numeric")};return q.runKernel(Vu,n)}const Tr=U({clone_:zL});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e_(t,e=!1){console.log(t.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */DI();const LL={buffer:qe,cast:ge,clone:Tr,print:e_};Kz(LL);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PL(t,e){let n=F(t,"a","add"),s=F(e,"b","add");[n,s]=Dt(n,s);const r={a:n,b:s};return q.runKernel(lo,r)}const le=U({add_:PL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BL(t,e){let n=F(t,"a","floorDiv"),s=F(e,"b","floorDiv");[n,s]=Dt(n,s);const r={a:n,b:s};return q.runKernel(Bu,r)}const Cy=U({floorDiv_:BL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ML(t,e){let n=F(t,"a","div"),s=F(e,"b","div");if([n,s]=Dt(n,s),n.dtype==="int32"&&s.dtype==="int32")return Cy(n,s);const r={a:n,b:s},a={};return q.runKernel(Du,r,a)}const Te=U({div_:ML});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VL(t,e){let n=F(t,"a","mul"),s=F(e,"b","mul");[n,s]=Dt(n,s);const r={a:n,b:s};return q.runKernel(Yu,r)}const j=U({mul_:VL});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WL(t){const e=F(t,"x","abs");if(e.dtype==="complex64"){const n={x:e};return q.runKernel(Nd,n)}else{const n={x:e};return q.runKernel(wd,n)}}const Ut=U({abs_:WL});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UL(t){const n={x:F(t,"x","acos")};return q.runKernel($u,n)}const t_=U({acos_:UL});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GL(t){const n={x:F(t,"x","acosh")};return q.runKernel(vu,n)}const n_=U({acosh_:GL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HL(t){O(Array.isArray(t),()=>"The argument passed to tf.addN() must be a list of tensors"),O(t.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${t.length}`);const e=t.map((r,a)=>F(r,`tensors${a}`,"addN")),n=e[0];e.forEach(r=>{if(r.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(r=>{if(!tt(r.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const s=e;return q.runKernel($d,s)}const qL=U({addN_:HL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jL(t,e=null,n=!1){const r={x:F(t,"x","all","bool")},a={axis:e,keepDims:n};return q.runKernel(wg,r,a)}const Ty=U({all_:jL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KL(t,e=null,n=!1){const r={x:F(t,"x","any","bool")},a={axis:e,keepDims:n};return q.runKernel($g,r,a)}const Gc=U({any_:KL});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XL(t,e=0){const s={x:F(t,"x","argMax")},r={axis:e};return q.runKernel(vd,s,r)}const Ki=U({argMax_:XL});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YL(t,e=0){const s={x:F(t,"x","argMin")},r={axis:e};return q.runKernel(Sd,s,r)}const s_=U({argMin_:YL});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZL(t){const n={x:F(t,"x","asin")};return q.runKernel(Su,n)}const r_=U({asin_:ZL});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QL(t){const n={x:F(t,"x","asinh")};return q.runKernel(Iu,n)}const a_=U({asinh_:QL});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JL(t){const n={x:F(t,"x","atan")};return q.runKernel(_u,n)}const i_=U({atan_:JL});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eP(t,e){let n=F(t,"a","atan2"),s=F(e,"b","atan2");[n,s]=Dt(n,s);const r={a:n,b:s};return q.runKernel(Cu,r)}const o_=U({atan2_:eP});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tP(t){const n={x:F(t,"x","atanh")};return q.runKernel(ku,n)}const u_=U({atanh_:tP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yl(t,e,n,s,r="NHWC",a){const i=t[3],o=[...e,i],u=Fr(r);return rn(t,o,n,a,s,null,null,u)}function _s(t,e,n,s,r,a,i="channelsLast"){const[o,u]=su(e);let l;if(i==="channelsLast")l=[o,u,t[3],t[3]];else if(i==="channelsFirst")l=[o,u,t[1],t[1]];else throw new Error(`Unknown dataFormat ${i}`);return rn(t,l,n,s,r,a,!1,i)}function Or(t,e,n,s,r,a,i="NDHWC"){const[o,u,l]=$m(e);let c,d;if(i==="NDHWC")d="channelsLast",c=[o,u,l,t[4],t[4]];else if(i==="NCDHW")d="channelsFirst",c=[o,u,l,t[1],t[1]];else throw new Error(`Unknown dataFormat ${i}`);return ba(t,c,n,s,r,!1,d,a)}function rn(t,e,n,s,r,a,i=!1,o="channelsLast"){let[u,l,c,d]=[-1,-1,-1,-1];if(o==="channelsLast")[u,l,c,d]=t;else if(o==="channelsFirst")[u,d,l,c]=t;else throw new Error(`Unknown dataFormat ${o}`);const[h,p,,f]=e,[m,g]=su(n),[y,b]=su(s),$=Wi(h,y),w=Wi(p,b),{padInfo:v,outHeight:k,outWidth:C}=rP(r,l,c,m,g,$,w,a,o),N=i?f*d:f;let A;return o==="channelsFirst"?A=[u,N,k,C]:o==="channelsLast"&&(A=[u,k,C,N]),{batchSize:u,dataFormat:o,inHeight:l,inWidth:c,inChannels:d,outHeight:k,outWidth:C,outChannels:N,padInfo:v,strideHeight:m,strideWidth:g,filterHeight:h,filterWidth:p,effectiveFilterHeight:$,effectiveFilterWidth:w,dilationHeight:y,dilationWidth:b,inShape:t,outShape:A,filterShape:e}}function ba(t,e,n,s,r,a=!1,i="channelsLast",o){let[u,l,c,d,h]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[u,l,c,d,h]=t;else if(i==="channelsFirst")[u,h,l,c,d]=t;else throw new Error(`Unknown dataFormat ${i}`);const[p,f,m,,g]=e,[y,b,$]=$m(n),[w,v,k]=$m(s),C=Wi(p,w),N=Wi(f,v),A=Wi(m,k),{padInfo:I,outDepth:E,outHeight:z,outWidth:P}=aP(r,l,c,d,y,b,$,C,N,A,o),H=a?g*h:g;let G;return i==="channelsFirst"?G=[u,H,E,z,P]:i==="channelsLast"&&(G=[u,E,z,P,H]),{batchSize:u,dataFormat:i,inDepth:l,inHeight:c,inWidth:d,inChannels:h,outDepth:E,outHeight:z,outWidth:P,outChannels:H,padInfo:I,strideDepth:y,strideHeight:b,strideWidth:$,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:C,effectiveFilterHeight:N,effectiveFilterWidth:A,dilationDepth:w,dilationHeight:v,dilationWidth:k,inShape:t,outShape:G,filterShape:e}}function nP(t,e,n,s,r){s==null&&(s=Ny(t,e,n));const a=t[0],i=t[1],o=ru((a-e+2*s)/n+1,r),u=ru((i-e+2*s)/n+1,r);return[o,u]}function sP(t,e,n,s,r,a){r==null&&(r=Ny(t,e[0],s[0]));const i=[0,0,0,n];for(let o=0;o<3;o++)t[o]+2*r>=e[o]&&(i[o]=ru((t[o]-e[o]+2*r)/s[o]+1,a));return i}function Ny(t,e,n,s=1){const r=Wi(e,s);return Math.floor((t[0]*(n-1)-n+r)/2)}function su(t){return typeof t=="number"?[t,t,t]:t.length===2?[t[0],t[1],1]:t}function $m(t){return typeof t=="number"?[t,t,t]:t}function Wi(t,e){return e<=1?t:t+(t-1)*(e-1)}function rP(t,e,n,s,r,a,i,o,u){let l,c,d;if(typeof t=="number"){l={top:t,bottom:t,left:t,right:t,type:t===0?"VALID":"NUMBER"};const p=nP([e,n],a,s,t,o);c=p[0],d=p[1]}else if(t==="same"){c=Math.ceil(e/s),d=Math.ceil(n/r);const h=Math.max(0,(c-1)*s+a-e),p=Math.max(0,(d-1)*r+i-n),f=Math.floor(h/2),m=h-f,g=Math.floor(p/2),y=p-g;l={top:f,bottom:m,left:g,right:y,type:"SAME"}}else if(t==="valid")l={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((e-a+1)/s),d=Math.ceil((n-i+1)/r);else if(typeof t=="object"){const h=u==="channelsLast"?t[1][0]:t[2][0],p=u==="channelsLast"?t[1][1]:t[2][1],f=u==="channelsLast"?t[2][0]:t[3][0],m=u==="channelsLast"?t[2][1]:t[3][1];l={top:h,bottom:p,left:f,right:m,type:h===0&&p===0&&f===0&&m===0?"VALID":"EXPLICIT"},c=ru((e-a+h+p)/s+1,o),d=ru((n-i+f+m)/r+1,o)}else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:l,outHeight:c,outWidth:d}}function aP(t,e,n,s,r,a,i,o,u,l,c){let d,h,p,f;if(t==="valid"&&(t=0),typeof t=="number"){d={top:t,bottom:t,left:t,right:t,front:t,back:t,type:t===0?"VALID":"NUMBER"};const g=sP([e,n,s,1],[o,u,l],1,[r,a,i],t,c);h=g[0],p=g[1],f=g[2]}else if(t==="same"){h=Math.ceil(e/r),p=Math.ceil(n/a),f=Math.ceil(s/i);const m=(h-1)*r+o-e,g=(p-1)*a+u-n,y=(f-1)*i+l-s,b=Math.floor(m/2),$=m-b,w=Math.floor(g/2),v=g-w,k=Math.floor(y/2),C=y-k;d={top:w,bottom:v,left:k,right:C,front:b,back:$,type:"SAME"}}else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:d,outDepth:h,outHeight:p,outWidth:f}}function ru(t,e){if(!e)return Math.trunc(t);switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${e}`)}}function ia(t){const[e,n,s]=su(t);return e===1&&n===1&&s===1}function pn(t,e){return ia(t)||ia(e)}function si(t){return su(t).every(e=>e>0)}function Fr(t){if(t==="NHWC")return"channelsLast";if(t==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}function Nn(t,e,n){if(n!=null){if(typeof e=="string")throw Error(`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);if(typeof e=="number")O(qi(e),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);else if(typeof e=="object")e.forEach(s=>{s.forEach(r=>{O(qi(r),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${r}.`)})});else throw Error(`Error in ${t}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iP(t,e){const s={x:F(t,"x","reshape","string_or_numeric")},r={shape:e};return q.runKernel(lh,s,r)}const K=U({reshape_:iP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oP(t,e,n,s,r){const a=F(t,"x","avgPool","float32"),i=1;O(pn(n,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);let o=a,u=!1;a.rank===3&&(u=!0,o=K(a,[1,a.shape[0],a.shape[1],a.shape[2]])),O(o.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),Nn("avgPool",s,r);const l={x:o},c={filterSize:e,strides:n,pad:s,dimRoundingMode:r};let d=q.runKernel(Id,l,c);return d=ge(d,a.dtype),u?K(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const Ih=U({avgPool_:oP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uP(t,e,n,s,r,a="NDHWC"){const i=F(t,"x","avgPool3d","float32");let o=i,u=!1;i.rank===4&&(u=!0,o=K(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),O(o.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),O(a==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),O(typeof n=="number"&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),Nn("avgPool3d",s,r);const l={x:o},c={filterSize:e,strides:n,pad:s,dimRoundingMode:r,dataFormat:a};let d=q.runKernel(_d,l,c);return d=ge(d,o.dtype),u?K(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const l_=U({avgPool3d_:uP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lP(t,e=0){O(t.length>=1,()=>"Pass at least one tensor to concat");const n=Uc(t,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(a=>{if(a.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${a.dtype}. `)}),n.length===1)return Tr(n[0]);const s=n,r={axis:e};return q.runKernel(Ed,s,r)}const Wt=U({concat_:lP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cP(t,e,n=!1,s=!1){let r=F(t,"a","matMul"),a=F(e,"b","matMul");[r,a]=Dt(r,a);const i={a:r,b:a},o={transposeA:n,transposeB:s};return q.runKernel(kd,i,o)}const Qe=U({matMul_:cP});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dP(t){const n={x:F(t,"x","sigmoid","float32")};return q.runKernel(ol,n)}const dr=U({sigmoid_:dP});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hP(t,e,n){const s=F(t,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const r={x:s},a={begin:e,size:n};return q.runKernel(fh,r,a)}const nt=U({slice_:hP});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pP(t){const n={x:F(t,"x","tanh","float32")};return q.runKernel(pl,n)}const ri=U({tanh_:pP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fP(t,e,n,s,r,a){const i=F(t,"forgetBias","basicLSTMCell"),o=F(e,"lstmKernel","basicLSTMCell"),u=F(n,"lstmBias","basicLSTMCell"),l=F(s,"data","basicLSTMCell"),c=F(r,"c","basicLSTMCell"),d=F(a,"h","basicLSTMCell"),h=Wt([l,d],1),p=Qe(h,o),f=le(p,u),m=f.shape[0],g=f.shape[1]/4,y=[m,g],b=nt(f,[0,0],y),$=nt(f,[0,g],y),w=nt(f,[0,g*2],y),v=nt(f,[0,g*3],y),k=le(j(dr(b),ri($)),j(c,dr(le(i,w)))),C=j(ri(k),dr(v));return[k,C]}const mP=U({basicLSTMCell_:fP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gP(t,e,n){const s=F(t,"x","batchToSpaceND"),r=e.reduce((o,u)=>o*u);O(s.rank>=1+e.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${e.length}`),O(n.length===e.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${e.length}`),O(s.shape[0]%r===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${r}`);const a={x:s},i={blockShape:e,crops:n};return q.runKernel(Cd,a,i)}const _h=U({batchToSpaceND_:gP});function yP(t){let e;return t.rank===0||t.rank===1?e=K(t,[1,1,1,t.size]):t.rank===2?e=K(t,[1,1,t.shape[0],t.shape[1]]):t.rank===3?e=K(t,[1,t.shape[0],t.shape[1],t.shape[2]]):e=t,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bP(t,e,n,s,r,a){a==null&&(a=.001);const i=F(t,"x","batchNorm"),o=F(e,"mean","batchNorm"),u=F(n,"variance","batchNorm");let l;r!=null&&(l=F(r,"scale","batchNorm"));let c;s!=null&&(c=F(s,"offset","batchNorm")),O(o.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),O(c==null||o.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),O(l==null||o.rank===l.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const h={x:yP(i),scale:l,offset:c,mean:o,variance:u},p={varianceEpsilon:a},f=q.runKernel(Bd,h,p);return K(f,i.shape)}const bl=U({batchNorm_:bP});function xP(t,e,n,s,r,a){const i=F(t,"x","batchNorm"),o=F(e,"mean","batchNorm"),u=F(n,"variance","batchNorm");let l;r!=null&&(l=F(r,"scale","batchNorm"));let c;return s!=null&&(c=F(s,"offset","batchNorm")),O(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),O(o.rank===2||o.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),O(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),l!=null&&O(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&O(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),bl(i,o,u,c,l,a)}const c_=U({batchNorm2d_:xP});function wP(t,e,n,s,r,a){const i=F(t,"x","batchNorm"),o=F(e,"mean","batchNorm"),u=F(n,"variance","batchNorm");let l;r!=null&&(l=F(r,"scale","batchNorm"));let c;return s!=null&&(c=F(s,"offset","batchNorm")),O(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),O(o.rank===3||o.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),O(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),l!=null&&O(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&O(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),bl(i,o,u,c,l,a)}const d_=U({batchNorm3d_:wP});function $P(t,e,n,s,r,a){const i=F(t,"x","batchNorm"),o=F(e,"mean","batchNorm"),u=F(n,"variance","batchNorm");let l;r!=null&&(l=F(r,"scale","batchNorm"));let c;return s!=null&&(c=F(s,"offset","batchNorm")),O(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),O(o.rank===4||o.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),O(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),l!=null&&O(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&O(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),bl(i,o,u,c,l,a)}const h_=U({batchNorm4d_:$P});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vP(t,e,n){const s=F(t,"x","bincount"),r=F(e,"weights","bincount");O(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),O(n>=0,()=>`size must be non-negative, but got ${n}.`),O(r.size===s.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`);const a={x:s,weights:r},i={size:n};return q.runKernel(Ig,a,i)}const p_=U({bincount_:vP});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SP(t,e){const n=F(t,"x","bitwiseAnd"),s=F(e,"y","bitwiseAnd");if(!tt(n.shape,s.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${s.shape}`);if(n.dtype!=="int32"||s.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${s.dtype}`);const r={a:n,b:s};return q.runKernel(Td,r)}const IP=U({bitwiseAnd_:SP});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _P(t,e){const n=F(t,"s0","broadcastArgs","int32"),s=F(e,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(s.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${s.rank}`);const r={s0:n,s1:s};return q.runKernel(_g,r)}const kP=U({broadcastArgs_:_P});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CP(t,e){let n=F(t,"broadcastTo","x");const s=n.shape;if(is(e),e.length<n.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${n.rank}.`);if(e.length>n.rank){const l=n.shape.slice();for(;l.length<e.length;)l.unshift(1);n=K(n,l)}const r=n.shape,a=Array.from(e);for(let l=e.length-1;l>=0;l--)if(r[l]===e[l])a[l]=1;else if(n.shape[l]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${e}].`);if(a.map((l,c)=>l>1?c:-1).filter(l=>l>=0).length===0)return Tr(n);const o={x:n},u={reps:a};return q.runKernel(fl,o,u)}const Ui=U({broadcastTo_:CP});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TP(t){const n={x:F(t,"x","ceil","float32")};return q.runKernel(Nu,n)}const f_=U({ceil_:TP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function co(t,e,n){is(t),n=n||oo(e);const s={shape:t,value:e,dtype:n};return q.runKernel(Mg,{},s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NP(t,e,n){const s=F(t,"x","clipByValue");if(O(e<=n,()=>`Error in clip: min (${e}) must be less than or equal to max (${n}).`),e===n)return co(s.shape,e,s.dtype);const r={x:s},a={clipValueMin:e,clipValueMax:n};return q.runKernel(Eu,r,a)}const qn=U({clipByValue_:NP});function EP(t){return Wt(t,0)}const m_=U({concat1d_:EP});function AP(t,e){return Wt(t,e)}const g_=U({concat2d_:AP});function RP(t,e){return Wt(t,e)}const y_=U({concat3d_:RP});function DP(t,e){return Wt(t,e)}const b_=U({concat4d_:DP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OP(t,e,n,s,r="NHWC",a=[1,1],i){const o=F(t,"x","conv2d","float32"),u=F(e,"filter","conv2d","float32");let l=o,c=!1;o.rank===3&&(c=!0,l=K(o,[1,o.shape[0],o.shape[1],o.shape[2]])),O(l.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`),O(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),Nn("conv2d",s,i);const d=r==="NHWC"?l.shape[3]:l.shape[1];O(d===u.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${u.shape[2]}.`),O(pn(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),O(si(a),()=>"Error in conv2D: Dilated rates should be larger than 0."),O(si(n),()=>"Error in conv2D: Strides should be larger than 0.");const h={x:l,filter:u},p={strides:n,pad:s,dataFormat:r,dilations:a,dimRoundingMode:i},f=q.runKernel(Ad,h,p);return c?K(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const oa=U({conv2d_:OP});function FP(t,e,n,s,r="NWC",a=1,i){const o=F(t,"x","conv1d"),u=F(e,"filter","conv1d");let l=o,c=!1;o.rank===2&&(c=!0,l=K(o,[1,o.shape[0],o.shape[1]])),O(l.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`),O(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),Nn("conv1d",s,i),O(l.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${u.shape[1]}.`),O(pn(n,a),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${a}'`),O(si(a),()=>"Error in conv1D: Dilated rates should be larger than 0."),O(si(n),()=>"Error in conv1D: Stride should be larger than 0."),O(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const d=K(u,[1,u.shape[0],u.shape[1],u.shape[2]]),h=K(l,[l.shape[0],1,l.shape[1],l.shape[2]]),g=oa(h,d,[1,n],s,"NHWC",[1,a],i);return c?K(g,[g.shape[2],g.shape[3]]):K(g,[g.shape[0],g.shape[2],g.shape[3]])}const Ey=U({conv1d_:FP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zP(t,e,n,s,r,a="NHWC",i){O(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let o=t,u=e,l=!1;e.rank===3&&(l=!0,u=K(e,[1,e.shape[0],e.shape[1],e.shape[2]]),o=[1,t[0],t[1],t[2]]),O(o.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),O(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),O(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const c=a==="NHWC"?o[3]:o[1],d=a==="NHWC"?u.shape[3]:u.shape[1];O(c===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`),O(d===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`),Nn("conv2dDerInput",r,i);const h={dy:u,filter:n},p={strides:s,pad:r,dataFormat:a,dimRoundingMode:i,inputShape:o},f=q.runKernel(Rd,h,p);return l?K(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const Ay=U({conv2DBackpropInput_:zP});function LP(t,e,n,s,r,a){const i=F(t,"x","conv2dTranspose"),o=F(e,"filter","conv2dTranspose");return Ay(n,i,o,s,r,"NHWC",a)}const Ry=U({conv2dTranspose_:LP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PP(t,e,n,s,r="NDHWC",a=[1,1,1]){const i=F(t,"x","conv3d"),o=F(e,"filter","conv3d");let u=i,l=!1;i.rank===4&&(l=!0,u=K(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),O(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),O(o.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),O(u.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${o.shape[3]}.`),O(pn(n,a),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),O(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),O(si(a),()=>"Error in conv3D: Dilated rates should be larger than 0."),O(si(n),()=>"Error in conv3D: Strides should be larger than 0.");const c={x:u,filter:o},d={strides:n,pad:s,dataFormat:r,dilations:a},h=q.runKernel(Dd,c,d);return l?K(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const x_=U({conv3d_:PP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BP(t,e,n,s,r){O(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let a=t,i=e,o=!1;e.rank===4&&(o=!0,i=K(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),a=[1,t[0],t[1],t[2],t[3]]);const u=a[4],l=i.shape[4];O(a.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`),O(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),O(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),O(u===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[3]}.`),O(l===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${n.shape[4]}.`);const c={dy:i,filter:n},d={pad:r,strides:s,inputShape:a},h=q.runKernel(Ng,c,d);return o?K(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const w_=U({conv3DBackpropInput_:BP});function MP(t,e,n,s,r){const a=F(t,"x","conv3dTranspose"),i=F(e,"filter","conv3dTranspose");return w_(n,a,i,s,r)}const $_=U({conv3dTranspose_:MP});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VP(t){const n={x:F(t,"x","cos","float32")};return q.runKernel(Au,n)}const kh=U({cos_:VP});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WP(t){const n={x:F(t,"x","cosh","float32")};return q.runKernel(Ru,n)}const Dy=U({cosh_:WP});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UP(t,e=0,n=!1,s=!1){const a={x:F(t,"x","cumprod")},i={axis:e,exclusive:n,reverse:s};return q.runKernel(Eg,a,i)}const Hc=U({cumprod_:UP});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GP(t,e=0,n=!1,s=!1){const a={x:F(t,"x","cumsum")},i={axis:e,exclusive:n,reverse:s};return q.runKernel(Od,a,i)}const Oy=U({cumsum_:GP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HP(t,e,n,s=!1){const r=F(t,"x","denseBincount"),a=F(e,"weights","denseBincount");O(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),O(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),O(n>=0,()=>`size must be non-negative, but got ${n}.`),O(a.size===r.size||a.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${a.shape}.`);const i={x:r,weights:a},o={size:n,binaryOutput:s};return q.runKernel(Rg,i,o)}const vm=U({denseBincount_:HP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qP(t,e,n="NHWC"){const s=F(t,"x","depthToSpace","float32"),r=n==="NHWC"?s.shape[1]:s.shape[2],a=n==="NHWC"?s.shape[2]:s.shape[3],i=n==="NHWC"?s.shape[3]:s.shape[1];O(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),O(r*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${e}  for depthToSpace with input shape
    ${s.shape}`),O(a*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${a} and ${e} for depthToSpace with input shape
        ${s.shape}`),O(i%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${i} for depthToSpace with input shape ${s.shape}`);const o={x:s},u={blockSize:e,dataFormat:n};return q.runKernel(Dg,o,u)}const v_=U({depthToSpace_:qP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jP(t,e,n,s,r="NHWC",a=[1,1],i){const o=F(t,"x","depthwiseConv2d","float32"),u=F(e,"filter","depthwiseConv2d","float32");let l=o,c=!1;o.rank===3&&(c=!0,l=K(o,[1,o.shape[0],o.shape[1],o.shape[2]])),O(l.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`),O(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`);const d=r==="NHWC"?l.shape[3]:l.shape[1];O(d===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${u.shape[2]}.`),Nn("depthwiseConv2d",s,i);const h={x:l,filter:u},p={strides:n,pad:s,dataFormat:r,dilations:a,dimRoundingMode:i},f=q.runKernel(Fd,h,p);return c?K(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const xl=U({depthwiseConv2d_:jP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KP(t){const n={x:F(t,"x","diag")};return q.runKernel(zg,n)}const XP=U({diag_:KP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YP(t,e,n,s,r=[1,1],a="NHWC"){const i=F(t,"x","dilation2d"),o=F(e,"filter","dilation2d");O(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),O(o.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),O(a==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`);let u=i,l=!1;i.rank===3&&(u=K(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=!0),O(u.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${u.shape[3]} vs ${o.shape[2]}`);const c={x:u,filter:o},d={strides:n,pad:s,dilations:r},h=q.runKernel(zd,c,d);return l?K(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const S_=U({dilation2d_:YP});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xi(t,e){const n=t.length,s=[];for(let r=0;r<n;r++){const a=n-1-r,i=t[a]||1;(e[e.length-1-r]||1)>1&&i===1&&s.unshift(a)}return s}function Yt(t,e){const n=[];for(let s=0;s<e.length;s++){const r=t[t.length-s-1],a=e.length-s-1,i=e[a];(r==null||r===1&&i>1)&&n.unshift(a)}return n}function We(t,e){const n=Math.max(t.length,e.length),s=new Array(n);for(let r=0;r<n;r++){let a=t[t.length-r-1];a==null&&(a=1);let i=e[e.length-r-1];if(i==null&&(i=1),a===1)s[n-r-1]=i;else if(i===1)s[n-r-1]=a;else if(a!==i){const o=`Operands could not be broadcast together with shapes ${t} and ${e}.`;throw Error(o)}else s[n-r-1]=a}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZP(t,e){let n=F(t,"a","equal","string_or_numeric"),s=F(e,"b","equal","string_or_numeric");[n,s]=Dt(n,s),We(n.shape,s.shape);const r={a:n,b:s};return q.runKernel(Ld,r)}const Ks=U({equal_:ZP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QP(t,e,n){const s=F(e,"a","where"),r=F(n,"b","where"),a=F(t,"condition","where","bool"),i=We(We(a.shape,s.shape),r.shape),o=Ui(a,i),u=Ui(s,i),l=Ui(r,i),c={condition:o,t:u,e:l};return q.runKernel(ph,c)}const bn=U({where_:QP});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JP(t){const n={x:F(t,"x","zerosLike")};return q.runKernel(vh,n)}const rt=U({zerosLike_:JP});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eB(t,e){let n=F(t,"a","div"),s=F(e,"b","div");[n,s]=Dt(n,s);const r=Te(n,s),a=rt(r),i=Ks(s,a);return bn(i,a,r)}const I_=U({divNoNan_:eB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tB(t,e){const n=F(t,"t1","dot"),s=F(e,"t2","dot");O((n.rank===1||n.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${s.rank}.`);const r=n.rank===1?n.size:n.shape[1],a=s.rank===1?s.size:s.shape[0];if(O(r===a,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${a}.`),n.rank===1&&s.rank===1){const i=K(n,[1,-1]),o=K(s,[-1,1]),u=Qe(i,o);return K(u,[])}else if(n.rank===1&&s.rank===2){const i=K(n,[1,-1]),o=K(s,[s.shape[0],s.shape[1]]),u=Qe(i,o);return K(u,[u.size])}else if(n.rank===2&&s.rank===1){const i=K(s,[-1,1]),o=Qe(n,i);return K(o,[o.size])}else{const i=K(s,[s.shape[0],s.shape[1]]);return Qe(n,i)}}const __=U({dot_:tB});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nB(t,...e){const n=e.map((r,a)=>F(r,`tensors${a}`,"einsum")),s={equation:t};return q.runKernel(Lg,n,s)}const zi=U({einsum_:nB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sB(t){const n={x:F(t,"x","elu","float32")};return q.runKernel(Ou,n)}const wl=U({elu_:sB});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rB(t,e){const n=F(t,"x","ensureShape","string_or_numeric");if(!pz(n.shape,e))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${e}`);return t}const aB=U({ensureShape_:rB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iB(t){let e=F(t,"x","erf");O(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=ge(e,"float32"));const n={x:e};return q.runKernel(Fu,n)}const Fy=U({erf_:iB});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zy(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function k_(t,e,n){const s=t.length+e.length,r=[];let a=0,i=0;for(let o=0;o<s;o++)n.indexOf(o)===-1?r.push(t[a++]):r.push(e[i++]);return r}function an(t,e){const n=[],s=t.length;for(let a=0;a<s;a++)e.indexOf(a)===-1&&n.push(t[a]);const r=e.map(a=>t[a]);return[n,r]}function Lt(t,e){const n=e.map(s=>1);return k_(t,n,e)}function fn(t,e,n){O(zy(e,n),()=>`${t} supports only inner-most axes for now. Got axes ${e} and rank-${n} input.`)}function At(t,e){if(zy(t,e))return null;const n=[];for(let s=0;s<e;++s)t.indexOf(s)===-1&&n.push(s);return t.forEach(s=>n.push(s)),n}function xa(t){return t.map((e,n)=>[n,e]).sort((e,n)=>e[1]-n[1]).map(e=>e[0])}function Pt(t,e){const n=[];for(let s=e-t;s<e;++s)n.push(s);return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oB(t,e=null,n=!1){const r={x:F(t,"x","max")},a={reductionIndices:e,keepDims:n};return q.runKernel(Xd,r,a)}const $s=U({max_:oB});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uB(t,e=null,n=!1){const r={x:F(t,"x","min")},a={axis:e,keepDims:n};return q.runKernel(Jd,r,a)}const au=U({min_:uB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lB(t,e){let n=F(t,"base","pow"),s=F(e,"exp","pow");[n,s]=Dt(n,s);const r={a:n,b:s};return q.runKernel(Zu,r)}const Er=U({pow_:lB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Re(t,e){if((vs(t)&&e!=="string"||Array.isArray(t))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&vs(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return ya(t,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cB(t){const n={x:F(t,"x","sqrt","float32")};return q.runKernel(ll,n)}const hn=U({sqrt_:cB});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dB(t){const e=F(t,"x","square"),n={};return q.runKernel("Square",{x:e},n)}const xt=U({square_:dB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hB(t,e=null,n=!1){let s=F(t,"x","sum");s.dtype==="bool"&&(s=ge(s,"int32"));const r={x:s},a={axis:e,keepDims:n};return q.runKernel(mh,r,a)}const Ie=U({sum_:hB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pB(t,e="euclidean",n=null,s=!1){t=F(t,"x","norm");const r=C_(t,e,n);let a=r.shape;if(s){const i=Ye(n,t.shape);a=Lt(r.shape,i)}return K(r,a)}function C_(t,e,n=null){if(t.rank===0)return Ut(t);if(t.rank!==1&&n===null)return C_(K(t,[-1]),e,n);if(t.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(e===1)return Ie(Ut(t),n);if(e===1/0)return $s(Ut(t),n);if(e===-1/0)return au(Ut(t),n);if(e==="euclidean"||e===2)return hn(Ie(Er(Ut(t),Re(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(n)&&n.length===2){if(e===1)return $s(Ie(Ut(t),n[0]),n[1]-1);if(e===1/0)return $s(Ie(Ut(t),n[1]),n[0]);if(e===-1/0)return au(Ie(Ut(t),n[1]),n[0]);if(e==="fro"||e==="euclidean")return hn(Ie(xt(t),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const $l=U({norm_:pB});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fB(t,e=null,n=!1){return $l(t,"euclidean",e,n)}const T_=U({euclideanNorm_:fB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mB(t){const n={x:F(t,"x","exp")};return q.runKernel(zu,n)}const jn=U({exp_:mB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gB(t,e=0){const n=F(t,"x","expandDims","string_or_numeric");O(e<=n.rank,()=>"Axis must be <= rank of the tensor");const s={input:n},r={dim:e};return q.runKernel(Pd,s,r)}const _n=U({expandDims_:gB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yB(t){const n={x:F(t,"x","expm1")};return q.runKernel(Lu,n)}const N_=U({expm1_:yB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bB(t,e){const n=F(t,"x","tile","string_or_numeric");O(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${e}.`);const s={x:n},r={reps:e};return q.runKernel(fl,s,r)}const gs=U({tile_:bB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xB(t,e,n,s="float32"){e==null&&(e=t);const r=qe([t,e],s),a=t<=e?t:e;for(let o=0;o<a;++o)r.set(1,o,o);const i=K(r.toTensor(),[t,e]);if(n==null)return i;if(n.length===1)return gs(_n(i,0),[n[0],1,1]);if(n.length===2)return gs(_n(_n(i,0),0),[n[0],n[1],1,1]);if(n.length===3)return gs(_n(_n(_n(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}const Ly=U({eye_:xB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wB(t){const n={x:F(t,"x","floor","float32")};return q.runKernel(Pu,n)}const vl=U({floor_:wB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $B(t,e,n=0,s=0){const r=F(t,"x","gather"),a=F(e,"indices","gather","int32"),i={x:r,indices:a},o={axis:n,batchDims:s};return q.runKernel(Md,i,o)}const Sl=U({gather_:$B});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vB(t,e){let n=F(t,"a","greater","string_or_numeric"),s=F(e,"b","greater","string_or_numeric");[n,s]=Dt(n,s),We(n.shape,s.shape);const r={a:n,b:s};return q.runKernel(Vd,r)}const Qn=U({greater_:vB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SB(t,e){let n=F(t,"a","greaterEqual","string_or_numeric"),s=F(e,"b","greaterEqual","string_or_numeric");[n,s]=Dt(n,s),We(n.shape,s.shape);const r={a:n,b:s};return q.runKernel(Mu,r)}const wa=U({greaterEqual_:SB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IB(t){const n={input:F(t,"input","imag")};return q.runKernel(Gg,n)}const Ch=U({imag_:IB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _B(t){const n={x:F(t,"x","isFinite")};return q.runKernel(Wu,n)}const E_=U({isFinite_:_B});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kB(t){const n={x:F(t,"x","isInf")};return q.runKernel(Uu,n)}const A_=U({isInf_:kB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CB(t){const n={x:F(t,"x","isNaN")};return q.runKernel(Gu,n)}const R_=U({isNaN_:CB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TB(t,e=.2){const s={x:F(t,"x","leakyRelu")},r={alpha:e};return q.runKernel(Wd,s,r)}const Th=U({leakyRelu_:TB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NB(t,e){let n=F(t,"a","less","string_or_numeric"),s=F(e,"b","less","string_or_numeric");[n,s]=Dt(n,s),We(n.shape,s.shape);const r={a:n,b:s};return q.runKernel(Ud,r)}const iu=U({less_:NB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EB(t,e){let n=F(t,"a","lessEqual","string_or_numeric"),s=F(e,"b","lessEqual","string_or_numeric");[n,s]=Dt(n,s),We(n.shape,s.shape);const r={a:n,b:s};return q.runKernel(Gd,r)}const gi=U({lessEqual_:EB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AB(t,e,n){if(n<=0)throw new Error("The number of values should be positive.");const s={start:t,stop:e,num:n};return q.runKernel(Hg,{},s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RB(t,e=5,n=1,s=1,r=.5){const a=F(t,"x","localResponseNormalization");O(a.rank===4||a.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${a.rank}.`),O(qi(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let i=a,o=!1;a.rank===3&&(o=!0,i=K(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const u={x:i},l={depthRadius:e,bias:n,alpha:s,beta:r},c=q.runKernel(Kd,u,l);return o?K(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const D_=U({localResponseNormalization_:RB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DB(t){const n={x:F(t,"x","log","float32")};return q.runKernel(Hu,n)}const rs=U({log_:DB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OB(t){const n={x:F(t,"x","log1p")};return q.runKernel(qu,n)}const Nh=U({log1p_:OB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FB(t,e){O(rm(t),()=>"The f passed in variableGrads(f) must be a function"),O(e==null||Array.isArray(e)&&e.every(l=>l instanceof Wc),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=e!=null;if(!n){e=[];for(const l in q.registeredVariables)e.push(q.registeredVariables[l])}const s=n?e.filter(l=>!l.trainable):null,r=e.length;e=e.filter(l=>l.trainable),O(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const a=!0,{value:i,grads:o}=q.gradients(t,e,null,a);O(o.some(l=>l!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),O(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);const u={};return e.forEach((l,c)=>{o[c]!=null&&(u[l.name]=o[c])}),s!=null&&s.forEach(l=>u[l.name]=null),{value:i,grads:u}}function Ar(t){return q.customGrad(t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zB(t){const n={x:F(t,"x","neg")};return q.runKernel(th,n)}const It=U({neg_:zB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LB(t){const n={x:F(t,"x","softplus")};return q.runKernel(ul,n)}const ho=U({softplus_:LB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PB(t){const e=F(t,"x","logSigmoid");return Ar(s=>({value:It(ho(It(s))),gradFunc:i=>j(i,dr(It(s)))}))(e)}const O_=U({logSigmoid_:PB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BB(t,e){let n=F(t,"a","sub"),s=F(e,"b","sub");[n,s]=Dt(n,s);const r={a:n,b:s};return q.runKernel(dl,r)}const we=U({sub_:BB});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MB(t,e=-1){const n=F(t,"logits","logSoftmax");if(e===-1&&(e=n.rank-1),e!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${e}`);return Ar((r,a)=>{const o=$s(r,e,!0),u=we(r,o),l=we(ge(u,"float32"),rs(Ie(jn(u),e,!0)));return a([l]),{value:l,gradFunc:(d,h)=>{const[p]=h,f=!0,m=jn(p);return we(d,j(Ie(d,e,f),m))}}})(n)}const Py=U({logSoftmax_:MB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VB(t,e=null,n=!1){const s=F(t,"x","logSumExp"),r=Ye(e,s.shape),a=$s(s,r,!0),i=we(s,a),o=jn(i),u=Ie(o,r),l=rs(u),c=le(K(a,l.shape),l);if(n){const d=Lt(c.shape,r);return K(c,d)}return c}const Eh=U({logSumExp_:VB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WB(t,e){const n=F(t,"a","logicalAnd","bool"),s=F(e,"b","logicalAnd","bool");We(n.shape,s.shape);const r={a:n,b:s};return q.runKernel(Hd,r)}const mr=U({logicalAnd_:WB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UB(t){const n={x:F(t,"x","logicalNot","bool")};return q.runKernel(qd,n)}const Ah=U({logicalNot_:UB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GB(t,e){const n=F(t,"a","logicalOr","bool"),s=F(e,"b","logicalOr","bool");We(n.shape,s.shape);const r={a:n,b:s};return q.runKernel(jd,r)}const By=U({logicalOr_:GB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HB(t,e){const n=F(t,"a","logicalXor","bool"),s=F(e,"b","logicalXor","bool");return We(n.shape,s.shape),mr(By(t,e),Ah(mr(t,e)))}const F_=U({logicalXor_:HB});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zl=2147483648;function qB(t,e,n="left"){const s=F(t,"sortedSequence","searchSorted"),r=F(e,"values","searchSorted"),a=s.shape[s.shape.length-1],i=r.shape[r.shape.length-1],o=K(s,[-1,a]),u=K(r,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==u.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(se(u.shape)>=Zl)throw new Error(`values tensor size must less than ${Zl}`);if(o.shape[1]>=Zl)throw new Error(`trailing dim_size must less than ${Zl} for int32 output type, was ${o.shape[1]}`);const l={sortedSequence:o,values:u},c={side:n};return q.runKernel(ly,l,c)}const My=U({searchSorted_:qB});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jB(t,e){return My(t,e,"left")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KB(t,e,n,s,r){const a=F(t,"x","maxPool"),i=1;let o=a,u=!1;a.rank===3&&(u=!0,o=K(a,[1,a.shape[0],a.shape[1],a.shape[2]])),O(o.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),O(pn(n,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),Nn("maxPool",s,r);const l={x:o},c={filterSize:e,strides:n,pad:s,dimRoundingMode:r},d=q.runKernel(Yd,l,c);return u?K(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const Rh=U({maxPool_:KB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XB(t,e=[1,1,1],n,s,r,a="NDHWC"){const i=F(t,"x","maxPool3d");let o=i,u=!1;i.rank===4&&(u=!0,o=K(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),O(o.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),O(a==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),Nn("maxPool3d",s,r);const l={x:o},c={filterSize:e,strides:n,pad:s,dimRoundingMode:r,dataFormat:a},d=q.runKernel(Zd,l,c);return u?K(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const z_=U({maxPool3d_:XB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YB(t,e,n,s,r=!1){const i={x:F(t,"x","maxPoolWithArgmax")},o={filterSize:e,strides:n,pad:s,includeBatchInIndex:r},u=q.runKernel(Xg,i,o);return{result:u[0],indexes:u[1]}}const ZB=U({maxPoolWithArgmax_:YB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QB(t,e){let n=F(t,"a","maximum"),s=F(e,"b","maximum");[n,s]=Dt(n,s),n.dtype==="bool"&&(n=ge(n,"int32"),s=ge(s,"int32")),We(n.shape,s.shape);const r={a:n,b:s};return q.runKernel(ju,r)}const zr=U({maximum_:QB});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JB(t,e=null,n=!1){const r={x:F(t,"x","mean")},a={axis:e,keepDims:n};return q.runKernel(Qd,r,a)}const Rt=U({mean_:JB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gt(t,e="float32"){if(is(t),e==="complex64"){const s=Gt(t,"float32"),r=Gt(t,"float32");return ra(s,r)}const n=xn(se(t),e);return q.makeTensor(n,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Un(t,e="float32"){if(is(t),e==="complex64"){const s=Un(t,"float32"),r=Gt(t,"float32");return ra(s,r)}const n=bg(se(t),e);return q.makeTensor(n,t,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eM(t,e,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(t===void 0)return[];let s=F(t,"x","meshgrid",t instanceof _t?t.dtype:"float32");if(e===void 0)return[s];let r=F(e,"y","meshgrid",e instanceof _t?e.dtype:"float32");const a=se(s.shape),i=se(r.shape);return n==="xy"?(s=K(s,[1,-1]),r=K(r,[-1,1]),[Qe(Un([i,1],s.dtype),s),Qe(r,Un([1,a],r.dtype))]):(s=K(s,[-1,1]),r=K(r,[1,-1]),[Qe(s,Un([1,i],s.dtype)),Qe(Un([a,1],r.dtype),r)])}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tM(t,e){let n=F(t,"a","minimum"),s=F(e,"b","minimum");[n,s]=Dt(n,s),n.dtype==="bool"&&(n=ge(n,"int32"),s=ge(s,"int32")),We(n.shape,s.shape);const r={a:n,b:s};return q.runKernel(Ku,r)}const ai=U({minimum_:tM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nM(t,e,n){O(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const s=F(t,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");O(e.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${e.length}.`);const r=n==="reflect"?1:0;for(let o=0;o<s.rank;o++)O(e[o].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),O(e[o][0]>=0&&e[o][0]<=s.shape[o]-r&&e[o][1]>=0&&e[o][1]<=s.shape[o]-r,()=>`Padding in dimension ${o} cannot be greater than or equal to ${s.shape[o]-r} or less than 0 for input of shape ${s.shape}`);const a={paddings:e,mode:n},i={x:s};return q.runKernel(eh,i,a)}const L_=U({mirrorPad_:nM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sM(t,e){let n=F(t,"a","mod"),s=F(e,"b","mod");[n,s]=Dt(n,s);const r={a:n,b:s};return q.runKernel(Xu,r)}const P_=U({mod_:sM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rM(t,e=null,n=!1){t=F(t,"x","moments");const s=Ye(e,t.shape),r=Rt(t,s,n);let a=r.shape;n||(a=Lt(r.shape,s));const i=xt(we(ge(t,"float32"),K(r,a))),o=Rt(i,s,n);return{mean:r,variance:o}}const Dh=U({moments_:rM});function aM(t,e,n,s){const r=F(e,"data","multiRNNCell"),a=Uc(n,"c","multiRNNCell"),i=Uc(s,"h","multiRNNCell");let o=r;const u=[];for(let d=0;d<t.length;d++){const h=t[d](o,a[d],i[d]);u.push(h[0]),u.push(h[1]),o=h[1]}const l=[],c=[];for(let d=0;d<u.length;d+=2)l.push(u[d]),c.push(u[d+1]);return[l,c]}const iM=U({multiRNNCell_:aM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oM(t,e,n,s=!1){const r=F(t,"logits","multinomial"),a=r.size,i=r.rank;if(a<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${a}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();const u={logits:i===1?K(r,[1,-1]):r},l={numSamples:e,seed:n,normalized:s},c=q.runKernel(Yg,u,l);return i===1?K(c,[c.size]):c}const uM=U({multinomial_:oM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lM(t,e){let n=F(t,"a","notEqual","string_or_numeric"),s=F(e,"b","notEqual","string_or_numeric");[n,s]=Dt(n,s),We(n.shape,s.shape);const r={a:n,b:s};return q.runKernel(nh,r)}const Yi=U({notEqual_:lM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cM(t,e,n=1,s=0,r="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const i={indices:F(t,"indices","oneHot","int32")},o={dtype:r,depth:e,onValue:n,offValue:s};return q.runKernel(rh,i,o)}const Vy=U({oneHot_:cM});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dM(t){const n={x:F(t,"x","onesLike")};return q.runKernel(sh,n)}const as=U({onesLike_:dM});function hM(t,e){const n=F(t,"v1","outerProduct"),s=F(e,"v2","outerProduct");O(n.rank===1&&s.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${s.rank}.`);const r=K(n,[-1,1]),a=K(s,[1,-1]);return Qe(r,a)}const pM=U({outerProduct_:hM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fM(t,e,n=0){const s=F(t,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:e,constantValue:n},a={x:s};return q.runKernel(ih,a,r)}const $a=U({pad_:fM});function mM(t,e,n=0){return O(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),$a(t,[e],n)}const gM=U({pad1d_:mM});function yM(t,e,n=0){return O(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),$a(t,e,n)}const bM=U({pad2d_:yM});function xM(t,e,n=0){return O(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),$a(t,e,n)}const wM=U({pad3d_:xM});function $M(t,e,n=0){return O(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),$a(t,e,n)}const vM=U({pad4d_:$M});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SM(t,e,n){const s=F(t,"x","spaceToBatchND");O(s.rank>=1+e.length,()=>`input rank ${s.rank} should be > than [blockShape] ${e.length}`),O(n.length===e.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${e.length}`),O(s.shape.reduce((i,o,u)=>u>0&&u<=e.length?i&&(o+n[u-1][0]+n[u-1][1])%e[u-1]===0:i,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${e.toString()}`);const r={x:s},a={blockShape:e,paddings:n};return q.runKernel(gh,r,a)}const Oh=U({spaceToBatchND_:SM});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IM(t,e,n,s,r,a,i){r==null&&(r=[1,1]),a==null&&(a=1),s===0&&(s="valid");const o=F(t,"x","maxPool");let u=o,l=!1;o.rank===3&&(l=!0,u=K(o,[1,o.shape[0],o.shape[1],o.shape[2]])),O(pn(a,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${r}'`);const c=_s(u.shape,e,a,r,s),d=[c.dilationHeight,c.dilationWidth];let h;s==="same"?h=kM([c.filterHeight,c.filterWidth],d):h=[[0,0],[0,0]];const p=d[0]===1&&d[1]===1,[f,m]=_M([c.inHeight,c.inWidth],d,h),g=p?s:"valid",y=p?u:Oh(u,d,f),$=(n==="avg"?()=>Ih(y,e,a,g,i):()=>Rh(y,e,a,g,i))(),w=p?$:_h($,d,m);return l?K(w,[w.shape[1],w.shape[2],w.shape[3]]):w}function _M(t,e,n){const s=n.map(c=>c[0]),r=n.map(c=>c[1]),a=t.concat(s,r),i=e.map((c,d)=>(c-a[d]%c)%c),o=r.map((c,d)=>c+i[d]),u=e.map((c,d)=>[s[d],o[d]]),l=e.map((c,d)=>[0,i[d]]);return[u,l]}function kM(t,e){const s=t.map((i,o)=>i+(i-1)*(e[o]-1)).map(i=>i-1),r=s.map(i=>Math.floor(i/2)),a=s.map((i,o)=>i-r[o]);return s.map((i,o)=>[r[o],a[o]])}const B_=U({pool_:IM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CM(t,e){const n=F(t,"x","prelu"),s=F(e,"alpha","prelu"),r={x:n,alpha:s};return q.runKernel(oh,r)}const Fh=U({prelu_:CM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TM(t,e=null,n=!1){let s=F(t,"x","prod");s.dtype==="bool"&&(s=ge(s,"int32"));const r={x:s},a={axis:e,keepDims:n};return q.runKernel(uh,r,a)}const M_=U({prod_:TM});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NM(t,e,n,s){const r=t.map((c,d)=>F(c,`tensors${d}`,"raggedGather","int32")),a=F(e,"paramsDenseValues","raggedGather"),i=F(n,"indices","raggedGather","int32"),o={paramsNestedSplits:r,paramsDenseValues:a,indices:i},u={outputRaggedRank:s},l=q.runKernel(ey,o,u);return{outputNestedSplits:l.slice(0,l.length-1),outputDenseValues:l[l.length-1]}}const EM=U({raggedGather_:NM});/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AM(t,e,n){const s=F(t,"starts","raggedRange"),r=F(e,"limits","raggedRange",s.dtype),a=F(n,"deltas","raggedRange",s.dtype),i={starts:s,limits:r,deltas:a},o=q.runKernel(ty,i);return{rtNestedSplits:o[0],rtDenseValues:o[1]}}const RM=U({raggedRange_:AM});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DM(t,e,n,s,r){const a=F(t,"shape","raggedTensorToTensor","int32"),i=F(e,"values","raggedTensorToTensor"),o=F(n,"defaultValue","raggedTensorToTensor",i.dtype),u=s.map((d,h)=>F(d,`tensors${h}`,"raggedTensorToTensor","int32")),l={shape:a,values:i,defaultValue:o,rowPartitionTensors:u},c={rowPartitionTypes:r};return q.runKernel(ny,l,c)}const OM=U({raggedTensorToTensor_:DM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FM(t,e,n){is(t);const s=se(t);let r=null;if(n==null||n==="float32")r=new Float32Array(s);else if(n==="int32")r=new Int32Array(s);else if(n==="bool")r=new Uint8Array(s);else throw new Error(`Unknown data type ${n}`);for(let a=0;a<s;a++)r[a]=e();return q.makeTensor(r,t,n)}const zM=U({rand_:FM});var kc={exports:{}},LM=kc.exports,n1;function PM(){return n1||(n1=1,function(t){(function(e,n,s){function r(u){var l=this,c=o();l.next=function(){var d=2091639*l.s0+l.c*23283064365386963e-26;return l.s0=l.s1,l.s1=l.s2,l.s2=d-(l.c=d|0)},l.c=1,l.s0=c(" "),l.s1=c(" "),l.s2=c(" "),l.s0-=c(u),l.s0<0&&(l.s0+=1),l.s1-=c(u),l.s1<0&&(l.s1+=1),l.s2-=c(u),l.s2<0&&(l.s2+=1),c=null}function a(u,l){return l.c=u.c,l.s0=u.s0,l.s1=u.s1,l.s2=u.s2,l}function i(u,l){var c=new r(u),d=l&&l.state,h=c.next;return h.int32=function(){return c.next()*4294967296|0},h.double=function(){return h()+(h()*2097152|0)*11102230246251565e-32},h.quick=h,d&&(typeof d=="object"&&a(d,c),h.state=function(){return a(c,{})}),h}function o(){var u=4022871197,l=function(c){c=String(c);for(var d=0;d<c.length;d++){u+=c.charCodeAt(d);var h=.02519603282416938*u;u=h>>>0,h-=u,h*=u,u=h>>>0,h-=u,u+=h*4294967296}return(u>>>0)*23283064365386963e-26};return l}n&&n.exports?n.exports=i:this.alea=i})(LM,t)}(kc)),kc.exports}var Cc={exports:{}},BM=Cc.exports,s1;function MM(){return s1||(s1=1,function(t){(function(e,n,s){function r(o){var u=this,l="";u.x=0,u.y=0,u.z=0,u.w=0,u.next=function(){var d=u.x^u.x<<11;return u.x=u.y,u.y=u.z,u.z=u.w,u.w^=u.w>>>19^d^d>>>8},o===(o|0)?u.x=o:l+=o;for(var c=0;c<l.length+64;c++)u.x^=l.charCodeAt(c)|0,u.next()}function a(o,u){return u.x=o.x,u.y=o.y,u.z=o.z,u.w=o.w,u}function i(o,u){var l=new r(o),c=u&&u.state,d=function(){return(l.next()>>>0)/4294967296};return d.double=function(){do var h=l.next()>>>11,p=(l.next()>>>0)/4294967296,f=(h+p)/(1<<21);while(f===0);return f},d.int32=l.next,d.quick=d,c&&(typeof c=="object"&&a(c,l),d.state=function(){return a(l,{})}),d}n&&n.exports?n.exports=i:this.xor128=i})(BM,t)}(Cc)),Cc.exports}var Tc={exports:{}},VM=Tc.exports,r1;function WM(){return r1||(r1=1,function(t){(function(e,n,s){function r(o){var u=this,l="";u.next=function(){var d=u.x^u.x>>>2;return u.x=u.y,u.y=u.z,u.z=u.w,u.w=u.v,(u.d=u.d+362437|0)+(u.v=u.v^u.v<<4^(d^d<<1))|0},u.x=0,u.y=0,u.z=0,u.w=0,u.v=0,o===(o|0)?u.x=o:l+=o;for(var c=0;c<l.length+64;c++)u.x^=l.charCodeAt(c)|0,c==l.length&&(u.d=u.x<<10^u.x>>>4),u.next()}function a(o,u){return u.x=o.x,u.y=o.y,u.z=o.z,u.w=o.w,u.v=o.v,u.d=o.d,u}function i(o,u){var l=new r(o),c=u&&u.state,d=function(){return(l.next()>>>0)/4294967296};return d.double=function(){do var h=l.next()>>>11,p=(l.next()>>>0)/4294967296,f=(h+p)/(1<<21);while(f===0);return f},d.int32=l.next,d.quick=d,c&&(typeof c=="object"&&a(c,l),d.state=function(){return a(l,{})}),d}n&&n.exports?n.exports=i:this.xorwow=i})(VM,t)}(Tc)),Tc.exports}var Nc={exports:{}},UM=Nc.exports,a1;function GM(){return a1||(a1=1,function(t){(function(e,n,s){function r(o){var u=this;u.next=function(){var c=u.x,d=u.i,h,p;return h=c[d],h^=h>>>7,p=h^h<<24,h=c[d+1&7],p^=h^h>>>10,h=c[d+3&7],p^=h^h>>>3,h=c[d+4&7],p^=h^h<<7,h=c[d+7&7],h=h^h<<13,p^=h^h<<9,c[d]=p,u.i=d+1&7,p};function l(c,d){var h,p=[];if(d===(d|0))p[0]=d;else for(d=""+d,h=0;h<d.length;++h)p[h&7]=p[h&7]<<15^d.charCodeAt(h)+p[h+1&7]<<13;for(;p.length<8;)p.push(0);for(h=0;h<8&&p[h]===0;++h);for(h==8?p[7]=-1:p[h],c.x=p,c.i=0,h=256;h>0;--h)c.next()}l(u,o)}function a(o,u){return u.x=o.x.slice(),u.i=o.i,u}function i(o,u){o==null&&(o=+new Date);var l=new r(o),c=u&&u.state,d=function(){return(l.next()>>>0)/4294967296};return d.double=function(){do var h=l.next()>>>11,p=(l.next()>>>0)/4294967296,f=(h+p)/(1<<21);while(f===0);return f},d.int32=l.next,d.quick=d,c&&(c.x&&a(c,l),d.state=function(){return a(l,{})}),d}n&&n.exports?n.exports=i:this.xorshift7=i})(UM,t)}(Nc)),Nc.exports}var Ec={exports:{}},HM=Ec.exports,i1;function qM(){return i1||(i1=1,function(t){(function(e,n,s){function r(o){var u=this;u.next=function(){var c=u.w,d=u.X,h=u.i,p,f;return u.w=c=c+1640531527|0,f=d[h+34&127],p=d[h=h+1&127],f^=f<<13,p^=p<<17,f^=f>>>15,p^=p>>>12,f=d[h]=f^p,u.i=h,f+(c^c>>>16)|0};function l(c,d){var h,p,f,m,g,y=[],b=128;for(d===(d|0)?(p=d,d=null):(d=d+"\0",p=0,b=Math.max(b,d.length)),f=0,m=-32;m<b;++m)d&&(p^=d.charCodeAt((m+32)%d.length)),m===0&&(g=p),p^=p<<10,p^=p>>>15,p^=p<<4,p^=p>>>13,m>=0&&(g=g+1640531527|0,h=y[m&127]^=p+g,f=h==0?f+1:0);for(f>=128&&(y[(d&&d.length||0)&127]=-1),f=127,m=512;m>0;--m)p=y[f+34&127],h=y[f=f+1&127],p^=p<<13,h^=h<<17,p^=p>>>15,h^=h>>>12,y[f]=p^h;c.w=g,c.X=y,c.i=f}l(u,o)}function a(o,u){return u.i=o.i,u.w=o.w,u.X=o.X.slice(),u}function i(o,u){o==null&&(o=+new Date);var l=new r(o),c=u&&u.state,d=function(){return(l.next()>>>0)/4294967296};return d.double=function(){do var h=l.next()>>>11,p=(l.next()>>>0)/4294967296,f=(h+p)/(1<<21);while(f===0);return f},d.int32=l.next,d.quick=d,c&&(c.X&&a(c,l),d.state=function(){return a(l,{})}),d}n&&n.exports?n.exports=i:this.xor4096=i})(HM,t)}(Ec)),Ec.exports}var Ac={exports:{}},jM=Ac.exports,o1;function KM(){return o1||(o1=1,function(t){(function(e,n,s){function r(o){var u=this,l="";u.next=function(){var d=u.b,h=u.c,p=u.d,f=u.a;return d=d<<25^d>>>7^h,h=h-p|0,p=p<<24^p>>>8^f,f=f-d|0,u.b=d=d<<20^d>>>12^h,u.c=h=h-p|0,u.d=p<<16^h>>>16^f,u.a=f-d|0},u.a=0,u.b=0,u.c=-1640531527,u.d=1367130551,o===Math.floor(o)?(u.a=o/4294967296|0,u.b=o|0):l+=o;for(var c=0;c<l.length+20;c++)u.b^=l.charCodeAt(c)|0,u.next()}function a(o,u){return u.a=o.a,u.b=o.b,u.c=o.c,u.d=o.d,u}function i(o,u){var l=new r(o),c=u&&u.state,d=function(){return(l.next()>>>0)/4294967296};return d.double=function(){do var h=l.next()>>>11,p=(l.next()>>>0)/4294967296,f=(h+p)/(1<<21);while(f===0);return f},d.int32=l.next,d.quick=d,c&&(typeof c=="object"&&a(c,l),d.state=function(){return a(l,{})}),d}n&&n.exports?n.exports=i:this.tychei=i})(jM,t)}(Ac)),Ac.exports}var Rc={exports:{}};const XM={},YM=Object.freeze(Object.defineProperty({__proto__:null,default:XM},Symbol.toStringTag,{value:"Module"})),ZM=Az(YM);var QM=Rc.exports,u1;function JM(){return u1||(u1=1,function(t){(function(e,n,s){var r=256,a=6,i=52,o="random",u=s.pow(r,a),l=s.pow(2,i),c=l*2,d=r-1,h;function p(w,v,k){var C=[];v=v==!0?{entropy:!0}:v||{};var N=y(g(v.entropy?[w,$(n)]:w??b(),3),C),A=new f(C),I=function(){for(var E=A.g(a),z=u,P=0;E<l;)E=(E+P)*r,z*=r,P=A.g(1);for(;E>=c;)E/=2,z/=2,P>>>=1;return(E+P)/z};return I.int32=function(){return A.g(4)|0},I.quick=function(){return A.g(4)/4294967296},I.double=I,y($(A.S),n),(v.pass||k||function(E,z,P,H){return H&&(H.S&&m(H,A),E.state=function(){return m(A,{})}),P?(s[o]=E,z):E})(I,N,"global"in v?v.global:this==s,v.state)}function f(w){var v,k=w.length,C=this,N=0,A=C.i=C.j=0,I=C.S=[];for(k||(w=[k++]);N<r;)I[N]=N++;for(N=0;N<r;N++)I[N]=I[A=d&A+w[N%k]+(v=I[N])],I[A]=v;(C.g=function(E){for(var z,P=0,H=C.i,G=C.j,W=C.S;E--;)z=W[H=d&H+1],P=P*r+W[d&(W[H]=W[G=d&G+z])+(W[G]=z)];return C.i=H,C.j=G,P})(r)}function m(w,v){return v.i=w.i,v.j=w.j,v.S=w.S.slice(),v}function g(w,v){var k=[],C=typeof w,N;if(v&&C=="object")for(N in w)try{k.push(g(w[N],v-1))}catch{}return k.length?k:C=="string"?w:w+"\0"}function y(w,v){for(var k=w+"",C,N=0;N<k.length;)v[d&N]=d&(C^=v[d&N]*19)+k.charCodeAt(N++);return $(v)}function b(){try{var w;return h&&(w=h.randomBytes)?w=w(r):(w=new Uint8Array(r),(e.crypto||e.msCrypto).getRandomValues(w)),$(w)}catch{var v=e.navigator,k=v&&v.plugins;return[+new Date,e,k,e.screen,$(n)]}}function $(w){return String.fromCharCode.apply(0,w)}if(y(s.random(),n),t.exports){t.exports=p;try{h=ZM}catch{}}else s["seed"+o]=p})(typeof self<"u"?self:QM,[],Math)}(Rc)),Rc.exports}var Up,l1;function e4(){if(l1)return Up;l1=1;var t=PM(),e=MM(),n=WM(),s=GM(),r=qM(),a=KM(),i=JM();return i.alea=t,i.xor128=e,i.xorwow=n,i.xorshift7=s,i.xor4096=r,i.tychei=a,Up=i,Up}var zh=e4();/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wy{constructor(e,n,s,r,a){this.mean=e,this.stdDev=n,this.dtype=s,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const i=a||Math.random();this.random=zh.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let e,n,s=!1;for(;!s;){let r,a,i;do r=2*this.random()-1,a=2*this.random()-1,i=r*r+a*a;while(i>=1||i===0);const o=Math.sqrt(-2*Math.log(i)/i);e=this.mean+this.stdDev*r*o,n=this.mean+this.stdDev*a*o,(!this.truncated||this.isValidTruncated(e))&&(s=!0)}return(!this.truncated||this.isValidTruncated(n))&&(this.nextVal=this.convertValue(n)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class t4{constructor(e,n,s,r){this.alpha=e,this.beta=1/n,this.dtype=s;const a=r||Math.random();this.randu=zh.alea(a.toString()),this.randn=new Wy(0,1,s,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,n,s,r,a,i;for(;;){do r=this.randn.nextValue(),i=1+this.c*r;while(i<=0);if(i*=i*i,e=r*r,n=1-.331*e*e,s=.5*e+this.d*(1-i+Math.log(i)),a=this.randu(),a<n||Math.log(a)<s)break}return i=1/this.beta*this.d*i,this.alpha<1&&(i*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(i)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class n4{constructor(e=0,n=1,s,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=n-e,this.dtype=s,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${n} <= 1 and dtype is not float`);this.random=zh.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s4(t,e,n=1,s="float32",r){if(is(t),n==null&&(n=1),s==null&&(s="float32"),s!=="float32"&&s!=="int32")throw new Error(`Unsupported data type ${s}`);const a=new t4(e,n,s,r),i=qe(t,s);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}const r4=U({randomGamma_:s4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a4(t,e=0,n=1,s,r){if(is(t),s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const a=new Wy(e,n,s,!1,r),i=qe(t,s);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}const Uy=U({randomNormal_:a4});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i4(t,e,n){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return Uy(t,0,1,e,n)}const o4=U({randomStandardNormal_:i4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u4(t,e=0,n=1,s="float32",r){is(t);const a=qe(t,s),i=new n4(e,n,null,r);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}const yi=U({randomUniform_:u4});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l4(t,e,n,s){return yi(t,e,n,"int32",s)}const c4=U({randomUniformInt_:l4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zi(t,e,n=1,s="float32"){if(n===0)throw new Error("Cannot have a step of zero");const r={start:t,stop:e,step:n,dtype:s};return q.runKernel(sy,{},r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d4(t){const n={input:F(t,"input","real")};return q.runKernel(ry,n)}const ou=U({real_:d4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h4(t){const n={x:F(t,"x","reciprocal")};return q.runKernel(Qu,n)}const V_=U({reciprocal_:h4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p4(t){const n={x:F(t,"x","relu")};return q.runKernel(Ju,n)}const xr=U({relu_:p4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f4(t){const n={x:F(t,"x","relu6")};return q.runKernel(el,n)}const Gy=U({relu6_:f4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m4(t,e){const s={x:F(t,"x","reverse")},r={dims:e};return q.runKernel(hh,s,r)}const Ss=U({reverse_:m4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g4(t){const e=F(t,"x","reverse");return O(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),Ss(e,0)}const y4=U({reverse1d_:g4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b4(t,e){const n=F(t,"x","reverse");return O(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),Ss(n,e)}const x4=U({reverse2d_:b4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w4(t,e){const n=F(t,"x","reverse");return O(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),Ss(n,e)}const $4=U({reverse3d_:w4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v4(t,e){const n=F(t,"x","reverse");return O(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),Ss(n,e)}const S4=U({reverse4d_:v4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I4(t){const n={x:F(t,"x","round")};return q.runKernel(tl,n)}const Hy=U({round_:I4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _4(t){const n={x:F(t,"x","rsqrt","float32")};return q.runKernel(nl,n)}const qy=U({rsqrt_:_4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k4(t){const n={x:F(t,"x","selu")};return q.runKernel(sl,n)}const jy=U({selu_:k4});function C4(t,e,n,s,r,a=[1,1],i="NHWC"){const o=F(t,"x","separableConv2d"),u=F(e,"depthwiseFilter","separableConv2d"),l=F(n,"pointwiseFilter","separableConv2d");let c=o,d=!1;if(o.rank===3&&(d=!0,c=K(o,[1,o.shape[0],o.shape[1],o.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");O(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),O(u.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),O(l.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),O(l.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`),O(l.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`);const h=u.shape[2],p=u.shape[3];O(l.shape[2]===h*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${h*p}, but got ${l.shape[2]}.`);const f=xl(c,u,s,r,i,a),g=oa(f,l,1,"valid",i);return d?K(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const Ky=U({separableConv2d_:C4});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function T4(t,e){const n=F(t,"x","setdiff1d"),s=F(e,"y","setdiff1d");O(n.dtype===s.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${s.dtype}).`),O(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),O(s.rank===1,()=>`y should be 1D tensor, but got y (${s.shape}).`);const r=await n.data(),a=await s.data(),i=new Set(a);let o=0;for(let c=0;c<r.length;c++)i.has(r[c])||o++;const u=new jt([o],n.dtype),l=new jt([o],"int32");for(let c=0,d=0;c<r.length;c++)i.has(r[c])||(u.values[d]=r[c],l.values[d]=c,d++);return[u.toTensor(),l.toTensor()]}const N4=T4;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E4(t){const n={x:F(t,"x","sign")};return q.runKernel(il,n)}const W_=U({sign_:E4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A4(t){const n={x:F(t,"x","sin","float32")};return q.runKernel(rl,n)}const Xy=U({sin_:A4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R4(t){const n={x:F(t,"x","sinh")};return q.runKernel(al,n)}const Yy=U({sinh_:R4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D4(t,e,n){const s=F(t,"x","slice1d");return O(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),nt(s,[e],[n])}const Lh=U({slice1d_:D4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O4(t,e,n){const s=F(t,"x","slice2d");return O(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),nt(s,e,n)}const Zy=U({slice2d_:O4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F4(t,e,n){const s=F(t,"x","slice3d");return O(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),nt(s,e,n)}const Ph=U({slice3d_:F4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z4(t,e,n){const s=F(t,"x","slice4d");return O(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),nt(s,e,n)}const uu=U({slice4d_:z4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L4(t,e=-1){const n=F(t,"logits","softmax","float32");if(e===-1&&(e=n.rank-1),e!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${e}`);const s={logits:n},r={dim:e};return q.runKernel(bh,s,r)}const Bh=U({softmax_:L4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P4(t){O(t.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`);const e={input:t};return q.runKernel(Bg,e)}const Mh=U({fft_:P4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B4(t){O(t.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`);const e={input:t};return q.runKernel(Ug,e)}const lu=U({ifft_:B4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M4(t){const e=t.shape[t.shape.length-1],n=t.size/e;let s;if(e<=2){const r=K(t,[n,e]);s=lu(r)}else{const r=[n,2*(e-1)],a=K(ou(t),[n,e]),i=K(Ch(t),[n,e]),o=Ss(nt(a,[0,1],[n,e-2]),1),u=j(Ss(nt(i,[0,1],[n,e-2]),1),Re(-1)),l=Wt([a,o],1),c=Wt([i,u],1),d=K(ra(l,c),[r[0],r[1]]);s=lu(d)}if(s=ou(s),t.rank===3&&t.shape[0]!==0){const r=s,a=t.shape[0];s=K(s,[a,s.shape[0]/a,s.shape[1]]),r.dispose()}return s}const Qy=U({irfft_:M4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V4(t,e,n=0){const r={x:F(t,"x","split")},a={numOrSizeSplits:e,axis:n};return q.runKernel(yh,r,a)}const Gn=U({split_:V4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W4(t,e){O(t.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${t.dtype}`);let n=t.shape[t.shape.length-1];const s=t.size/n;let r;if(e!=null&&e<n){const f=t.shape.map(g=>0),m=t.shape.map(g=>g);m[t.shape.length-1]=e,r=nt(t,f,m),n=e}else if(e!=null&&e>n){const f=t.shape.map(m=>m);f[t.shape.length-1]=e-n,r=Wt([t,Gt(f)],t.shape.length-1),n=e}else r=t;const a=rt(r),i=K(ra(r,a),[s,n]),o=Mh(i),u=Math.floor(n/2)+1,l=ou(o),c=Ch(o),d=Gn(l,[u,n-u],l.shape.length-1),h=Gn(c,[u,n-u],c.shape.length-1),p=r.shape.slice();return p[r.shape.length-1]=u,K(ra(d[0],h[0]),p)}const Vh=U({rfft_:W4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U4(t,e){let n=F(t,"a","squaredDifference"),s=F(e,"b","squaredDifference");[n,s]=Dt(n,s),We(n.shape,s.shape);const r={a:n,b:s},a={};return q.runKernel(cl,r,a)}const Jy=U({squaredDifference_:U4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G4(t,e){const n=F(t,"x","squeeze","string_or_numeric");return K(n,fa(n.shape,e).newShape)}const bi=U({squeeze_:G4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H4(t,e=0){const n=Uc(t,"tensors","stack","string_or_numeric");O(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&O(e<=n[0].rank,()=>"Axis must be <= rank of the tensor");const s=n,r={axis:e};return q.runKernel(ah,s,r)}const Kn=U({stack_:H4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q4(t,e=0){const s={x:F(t,"x","step")},r={alpha:e};return q.runKernel(ml,s,r)}const po=U({step_:q4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j4(t,e,n,s,r=0,a=0,i=0,o=0,u=0){const c={x:F(t,"x","stridedSlice","string_or_numeric")},d={begin:e,end:n,strides:s,beginMask:r,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:u};return q.runKernel(gy,c,d)}const U_=U({stridedSlice_:j4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K4(t){const n={x:F(t,"x","tan","float32")};return q.runKernel(hl,n)}const G_=U({tan_:K4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cn(t,e){io(t);const n=ga(t,e);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return ya(t,null,n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eu(t,e,n){if(io(t),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=ga(t,n);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return ya(t,e,s,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H_(t,e,n){if(io(t),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const s=ga(t,n);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return ya(t,e,s,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X4(t,e,n){if(io(t),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const s=ga(t,n);if(s.length!==4&&s.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return ya(t,e,s,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y4(t,e,n){if(io(t),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const s=ga(t,n);if(s.length!==5&&s.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return ya(t,e,s,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z4(t,e,n){if(io(t),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const s=ga(t,n);if(s.length!==6&&s.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||s,ya(t,e,s,n)}function q_(t,e,n){const s=e.rank>1?e.shape[e.rank-1]:1,r=e.rank>1?e.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${e.shape}, shape: ${t}, sliceDim: ${s}, and batchDim: ${r}.`;if(n.rank<r)throw new Error(a+` update.rank < ${r}. `);if(t.length<s+(n.rank-r))throw new Error(a+` Output shape length < ${s+(n.rank-r)}`);if(n.rank!==r+t.length-s)throw new Error(a+` update.rank != ${r+t.length-s}`);for(let i=0;i<r;++i)if(n.shape[i]!==e.shape[i])throw new Error(a+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${e.shape[i]}).`);for(let i=0;i<n.rank-r;++i)if(n.shape[i+r]!==t[i+s])throw new Error(a+` updates.shape[${i+r}] (${n.shape[i+r]}) != shape[${i+r}] (${t[i+r]})`)}function eb(t,e,n){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(t.size===0)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}q_(n,e,t)}function xi(t,e,n){const s=e.shape.length,r=s>1?e.shape[s-1]:1,a=n.length;let i=1;for(let d=r;d<a;++d)i*=n[d];const o=r<1?1:r,u=se(e.shape)/o,l=[...Ae(n.slice(0,r)),1],c=se(n);return{sliceRank:r,numUpdates:u,sliceSize:i,strides:l,outputSize:c}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q4(t,e,n){const s=F(t,"tensor","tensorScatterupdate"),r=F(e,"indices","tensorScatterupdate","int32"),a=F(n,"updates","tensorScatterupdate");if(eb(a,r,s.shape),s.dtype!==a.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${s.dtype} and ${a.dtype}.`);const i={tensor:s,indices:r,updates:a},o={};return q.runKernel(uy,i,o)}const J4=U({tensorScatterUpdate_:Q4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eV(t,e=1,n=!0){const s=F(t,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${e}`);const a={x:s},i={k:e,sorted:n},[o,u]=q.runKernel(wy,a,i);return{values:o,indices:u}}const j_=U({topk_:eV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tV(t,e=0,n=1,s,r){if(is(t),s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const a=new Wy(e,n,s,!0,r),i=qe(t,s);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}const tb=U({truncatedNormal_:tV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nV(t,e=0){const n=F(t,"x","unique","string_or_numeric");O(n.rank>0,()=>"The input tensor must be at least 1D");const s={x:n},r={axis:e},[a,i]=q.runKernel(vy,s,r);return{values:a,indices:i}}const K_=U({unique_:nV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sV(t,e,n){const s=F(t,"x","unsortedSegmentSum"),r=F(e,"segmentIds","unsortedSegmentSum","int32");O(qi(n),()=>"numSegments must be of dtype int");const a={x:s,segmentIds:r},i={numSegments:n};return q.runKernel($h,a,i)}const nb=U({unsortedSegmentSum_:sV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rV(t,e=0){const n=F(t,"x","unstack","string_or_numeric");O(e>=-n.shape.length&&e<n.shape.length,()=>`Axis = ${e} is not in [-${n.shape.length}, ${n.shape.length})`);const s={value:n},r={axis:e};return q.runKernel(wh,s,r)}const Is=U({unstack_:rV});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aV(t,e){return My(t,e,"right")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X_(t,e=!0,n,s){return q.makeVariable(t,e,n,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sb(t,e){const n=[];for(let a=0;a<e.length;a++)e[a]&&n.push(a);const s=qe(t,"int32"),r=qe([n.length,t.length],"int32");for(let a=0;a<n.length;a++){const i=s.indexToLoc(n[a]),o=a*t.length;r.values.set(i,o)}return r.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function iV(t){const e=F(t,"condition","whereAsync","bool"),n=await e.data(),s=sb(e.shape,n);return t!==e&&e.dispose(),s}const Y_=iV;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function oV(t,e,n){const s=F(t,"tensor","boolMask"),r=F(e,"mask","boolMask","bool"),a=n??0,i=r.rank,o=s.shape;O(i>0,()=>"mask cannot be scalar"),Zn(o.slice(a,a+i),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let m=a;m<a+i;m++)u*=o[m];const l=o.slice(0,a).concat([u],o.slice(a+i)),c=K(s,l),d=K(r,[-1]),h=await Y_(d),p=bi(h,[1]),f=Sl(c,p,a);return t!==s&&s.dispose(),e!==r&&r.dispose(),p.dispose(),c.dispose(),d.dispose(),h.dispose(),f}const uV=oV;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lV(t,e,n){const s=F(t,"x","transpose");if(e==null&&(e=s.shape.map((i,o)=>o).reverse()),O(s.rank===e.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${e}.`),e.forEach(i=>{O(i>=0&&i<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${e}`)}),s.rank<=1)return s.clone();const r={x:s},a={perm:e};return s.dtype==="complex64"?ee(()=>{let i=ou(s),o=Ch(s);return i=q.runKernel(Mi,{x:i},a),o=q.runKernel(Mi,{x:o},a),n&&(o=It(o)),ra(i,o)}):q.runKernel(Mi,r,a)}const st=U({transpose_:lV});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cV(t,e,n,s,r=!0){const a=F(t,"v","movingAverage"),i=F(e,"x","movingAverage"),o=F(n,"decay","movingAverage");Yz(a,i),O(tt(a.shape,i.shape),()=>"Shape mismatch in v and x");const u=Re(1),l=we(u,o);let c=j(we(i,a),l);if(r){O(s!=null,()=>"When using zeroDebias: true, step is required.");const d=F(s,"step","movingAverage");c=Te(c,we(u,Er(o,d)))}return le(a,c)}const dV=U({movingAverage_:cV});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hV(t,e,n){is(n);const s=F(t,"indices","scatterND","int32"),r=F(e,"updates","scatterND");eb(r,s,n);const a={indices:s,updates:r},i={shape:n};return q.runKernel(oy,a,i)}const pV=U({scatterND_:hV});function fV(t,e,n,s){if(t.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${t.shape}.`);const r=t.rank>0?t.shape[0]:1,a=t.rank>1?t.shape[1]:1;if(n.length!==a)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${a}.`);const i=e.size;if(!(e.rank===0||e.rank===1&&i===r))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${r}]`);if(e.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mV(t,e,n,s=0){is(n);const r=F(t,"sparseIndices","sparseToDense","int32"),a=F(e,"sparseValues","sparseToDense","string_or_numeric"),i=F(s,"defaultValue","sparseToDense",a.dtype);fV(r,a,n,i);const o={sparseIndices:r,sparseValues:a,defaultValue:i},u={outputShape:n};return q.runKernel(fy,o,u)}const gV=U({sparseToDense_:mV});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yV(t,e){const n=F(e,"indices","gatherND","int32"),r={params:F(t,"x","gatherND","string_or_numeric"),indices:n};return q.runKernel(Wg,r)}const bV=U({gatherND_:yV});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xV(t,e){if(e==null)return t.shape.slice();if(tt(t.shape,e))return e;if(t.shape.length===e.length){const n=[];for(let s=0;s<t.shape.length;s++)e[s]==null&&t.shape[s]!=null?n.push(t.shape[s]):n.push(e[s]);return n}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wV(t,e,n,s){const r=F(t,"x","dropout");if(O(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),O(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return t instanceof _t?r.clone():r;const a=xV(r,n),i=1-e,o=Te(vl(le(yi(a,0,1,"float32",s),i)),i);return j(r,o)}const Z_=U({dropout_:wV});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q_(t){return Math.floor(Math.pow(2,Math.ceil(Math.log(t)/Math.log(2))))}function rb(t,e,n){const s=1-t%2,r=new Float32Array(t);for(let a=0;a<t;++a){const i=2*Math.PI*a/(t+s-1);r[a]=e-n*Math.cos(i)}return Cn(r,"float32")}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function $V(t,e,n=1){const s=F(t,"predictions","inTopK"),r=F(e,"targets","inTopK");O(s.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${s.rank}`),O(s.rank-1===r.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${s.rank} and targets rank ${r.rank}`),Zn(s.shape.slice(0,s.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const a=s.shape[s.shape.length-1];O(n>0&&n<=a,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${a}), but got ${n}`);const i=await s.data(),o=await r.data(),[u,l]=[i.length/a,a],c=dn("bool",u);for(let d=0;d<u;d++){const h=d*l,p=i.subarray(h,h+l),f=[];for(let m=0;m<p.length;m++)f.push({value:p[m],index:m});f.sort((m,g)=>g.value-m.value),c[d]=0;for(let m=0;m<n;m++)if(f[m].index===o[d]){c[d]=1;break}}return t!==s&&s.dispose(),e!==r&&r.dispose(),Hs(c,r.shape,"bool")}const vV=$V;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SV(t,e,n,s,r,a="NHWC",i){let o=t;t.rank===3&&(o=K(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u=e;u.rank===3&&(u=K(e,[1,e.shape[0],e.shape[1],e.shape[2]])),O(o.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),O(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),O(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const l=a==="NHWC"?o.shape[3]:o.shape[1],c=a==="NHWC"?u.shape[3]:u.shape[1];O(l===n[2],()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${n[2]}.`),O(c===n[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`),Nn("conv2dDerFilter",r,i);const d={x:o,dy:u},h={strides:s,pad:r,dataFormat:a,dimRoundingMode:i,filterShape:n};return q.runKernel(Cg,d,h)}const ab=U({conv2DBackpropFilter_:SV});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wh(t,e,n){if(n==null||n==="linear")return t;if(n==="relu")return j(t,po(e));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function Uh(t,e){let n=e;const s=Yt(t.shape,e.shape);return s.length>0&&(n=Ie(n,s)),K(n,t.shape)}function Gh(t,e,n,s){if(e==="linear")return t;if(e==="relu")return xr(t);if(e==="elu")return wl(t);if(e==="relu6")return Gy(t);if(e==="prelu")return Fh(t,n);if(e==="leakyrelu")return Th(t,s);if(e==="sigmoid")return dr(t);throw new Error(`Unknown fused activation ${e}.`)}const Hh=(t,e)=>!(t>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IV({x:t,filter:e,strides:n,pad:s,dataFormat:r="NHWC",dilations:a=[1,1],dimRoundingMode:i,bias:o,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(u=u||"linear",Hh(q.state.gradientDepth,u)===!1){O(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let k=oa(t,e,n,s,r,a,i);return o!=null&&(k=le(k,o)),Gh(k,u,l,c)}const d=F(t,"x","conv2d","float32"),h=F(e,"filter","conv2d","float32");let p=d,f=!1;d.rank===3&&(f=!0,p=K(d,[1,d.shape[0],d.shape[1],d.shape[2]])),O(p.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),O(h.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${h.rank}.`),Nn("fused conv2d",s,i);const m=r==="NHWC"?p.shape[3]:p.shape[1];O(h.shape[2]===m,()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${h.shape[2]}.`),O(pn(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`);const g=rn(p.shape,h.shape,n,a,s,i);let y;o!=null&&(y=F(o,"bias","fused conv2d"),[y]=Dt(y,d),r==="NHWC"?We(g.outShape,y.shape):(O(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),O(y.shape.length===0||y.shape[0]===g.outChannels||y.shape[0]===1,()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${g.outChannels})`)));let b;if(l!=null){const k=l.shape;if(O(k.length<=1||k.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${k.length}.`),k.length===1)O(k[0]===1||k[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${k}) is not compatible with the number of output channels (${g.outChannels}).`);else if(k.length===3)try{We(k,g.outShape)}catch{const N=`Error in fused conv2d: PReLU activation weights (${k}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(N)}b=F(l,"prelu weights","fused conv2d")}const $=(k,C)=>{O(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[N,A,I,E]=C,z=Wh(k,I,u);O(ia(a),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);const P=Ay(A.shape,z,N,n,s),H=ab(A,z,N.shape,n,s),G=[P,H];if(E!=null){const W=Uh(E,z);G.push(W)}return G},w={x:p,filter:h,bias:y,preluActivationWeights:b},v={strides:n,pad:s,dataFormat:r,dilations:a,dimRoundingMode:i,activation:u,leakyreluAlpha:c};return o==null?Ar((C,N,A)=>{let I=q.runKernel(Bc,w,v);return A([N,C,I]),f&&(I=K(I,[I.shape[1],I.shape[2],I.shape[3]])),{value:I,gradFunc:$}})(p,h):Ar((C,N,A,I)=>{let E=q.runKernel(Bc,w,v);return I([N,C,E,A]),f&&(E=K(E,[E.shape[1],E.shape[2],E.shape[3]])),{value:E,gradFunc:$}})(p,h,y)}const J_=U({fusedConv2d_:IV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _V(t,e,n,s,r,a=[1,1],i){let o=t;t.rank===3&&(o=K(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u=e;u.rank===3&&(u=K(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const l={x:o,dy:u},c={strides:s,pad:r,dimRoundingMode:i,dilations:a,filterShape:n};return q.runKernel(Og,l,c)}const ek=U({depthwiseConv2dNativeBackpropFilter_:_V});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kV(t,e,n,s,r,a=[1,1],i){let o=e,u=!1;e.rank===3&&(u=!0,o=K(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const l={dy:o,filter:n},c={strides:s,pad:r,dimRoundingMode:i,dilations:a,inputShape:t},d=q.runKernel(Fg,l,c);return u?K(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const tk=U({depthwiseConv2dNativeBackpropInput_:kV});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CV({x:t,filter:e,strides:n,pad:s,dataFormat:r="NHWC",dilations:a=[1,1],dimRoundingMode:i,bias:o,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(Hh(q.state.gradientDepth,u)===!1){let v=xl(t,e,n,s,r,a,i);return o!=null&&(v=le(v,o)),Gh(v,u,l,c)}const d=F(t,"x","depthwiseConv2d","float32"),h=F(e,"filter","depthwiseConv2d","float32");let p=d,f=!1;d.rank===3&&(f=!0,p=K(d,[1,d.shape[0],d.shape[1],d.shape[2]])),O(p.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),O(h.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${h.rank}.`),O(p.shape[3]===h.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${h.shape[2]}.`),a==null&&(a=[1,1]),O(pn(n,a),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),Nn("fused depthwiseConv2d",s,i);const m=rn(p.shape,h.shape,n,a,s,i,!0);let g;o!=null&&(g=F(o,"bias","fused conv2d"),[g]=Dt(g,d),We(m.outShape,g.shape));let y;l!=null&&(y=F(l,"prelu weights","fused depthwiseConv2d"));const b=(v,k)=>{O(ia(a),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[C,N,A,I]=k,E=Wh(v,A,u),z=tk(N.shape,E,C,n,s,a,i),P=ek(N,E,C.shape,n,s,a,i);if(I!=null){const H=Uh(g,E);return[z,P,H]}return[z,P]},$={x:p,filter:h,bias:g,preluActivationWeights:y},w={strides:n,pad:s,dataFormat:r,dilations:a,dimRoundingMode:i,activation:u,leakyreluAlpha:c};return o==null?Ar((k,C,N)=>{let A=q.runKernel(Mc,$,w);return N([C,k,A]),f&&(A=K(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:b}})(p,h):Ar((k,C,N,A)=>{let I=q.runKernel(Mc,$,w);return A([C,k,I,N]),f&&(I=K(I,[I.shape[1],I.shape[2],I.shape[3]])),{value:I,gradFunc:b}})(p,h,g)}const TV=U({fusedDepthwiseConv2d_:CV});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NV({a:t,b:e,transposeA:n=!1,transposeB:s=!1,bias:r,activation:a="linear",preluActivationWeights:i,leakyreluAlpha:o=.2}){if(Hh(q.state.gradientDepth,a)===!1){let E=Qe(t,e,n,s);return r!=null&&(E=le(E,r)),Gh(E,a,i,o)}let u=F(t,"a","fused matMul"),l=F(e,"b","fused matMul");[u,l]=Dt(u,l);const c=n?u.shape[u.rank-2]:u.shape[u.rank-1],d=s?l.shape[l.rank-1]:l.shape[l.rank-2],h=n?u.shape[u.rank-1]:u.shape[u.rank-2],p=s?l.shape[l.rank-2]:l.shape[l.rank-1],f=u.shape.slice(0,-2),m=l.shape.slice(0,-2),g=se(f),y=se(m);O(c===d,()=>`Error in fused matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${u.shape} and ${l.shape} and transposeA=${n} and transposeB=${s} must match.`);const $=We(u.shape.slice(0,-2),l.shape.slice(0,-2)).concat([h,p]),w=n?K(u,[g,c,h]):K(u,[g,h,c]),v=s?K(l,[y,p,d]):K(l,[y,d,p]);let k;r!=null&&(k=F(r,"bias","fused matMul"),[k]=Dt(k,u),We($,k.shape));let C;i!=null&&(C=F(i,"prelu weights","fused matMul"));const N=(E,z)=>{const[P,H,G,W]=z,L=Wh(K(E,G.shape),G,a);let B,Y;if(!n&&!s?(B=Qe(L,H,!1,!0),Y=Qe(P,L,!0,!1)):!n&&s?(B=Qe(L,H,!1,!1),Y=Qe(L,P,!0,!1)):n&&!s?(B=Qe(H,L,!1,!0),Y=Qe(P,L,!1,!1)):(B=Qe(H,L,!0,!0),Y=Qe(L,P,!0,!0)),r!=null){const ne=Uh(W,L);return[B,Y,ne]}else return[B,Y]},A={a:w,b:v,bias:k,preluActivationWeights:C},I={transposeA:n,transposeB:s,activation:a,leakyreluAlpha:o};return r==null?Ar((z,P,H)=>{const G=q.runKernel(Pc,A,I);return H([z,P,G]),{value:K(G,$),gradFunc:N}})(w,v):Ar((z,P,H,G)=>{const W=q.runKernel(Pc,A,I);return G([z,P,W,H]),{value:K(W,$),gradFunc:N}})(w,v,k)}const Sm=U({fusedMatMul_:NV});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EV=Object.freeze(Object.defineProperty({__proto__:null,conv2d:J_,depthwiseConv2d:TV,matMul:Sm},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AV(t){return rb(t,.54,.46)}const RV=U({hammingWindow_:AV});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DV(t){return rb(t,.5,.5)}const nk=U({hannWindow_:DV});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OV(t,e,n,s=!1,r=0){let a=0;const i=[];for(;a+e<=t.size;)i.push(nt(t,a,e)),a+=n;if(s)for(;a<t.size;){const o=a+e-t.size,u=Wt([nt(t,a,e-o),co([o],r)]);i.push(u),a+=n}return i.length===0?eu([],[0,e]):K(Wt(i),[i.length,e])}const sk=U({frame_:OV});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FV(t,e,n,s,r=nk){s==null&&(s=Q_(e));const a=sk(t,e,n),i=j(a,r(e));return Vh(i,s)}const zV=U({stft_:FV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LV(t,e,n,s,r="bilinear",a=0){const i=F(t,"image","cropAndResize"),o=F(e,"boxes","cropAndResize","float32"),u=F(n,"boxInd","cropAndResize","int32"),l=o.shape[0];O(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),O(o.rank===2&&o.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${o.shape}.`),O(u.rank===1&&u.shape[0]===l,()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${o.shape}.`),O(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),O(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),O(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);const c={image:i,boxes:o,boxInd:u},d={method:r,extrapolationValue:a,cropSize:s};return q.runKernel(Ag,c,d)}const PV=U({cropAndResize_:LV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BV(t){const e=F(t,"image","flipLeftRight","float32");O(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const n={image:e};return q.runKernel(Vg,n,{})}const MV=U({flipLeftRight_:BV});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VV(t){const e=F(t,"image","grayscaleToRGB"),n=e.rank-1,s=e.shape[n];O(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),O(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const r=new Array(e.rank);return r.fill(1,0,n),r[n]=3,gs(e,r)}const WV=U({grayscaleToRGB_:VV});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UV(t){const e=F(t,"image","RGBToGrayscale"),n=e.rank-1,s=e.shape[n];O(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),O(s===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${s}.`);const r=e.dtype,a=ge(e,"float32"),i=Cn([.2989,.587,.114]);let o;switch(e.rank){case 2:o=zi("ij,j->i",a,i);break;case 3:o=zi("ijk,k->ij",a,i);break;case 4:o=zi("ijkl,l->ijk",a,i);break;case 5:o=zi("ijklm,m->ijkl",a,i);break;case 6:o=zi("ijklmn,n->ijklm",a,i);break;default:throw new Error("Not a valid tensor rank.")}return o=_n(o,-1),ge(o,r)}const GV=U({rgbToGrayscale_:UV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HV(t,e,n=0,s=.5){const r=F(t,"image","rotateWithOffset","float32");O(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);const a={image:r},i={radians:e,fillValue:n,center:s};return q.runKernel(Sy,a,i)}const qV=U({rotateWithOffset_:HV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fo(t,e,n,s,r,a){s==null&&(s=.5),r==null&&(r=Number.NEGATIVE_INFINITY),a==null&&(a=0);const i=t.shape[0];return n=Math.min(n,i),O(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),O(t.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`),O(t.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`),O(e.rank===1,()=>"scores must be a 1D tensor"),O(e.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${e.shape[0]}`),O(0<=a&&a<=1,()=>`softNmsSigma must be in [0, 1], but was '${a}'`),{maxOutputSize:n,iouThreshold:s,scoreThreshold:r,softNmsSigma:a}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jV(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY){const a=F(t,"boxes","nonMaxSuppression","float32"),i=F(e,"scores","nonMaxSuppression","float32"),o=fo(a,i,n,s,r);n=o.maxOutputSize,s=o.iouThreshold,r=o.scoreThreshold;const u={maxOutputSize:n,iouThreshold:s,scoreThreshold:r};return q.runKernel(Zg,{boxes:a,scores:i},u)}const KV=U({nonMaxSuppression_:jV});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XV(t,e,n){const s=YV(t,e,n),r=s<0?-(s+1):s;t.splice(r,0,e)}function YV(t,e,n){return QV(t,e,n||ZV)}function ZV(t,e){return t>e?1:t<e?-1:0}function QV(t,e,n){let s=0,r=t.length,a=0,i=!1;for(;s<r;){a=s+(r-s>>>1);const o=n(e,t[a]);o>0?s=a+1:(r=a,i=!o)}return i?s:-s-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ib(t,e,n,s,r){return lb(t,e,n,s,r,0)}function ob(t,e,n,s,r,a){return lb(t,e,n,s,r,0,!1,a,!0)}function ub(t,e,n,s,r,a){return lb(t,e,n,s,r,a,!0)}function lb(t,e,n,s,r,a,i=!1,o=!1,u=!1){const l=[];for(let g=0;g<e.length;g++)e[g]>r&&l.push({score:e[g],boxIndex:g,suppressBeginIndex:0});l.sort(c1);const c=a>0?-.5/a:0,d=[],h=[];for(;d.length<n&&l.length>0;){const g=l.pop(),{score:y,boxIndex:b,suppressBeginIndex:$}=g;if(y<r)break;let w=!1;for(let v=d.length-1;v>=$;--v){const k=JV(t,b,d[v]);if(k>=s){w=!0;break}if(g.score=g.score*eW(s,c,k),g.score<=r)break}g.suppressBeginIndex=d.length,w||(g.score===y?(d.push(b),h.push(g.score)):g.score>r&&XV(l,g,c1))}const p=d.length,f=n-p;o&&f>0&&(d.push(...new Array(f).fill(0)),h.push(...new Array(f).fill(0)));const m={selectedIndices:d};return i&&(m.selectedScores=h),u&&(m.validOutputs=p),m}function JV(t,e,n){const s=t.subarray(e*4,e*4+4),r=t.subarray(n*4,n*4+4),a=Math.min(s[0],s[2]),i=Math.min(s[1],s[3]),o=Math.max(s[0],s[2]),u=Math.max(s[1],s[3]),l=Math.min(r[0],r[2]),c=Math.min(r[1],r[3]),d=Math.max(r[0],r[2]),h=Math.max(r[1],r[3]),p=(o-a)*(u-i),f=(d-l)*(h-c);if(p<=0||f<=0)return 0;const m=Math.max(a,l),g=Math.max(i,c),y=Math.min(o,d),b=Math.min(u,h),$=Math.max(y-m,0)*Math.max(b-g,0);return $/(p+f-$)}function eW(t,e,n){const s=Math.exp(e*n*n);return n<=t?s:0}function c1(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function tW(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY){const a=F(t,"boxes","nonMaxSuppressionAsync"),i=F(e,"scores","nonMaxSuppressionAsync"),o=fo(a,i,n,s,r);n=o.maxOutputSize,s=o.iouThreshold,r=o.scoreThreshold;const u=await Promise.all([a.data(),i.data()]),l=u[0],c=u[1],{selectedIndices:d}=ib(l,c,n,s,r);return a!==t&&a.dispose(),i!==e&&i.dispose(),Cn(d,"int32")}const nW=tW;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sW(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY,a=0){const i=F(t,"boxes","nonMaxSuppression"),o=F(e,"scores","nonMaxSuppression"),u=fo(i,o,n,s,r,a);n=u.maxOutputSize,s=u.iouThreshold,r=u.scoreThreshold,a=u.softNmsSigma;const l={boxes:i,scores:o},c={maxOutputSize:n,iouThreshold:s,scoreThreshold:r,softNmsSigma:a},d=q.runKernel(Jg,l,c);return{selectedIndices:d[0],selectedScores:d[1]}}const rW=U({nonMaxSuppressionWithScore_:sW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function aW(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY,a=0){const i=F(t,"boxes","nonMaxSuppressionAsync"),o=F(e,"scores","nonMaxSuppressionAsync"),u=fo(i,o,n,s,r,a);n=u.maxOutputSize,s=u.iouThreshold,r=u.scoreThreshold,a=u.softNmsSigma;const l=await Promise.all([i.data(),o.data()]),c=l[0],d=l[1],{selectedIndices:h,selectedScores:p}=ub(c,d,n,s,r,a);return i!==t&&i.dispose(),o!==e&&o.dispose(),{selectedIndices:Cn(h,"int32"),selectedScores:Cn(p)}}const iW=aW;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oW(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY,a=!1){const i=F(t,"boxes","nonMaxSuppression"),o=F(e,"scores","nonMaxSuppression"),u=fo(i,o,n,s,r,null),l=u.maxOutputSize,c=u.iouThreshold,d=u.scoreThreshold,h={boxes:i,scores:o},p={maxOutputSize:l,iouThreshold:c,scoreThreshold:d,padToMaxOutputSize:a},f=q.runKernel(Qg,h,p);return{selectedIndices:f[0],validOutputs:f[1]}}const uW=U({nonMaxSuppressionPadded_:oW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function lW(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY,a=!1){const i=F(t,"boxes","nonMaxSuppressionAsync"),o=F(e,"scores","nonMaxSuppressionAsync"),u=fo(i,o,n,s,r,null),l=u.maxOutputSize,c=u.iouThreshold,d=u.scoreThreshold,[h,p]=await Promise.all([i.data(),o.data()]),{selectedIndices:f,validOutputs:m}=ob(h,p,l,c,d,a);return i!==t&&i.dispose(),o!==e&&o.dispose(),{selectedIndices:Cn(f,"int32"),validOutputs:Re(m,"int32")}}const cW=lW;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dW(t,e,n=!1,s=!1){const r=F(t,"images","resizeBilinear");O(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),O(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),O(s===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let a=r,i=!1;r.rank===3&&(i=!0,a=K(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const o={images:a},u={alignCorners:n,halfPixelCenters:s,size:e},l=q.runKernel(dh,o,u);return i?K(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const rk=U({resizeBilinear_:dW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hW(t,e,n=!1,s=!1){const r=F(t,"images","resizeNearestNeighbor");O(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),O(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),O(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),O(s===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let a=r,i=!1;r.rank===3&&(i=!0,a=K(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const o={images:a},u={alignCorners:n,halfPixelCenters:s,size:e},l=q.runKernel(ch,o,u);return i?K(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const ak=U({resizeNearestNeighbor_:hW});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pW(t,e="binary",n=!1,s=.5){const r=F(t,"image","threshold"),a=.2989,i=.587,o=.114,u=r.shape[0]*r.shape[1];let l=j(Cn([s]),255),c,d,h,p;if(O(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),O(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),O(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),O(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),r.shape[2]===3){[c,d,h]=Gn(r,[1,1,1],-1);const g=j(c,a),y=j(d,i),b=j(h,o);p=le(le(g,y),b)}else p=t;if(e==="otsu"){const g=p_(ge(Hy(p),"int32"),Hs([]),256);l=fW(g,u)}const f=n?gi(p,l):Qn(p,l);return ge(j(f,255),"int32")}function fW(t,e){let n=Cn([-1]),s=Cn([0]),r=Cn([0]),a,i,o,u,l,c;for(let d=0;d<t.size-1;d++){a=nt(t,0,d+1),i=nt(t,d+1),l=Te(Ie(a),e),c=Te(Ie(i),e);const h=Ie(j(a,Zi(0,a.size)));o=Te(h,Ie(a));const p=co(i.shape,a.size),f=le(Zi(0,i.size),p),m=j(i,f);u=Te(Ie(m),Ie(i));const g=we(o,u),y=we(o,u),b=j(l,c);r=j(j(b,g),y);const $=Qn(r,s);s=bn($,r,s),n=bn($,Cn([d]),n)}return n}const mW=U({threshold_:pW});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gW(t,e,n="nearest",s="constant",r=0,a){const i=F(t,"image","transform","float32"),o=F(e,"transforms","transform","float32");O(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),O(o.rank===2&&(o.shape[0]===i.shape[0]||o.shape[0]===1)&&o.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),O(a==null||a.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`);const u={image:i,transforms:o},l={interpolation:n,fillMode:s,fillValue:r,outputShape:a};return q.runKernel($y,u,l)}const yW=U({transform_:gW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bW(t,e,n){const s=F(t,"a","bandPart");O(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[a,i]=s.shape.slice(-2);let o,u;typeof e=="number"?(O(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),O(e<=a,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${a}).`),o=F(e<0?a:e,"numLower","bandPart")):(O(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),o=bn(iu(e,0),a,ai(e,a))),typeof n=="number"?(O(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),O(n<=i,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`),u=F(n<0?i:n,"numUpper","bandPart")):(O(n.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),u=bn(iu(n,0),i,ai(n,i)));const l=K(Zi(0,a,1,"int32"),[-1,1]),c=Zi(0,i,1,"int32"),d=we(l,c),h=mr(gi(d,o),wa(d,It(u))),p=Gt([a,i],s.dtype);return K(Kn(Is(K(s,[-1,a,i])).map(f=>bn(h,f,p))),r)}const xW=U({bandPart_:bW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wW(t){let e;if(Array.isArray(t)){e=!1,O(t!=null&&t.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=t[0].shape[0];for(let a=1;a<t.length;++a)O(t[a].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[a].shape[0]} vs. ${r})`)}else e=!0,t=Gn(t,t.shape[0],0).map(r=>bi(r,[0]));O(t.length<=t[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`);const n=[],s=t;for(let r=0;r<t.length;++r)n.push(q.tidy(()=>{let a=s[r];if(r>0)for(let i=0;i<r;++i){const o=j(Ie(j(n[i],a)),n[i]);a=we(a,o)}return Te(a,$l(a,"euclidean"))}));return e?Kn(n,0):n}const $W=U({gramSchmidt_:wW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vW(t,e=!1){if(O(t.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`),t.rank===2)return d1(t,e);{const n=t.shape.slice(0,t.shape.length-2).reduce((u,l)=>u*l),s=Is(K(t,[n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),r=[],a=[];s.forEach(u=>{const[l,c]=d1(u,e);r.push(l),a.push(c)});const i=K(Kn(r,0),t.shape),o=K(Kn(a,0),t.shape);return[i,o]}}function d1(t,e=!1){return q.tidy(()=>{O(t.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`);const n=t.shape[0],s=t.shape[1];let r=Ly(n),a=Tr(t);const i=eu([[1]],[1,1]);let o=Tr(i);const u=n>=s?s:n;for(let l=0;l<u;++l){const c=a,d=o,h=r;[o,a,r]=q.tidy(()=>{const p=nt(a,[l,l],[n-l,1]),f=$l(p),m=nt(a,[l,l],[1,1]),g=bn(Qn(m,0),eu([[-1]]),eu([[1]])),y=we(m,j(g,f)),b=Te(p,y);b.shape[0]===1?o=Tr(i):o=Wt([i,nt(b,[1,0],[b.shape[0]-1,b.shape[1]])],0);const $=It(Te(Qe(g,y),f)),w=nt(a,[l,0],[n-l,s]),v=j($,o),k=st(o);if(l===0)a=we(w,Qe(v,Qe(k,w)));else{const A=we(w,Qe(v,Qe(k,w)));a=Wt([nt(a,[0,0],[l,s]),A],0)}const C=st(v),N=nt(r,[0,l],[n,r.shape[1]-l]);if(l===0)r=we(N,Qe(Qe(N,o),C));else{const A=we(N,Qe(Qe(N,o),C));r=Wt([nt(r,[0,0],[n,l]),A],1)}return[o,a,r]}),Ve([c,d,h])}return!e&&n>s&&(r=nt(r,[0,0],[n,s]),a=nt(a,[0,0],[s,s])),[r,a]})}const SW=U({qr_:vW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var On;(function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(On||(On={}));function IW(t,e,n=On.SUM_BY_NONZERO_WEIGHTS){const s=F(t,"losses","computeWeightedLoss");let r=null;e!=null&&(r=F(e,"weights","computeWeightedLoss"));const a=r==null?s:j(s,r);if(n===On.NONE)return a;if(n===On.SUM)return Ie(a);if(n===On.MEAN){if(r==null)return Rt(a);{const i=s.size/r.size,o=Te(Ie(a),Ie(r));return i>1?Te(o,Re(i)):o}}if(n===On.SUM_BY_NONZERO_WEIGHTS){if(r==null)return Te(Ie(a),Re(s.size));{const i=j(r,Un(s.shape)),o=ge(Ie(Yi(i,Re(0))),"float32");return Te(Ie(a),o)}}throw Error(`Unknown reduction: ${n}`)}const Lr=U({computeWeightedLoss_:IW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _W(t,e,n,s=On.SUM_BY_NONZERO_WEIGHTS){const r=F(t,"labels","absoluteDifference"),a=F(e,"predictions","absoluteDifference");let i=null;n!=null&&(i=F(n,"weights","absoluteDifference")),Zn(r.shape,a.shape,"Error in absoluteDifference: ");const o=Ut(we(r,a));return Lr(o,i,s)}const kW=U({absoluteDifference_:_W});function CW(t,e,n,s,r=On.SUM_BY_NONZERO_WEIGHTS){const a=F(t,"labels","cosineDistance"),i=F(e,"predictions","cosineDistance");let o=null;s!=null&&(o=F(s,"weights","cosineDistance")),Zn(a.shape,i.shape,"Error in cosineDistance: ");const u=Re(1),l=we(u,Ie(j(a,i),n,!0));return Lr(l,o,r)}const TW=U({cosineDistance_:CW});function NW(t,e,n,s=On.SUM_BY_NONZERO_WEIGHTS){let r=F(t,"labels","hingeLoss");const a=F(e,"predictions","hingeLoss");let i=null;n!=null&&(i=F(n,"weights","hingeLoss")),Zn(r.shape,a.shape,"Error in hingeLoss: ");const o=Re(1);r=we(j(Re(2),r),o);const u=xr(we(o,j(r,a)));return Lr(u,i,s)}const EW=U({hingeLoss_:NW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AW(t,e,n,s=1,r=On.SUM_BY_NONZERO_WEIGHTS){const a=F(t,"labels","huberLoss"),i=F(e,"predictions","huberLoss");let o=null;n!=null&&(o=F(n,"weights","huberLoss")),Zn(a.shape,i.shape,"Error in huberLoss: ");const u=Re(s),l=Ut(we(i,a)),c=ai(l,u),d=we(l,c),h=le(j(Re(.5),xt(c)),j(u,d));return Lr(h,o,r)}const RW=U({huberLoss_:AW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DW(t,e,n,s=1e-7,r=On.SUM_BY_NONZERO_WEIGHTS){const a=F(t,"labels","logLoss"),i=F(e,"predictions","logLoss");let o=null;n!=null&&(o=F(n,"weights","logLoss")),Zn(a.shape,i.shape,"Error in logLoss: ");const u=Re(1),l=Re(s),c=It(j(a,rs(le(i,l)))),d=j(we(u,a),rs(le(we(u,i),l))),h=we(c,d);return Lr(h,o,r)}const OW=U({logLoss_:DW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FW(t,e,n,s=On.SUM_BY_NONZERO_WEIGHTS){const r=F(t,"labels","meanSquaredError"),a=F(e,"predictions","meanSquaredError");let i=null;n!=null&&(i=F(n,"weights","meanSquaredError")),Zn(r.shape,a.shape,"Error in meanSquaredError: ");const o=Jy(r,a);return Lr(o,i,s)}const zW=U({meanSquaredError_:FW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LW(t,e){const n=F(t,"labels","sigmoidCrossEntropyWithLogits"),s=F(e,"logits","sigmoidCrossEntropyWithLogits");Zn(n.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=xr(s),a=j(s,n),i=Nh(jn(It(Ut(s))));return le(we(r,a),i)}function PW(t,e,n,s=0,r=On.SUM_BY_NONZERO_WEIGHTS){let a=F(t,"multiClassLabels","sigmoidCrossEntropy");const i=F(e,"logits","sigmoidCrossEntropy");let o=null;if(n!=null&&(o=F(n,"weights","sigmoidCrossEntropy")),Zn(a.shape,i.shape,"Error in sigmoidCrossEntropy: "),s>0){const l=Re(s),c=Re(1),d=Re(.5);a=le(j(a,we(c,l)),j(d,l))}const u=LW(a,i);return Lr(u,o,r)}const BW=U({sigmoidCrossEntropy_:PW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MW(t,e,n=-1){if(n===-1&&(n=e.rank-1),n!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${n}`);return Ar((r,a,i)=>{const u=Eh(a,[n],!0),l=we(ge(a,"float32"),u);i([r,l]);const c=It(j(l,r));return{value:Ie(c,[n]),gradFunc:(p,f)=>{const[m,g]=f,y=Lt(p.shape,[n]);return[j(K(p,y),we(ge(m,"float32"),jn(g))),j(K(p,y),we(jn(g),ge(m,"float32")))]}}})(t,e)}function VW(t,e,n,s=0,r=On.SUM_BY_NONZERO_WEIGHTS){let a=F(t,"onehotLabels","softmaxCrossEntropy");const i=F(e,"logits","softmaxCrossEntropy");let o=null;if(n!=null&&(o=F(n,"weights","softmaxCrossEntropy")),Zn(a.shape,i.shape,"Error in softmaxCrossEntropy: "),s>0){const l=Re(s),c=Re(1),d=Re(a.shape[1]);a=le(j(a,we(c,l)),Te(l,d))}const u=MW(a,i);return Lr(u,o,r)}const WW=U({softmaxCrossEntropy_:VW});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UW(t,e,n,s){const r=F(t,"indices","sparseFillEmptyRows","int32"),a=F(e,"values","sparseFillEmptyRows"),i=F(n,"denseShape","sparseFillEmptyRows","int32"),o=F(s,"defaultValue","sparseFillEmptyRows",a.dtype);if(r.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${r.shape}`);if(a.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${a.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(o.rank!==0)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);const u={indices:r,values:a,denseShape:i,defaultValue:o},l=q.runKernel(cy,u);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}const GW=U({sparseFillEmptyRows_:UW});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HW(t,e,n){const s=F(t,"inputIndices","sparseReshape","int32"),r=F(e,"inputShape","sparseReshape","int32"),a=F(n,"newShape","sparseReshape","int32");if(s.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${s.shape}`);if(r.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(a.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${a.shape}`);const i={inputIndices:s,inputShape:r,newShape:a},o=q.runKernel(dy,i);return{outputIndices:o[0],outputShape:o[1]}}const qW=U({sparseReshape_:HW});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jW(t,e,n){const s=F(t,"data","sparseSegmentMean"),r=F(e,"indices","sparseSegmentMean","int32"),a=F(n,"segmentIds","sparseSegmentMean","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${r.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${a.shape}`);const i={data:s,indices:r,segmentIds:a};return q.runKernel(hy,i)}const KW=U({sparseSegmentMean_:jW});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XW(t,e,n){const s=F(t,"data","sparseSegmentSum"),r=F(e,"indices","sparseSegmentSum","int32"),a=F(n,"segmentIds","sparseSegmentSum","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${r.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${a.shape}`);const i={data:s,indices:r,segmentIds:a};return q.runKernel(py,i)}const YW=U({sparseSegmentSum_:XW});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZW(t,e,n,s,r,a,i,o){const u=F(t,"data","stringNGrams","string");if(u.dtype!=="string")throw new Error("Data must be of datatype string");if(u.shape.length!==1)throw new Error(`Data must be a vector, saw: ${u.shape}`);const l=F(e,"dataSplits","stringNGrams");if(l.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const c={separator:n,nGramWidths:s,leftPad:r,rightPad:a,padWidth:i,preserveShortSequences:o},d={data:u,dataSplits:l},h=q.runKernel(yy,d,c);return{nGrams:h[0],nGramsSplits:h[1]}}const QW=U({stringNGrams_:ZW});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JW(t,e,n=!0){const s=F(t,"input","stringSplit","string"),r=F(e,"delimiter","stringSplit","string");if(s.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${s.shape}`);if(r.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);const a={skipEmpty:n},i={input:s,delimiter:r},o=q.runKernel(by,i,a);return{indices:o[0],values:o[1],shape:o[2]}}const eU=U({stringSplit_:JW});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tU(t,e){const n=F(t,"input","stringToHashBucketFast","string"),s={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const r={input:n};return q.runKernel(xy,r,s)}const nU=U({stringToHashBucketFast_:tU});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sU(t,e,n,s=!0){const r=F(t,"input","staticRegexReplace","string"),a={pattern:e,rewrite:n,replaceGlobal:s};return q.runKernel(xh,{x:r},a)}const rU=U({staticRegexReplace_:sU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aU={fft:Mh,ifft:lu,rfft:Vh,irfft:Qy},iU={hammingWindow:RV,hannWindow:nk,frame:sk,stft:zV},ys={flipLeftRight:MV,grayscaleToRGB:WV,resizeNearestNeighbor:ak,resizeBilinear:rk,rgbToGrayscale:GV,rotateWithOffset:qV,cropAndResize:PV,nonMaxSuppression:KV,nonMaxSuppressionAsync:nW,nonMaxSuppressionWithScore:rW,nonMaxSuppressionWithScoreAsync:iW,nonMaxSuppressionPadded:uW,nonMaxSuppressionPaddedAsync:cW,threshold:mW,transform:yW},ik={bandPart:xW,gramSchmidt:$W,qr:SW},oU={absoluteDifference:kW,computeWeightedLoss:Lr,cosineDistance:TW,hingeLoss:EW,huberLoss:RW,logLoss:OW,meanSquaredError:zW,sigmoidCrossEntropy:BW,softmaxCrossEntropy:WW},uU={sparseFillEmptyRows:GW,sparseReshape:qW,sparseSegmentMean:KW,sparseSegmentSum:YW},lU={stringNGrams:QW,stringSplit:eU,stringToHashBucketFast:nU,staticRegexReplace:rU};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cU=new Map,dU=new Map;class mo{getClassName(){return this.constructor.className}static fromConfig(e,n){return new e(n)}}class ms{constructor(){this.classNameMap={}}static getMap(){return ms.instance==null&&(ms.instance=new ms),ms.instance}static register(e){ms.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function ce(t,e,n){O(t.className!=null,()=>"Class being registered does not have the static className property defined."),O(typeof t.className=="string",()=>"className is required to be a string, but got type "+typeof t.className),O(t.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof n>"u"&&(n=t.className);const s=n,r=e+">"+s;return ms.register(t),cU.set(r,t),dU.set(t,r),t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class va extends mo{minimize(e,n=!1,s){const{value:r,grads:a}=this.computeGradients(e,s);if(s!=null){const i=s.map(o=>({name:o.name,tensor:a[o.name]}));this.applyGradients(i)}else this.applyGradients(a);return Ve(a),n?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,n){return FB(e,n)}dispose(){this.iterations_!=null&&Ve(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:Re(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(va,Symbol.hasInstance,{value:t=>t.minimize!=null&&t.computeGradients!=null&&t.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ok extends va{static get className(){return"Adadelta"}constructor(e,n,s=null){super(),this.learningRate=e,this.rho=n,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=q.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const a=q.registeredVariables[s],i=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accum_grad`,variable:ee(()=>rt(a).variable(i))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${s}/accum_var`,variable:ee(()=>rt(a).variable(i))});const o=Array.isArray(e)?e[r].tensor:e[s];if(o==null)return;const u=this.accumulatedGrads[r].variable,l=this.accumulatedUpdates[r].variable;ee(()=>{const c=le(j(u,this.rho),j(xt(o),1-this.rho)),d=j(Te(hn(le(l,this.epsilon)),hn(le(u,this.epsilon))),o),h=le(j(l,this.rho),j(xt(d),1-this.rho));u.assign(c),l.assign(h);const p=le(j(d,-this.learningRate),a);a.assign(p)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Ve(this.accumulatedGrads.map(e=>e.variable)),Ve(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=e.length/2,s=!1;this.accumulatedGrads=e.slice(0,n).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedUpdates=e.slice(n,n*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,n){return new e(n.learningRate,n.rho,n.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uk extends va{static get className(){return"Adagrad"}constructor(e,n=.1){super(),this.learningRate=e,this.initialAccumulatorValue=n,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const a=q.registeredVariables[s];this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accumulator`,variable:ee(()=>co(a.shape,this.initialAccumulatorValue).variable(!1))});const i=Array.isArray(e)?e[r].tensor:e[s];if(i==null)return;const o=this.accumulatedGrads[r].variable;ee(()=>{const u=le(o,xt(i));o.assign(u);const l=le(j(Te(i,hn(le(u,q.backend.epsilon()))),-this.learningRate),a);a.assign(l)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Ve(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=!1;this.accumulatedGrads=e.map(s=>({originalName:s.name,variable:s.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,n){return new e(n.learningRate,n.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lk extends va{static get className(){return"Adam"}constructor(e,n,s,r=null){super(),this.learningRate=e,this.beta1=n,this.beta2=s,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],ee(()=>{this.accBeta1=Re(n).variable(),this.accBeta2=Re(s).variable()}),r==null&&(this.epsilon=q.backend.epsilon())}applyGradients(e){const n=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);ee(()=>{const s=we(1,this.accBeta1),r=we(1,this.accBeta2);n.forEach((a,i)=>{const o=q.registeredVariables[a],u=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${a}/m`,variable:ee(()=>rt(o).variable(u))}),this.accumulatedSecondMoment[i]==null&&(this.accumulatedSecondMoment[i]={originalName:`${a}/v`,variable:ee(()=>rt(o).variable(u))});const l=Array.isArray(e)?e[i].tensor:e[a];if(l==null)return;const c=this.accumulatedFirstMoment[i].variable,d=this.accumulatedSecondMoment[i].variable,h=le(j(c,this.beta1),j(l,1-this.beta1)),p=le(j(d,this.beta2),j(xt(l),1-this.beta2)),f=Te(h,s),m=Te(p,r);c.assign(h),d.assign(p);const g=le(j(Te(f,le(hn(m),this.epsilon)),-this.learningRate),o);o.assign(g)}),this.accBeta1.assign(j(this.accBeta1,this.beta1)),this.accBeta2.assign(j(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Ve(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&Ve(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e),ee(()=>{this.accBeta1.assign(Er(this.beta1,this.iterations_+1)),this.accBeta2.assign(Er(this.beta2,this.iterations_+1))});const n=e.length/2,s=!1;this.accumulatedFirstMoment=e.slice(0,n).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedSecondMoment=e.slice(n,n*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,n){return new e(n.learningRate,n.beta1,n.beta2,n.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ck extends va{static get className(){return"Adamax"}constructor(e,n,s,r=null,a=0){super(),this.learningRate=e,this.beta1=n,this.beta2=s,this.epsilon=r,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],ee(()=>{this.iteration=Re(0).variable(),this.accBeta1=Re(n).variable()}),r==null&&(this.epsilon=q.backend.epsilon())}applyGradients(e){const n=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);ee(()=>{const s=we(1,this.accBeta1),r=Te(-this.learningRate,le(j(this.iteration,this.decay),1));n.forEach((a,i)=>{const o=q.registeredVariables[a],u=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${a}/m`,variable:rt(o).variable(u)}),this.accumulatedWeightedInfNorm[i]==null&&(this.accumulatedWeightedInfNorm[i]={originalName:`${a}/v`,variable:rt(o).variable(u)});const l=Array.isArray(e)?e[i].tensor:e[a];if(l==null)return;const c=this.accumulatedFirstMoment[i].variable,d=this.accumulatedWeightedInfNorm[i].variable,h=le(j(c,this.beta1),j(l,1-this.beta1)),p=j(d,this.beta2),f=Ut(l),m=zr(p,f);c.assign(h),d.assign(m);const g=le(j(Te(r,s),Te(h,le(m,this.epsilon))),o);o.assign(g)}),this.iteration.assign(le(this.iteration,1)),this.accBeta1.assign(j(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Ve(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&Ve(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,n){return new e(n.learningRate,n.beta1,n.beta2,n.epsilon,n.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cb extends va{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const a=Array.isArray(e)?e[r].tensor:e[s];if(a==null)return;const i=q.registeredVariables[s];ee(()=>{const o=le(j(this.c,a),i);i.assign(o)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=tn(Re(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,n){return new e(n.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dk extends cb{static get className(){return"Momentum"}constructor(e,n,s=!1){super(e),this.learningRate=e,this.momentum=n,this.useNesterov=s,this.accumulations=[],this.m=Re(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const a=q.registeredVariables[s];this.accumulations[r]==null&&(this.accumulations[r]={originalName:`${s}/momentum`,variable:ee(()=>rt(a).variable(!1))});const i=this.accumulations[r].variable,o=Array.isArray(e)?e[r].tensor:e[s];o!=null&&ee(()=>{let u;const l=le(j(this.m,i),o);this.useNesterov?u=le(j(this.c,le(o,j(l,this.m))),a):u=le(j(this.c,l),a),i.assign(l),a.assign(u)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Ve(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=!1;this.accumulations=e.map(s=>({originalName:s.name,variable:s.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,n){return new e(n.learningRate,n.momentum,n.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hk extends va{static get className(){return"RMSProp"}constructor(e,n=.9,s=0,r=null,a=!1){if(super(),this.learningRate=e,this.decay=n,this.momentum=s,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,r==null&&(this.epsilon=q.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const a=q.registeredVariables[s],i=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${s}/rms`,variable:ee(()=>rt(a).variable(i))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${s}/momentum`,variable:ee(()=>rt(a).variable(i))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${s}/mg`,variable:ee(()=>rt(a).variable(i))});const o=Array.isArray(e)?e[r].tensor:e[s];if(o==null)return;const u=this.accumulatedMeanSquares[r].variable,l=this.accumulatedMoments[r].variable;ee(()=>{const c=le(j(u,this.decay),j(xt(o),1-this.decay));if(this.centered){const d=this.accumulatedMeanGrads[r].variable,h=le(j(d,this.decay),j(o,1-this.decay)),p=Te(j(o,this.learningRate),hn(we(c,le(xt(h),this.epsilon)))),f=le(j(l,this.momentum),p);u.assign(c),d.assign(h),l.assign(f);const m=we(a,f);a.assign(m)}else{const d=le(j(u,this.decay),j(xt(o),1-this.decay)),h=le(j(l,this.momentum),Te(j(o,this.learningRate),hn(le(d,this.epsilon))));u.assign(d),l.assign(h);const p=we(a,h);a.assign(p)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Ve(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Ve(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&Ve(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=this.centered?e.length/3:e.length/2,s=!1;this.accumulatedMeanSquares=e.slice(0,n).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedMoments=e.slice(n,n*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=e.slice(n*2,n*3).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,n){return new e(n.learningRate,n.decay,n.momentum,n.epsilon,n.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hU=[ok,uk,lk,ck,dk,hk,cb];function pU(){for(const t of hU)ce(t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fU="model",mU=".json",gU=".weights.bin";function h1(t){return new Promise(e=>setTimeout(e)).then(t)}class ii{constructor(e){if(!te().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(ii.URL_SCHEME)&&(e=e.slice(ii.URL_SCHEME.length)),(e==null||e.length===0)&&(e=fU),this.modelJsonFileName=e+mU,this.weightDataFileName=e+gU}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const n=Qs.join(e.weightData),s=window.URL.createObjectURL(new Blob([n],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const r=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],a=GI(e,r),i=window.URL.createObjectURL(new Blob([JSON.stringify(a)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=i,await h1(()=>o.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const u=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;u.download=this.weightDataFileName,u.href=s,await h1(()=>u.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:gl(e)}}}}ii.URL_SCHEME="downloads://";class yU{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,n)=>{const s=new FileReader;s.onload=r=>{const a=JSON.parse(r.target.result),i=a.modelTopology;if(i==null){n(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(a.weightsManifest==null){n(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:i});return}const u=ky(a,l=>this.loadWeights(l));e(u)},s.onerror=r=>n(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(this.jsonFile)})}loadWeights(e){const n=[],s=[];for(const i of e)n.push(...i.weights),s.push(...i.paths);const r=this.checkManifestAndWeightFiles(e),a=s.map(i=>this.loadWeightsFile(i,r[i]));return Promise.all(a).then(i=>[n,i])}loadWeightsFile(e,n){return new Promise((s,r)=>{const a=new FileReader;a.onload=i=>{const o=i.target.result;s(o)},a.onerror=i=>r(`Failed to weights data from file of path '${e}'.`),a.readAsArrayBuffer(n)})}checkManifestAndWeightFiles(e){const n=[],s=this.weightsFiles.map(a=>t1(a.name)),r={};for(const a of e)a.paths.forEach(i=>{const o=t1(i);if(n.indexOf(o)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${o}'`);if(n.push(o),s.indexOf(o)===-1)throw new Error(`Weight file with basename '${o}' is not provided.`);r[i]=this.weightsFiles[s.indexOf(o)]});if(n.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${n.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}const bU=t=>te().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(ii.URL_SCHEME)?xU(t.slice(ii.URL_SCHEME.length)):null;Tt.registerSaveRouter(bU);function xU(t="model"){return new ii(t)}function wU(t){return new yU(t)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p1(t,e,n,s){i(t),n=n??0,s=s??1,o(n,s);let r=0;const a=u=>(u.then(l=>{const c=n+ ++r/t.length*(s-n);return e(c),l}),u);function i(u){O(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function o(u,l){O(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),O(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${l}`),O(l>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${l}`)}return Promise.all(t.map(a))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function pk(t,e){e==null&&(e={});const n=e.fetchFunc==null?te().platform.fetch:e.fetchFunc,s=t.map(d=>n(d,e.requestInit,{isBinary:!0})),o=(e.onProgress==null?await Promise.all(s):await p1(s,e.onProgress,0,.5)).map(d=>d.arrayBuffer());return e.onProgress==null?await Promise.all(o):await p1(o,e.onProgress,.5,1)}function $U(t,e){var n;const s=e.fetchFunc==null?te().platform.fetch:e.fetchFunc;let r=0,a;return(n=e.onProgress)===null||n===void 0||n.call(e,0),new ReadableStream({pull:async i=>{for(var o;r<t.length;){a||(a=(await s(t[r],e.requestInit,{isBinary:!0})).body.getReader());const{done:u,value:l}=await a.read();if(u){r++,a=void 0,(o=e.onProgress)===null||o===void 0||o.call(e,r/t.length);continue}i.enqueue(l);return}i.close()}})}async function vU(t,e="",n,s){return fk(i=>pk(i,{requestInit:s}))(t,e,n)}function fk(t){return async(e,n="",s)=>{const r=e.map(()=>!1),a={},i=s!=null?s.map(()=>!1):[],o=[];if(e.forEach((p,f)=>{let m=0;p.weights.forEach(g=>{const y="quantization"in g?g.quantization.dtype:g.dtype,b=ei[y]*se(g.shape),$=()=>{r[f]=!0,a[f]==null&&(a[f]=[]),a[f].push({manifestEntry:g,groupOffset:m,sizeBytes:b})};s!=null?s.forEach((w,v)=>{w===g.name&&($(),i[v]=!0)}):$(),o.push(g.name),m+=b})}),!i.every(p=>p)){const p=s.filter((f,m)=>!i[m]);throw new Error(`Could not find weights in manifest with names: ${p.join(", ")}. 
Manifest JSON has weights with names: ${o.join(", ")}.`)}const u=r.reduce((p,f,m)=>(f&&p.push(m),p),[]),l=[];u.forEach(p=>{e[p].paths.forEach(f=>{const m=n+(n.endsWith("/")?"":"/")+f;l.push(m)})});const c=await t(l),d={};let h=0;return u.forEach(p=>{const f=e[p].paths.length,m=new Qs(c.slice(h,h+f));a[p].forEach(y=>{const b=m.slice(y.groupOffset,y.groupOffset+y.sizeBytes),$=MI(b,[y.manifestEntry]);for(const w in $)d[w]=$[w]}),h+=f}),d}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SU="application/octet-stream",IU="application/json";class db{constructor(e,n){if(this.DEFAULT_METHOD="POST",n==null&&(n={}),this.weightPathPrefix=n.weightPathPrefix,this.weightUrlConverter=n.weightUrlConverter,n.fetchFunc!=null?(O(typeof n.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=n.fetchFunc):this.fetch=te().platform.fetch,O(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&O(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,n.requestInit!=null&&n.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=n.requestInit||{},this.loadOptions=n}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const n=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);n.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=GI(e,s);if(n.body.append("model.json",new Blob([JSON.stringify(r)],{type:IU}),"model.json"),e.weightData!=null){const i=Qs.join(e.weightData);n.body.append("model.weights.bin",new Blob([i],{type:SU}),"model.weights.bin")}const a=await this.fetch(this.path,n);if(a.ok)return{modelArtifactsInfo:gl(e),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let n;try{n=await e.json()}catch{let i=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?i+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":i+=" Please make sure the server is serving valid JSON for this request.",new Error(i)}const s=n.modelTopology,r=n.weightsManifest;if(s==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return n}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const e=await this.loadModelJSON();return ky(e,n=>this.loadWeights(n))}async loadStream(){const e=await this.loadModelJSON(),n=await this.getWeightUrls(e.weightsManifest),s=ym(e.weightsManifest),r=()=>$U(n,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:s,getWeightStream:r})}async getWeightUrls(e){const n=Array.isArray(this.path)?this.path[1]:this.path,[s,r]=_U(n),a=this.weightPathPrefix||s,i=[],o=[];for(const u of e)for(const l of u.paths)this.weightUrlConverter!=null?o.push(this.weightUrlConverter(l)):i.push(a+l+r);return this.weightUrlConverter&&i.push(...await Promise.all(o)),i}async loadWeights(e){const n=await this.getWeightUrls(e),s=ym(e),r=await pk(n,this.loadOptions);return[s,r]}}db.URL_SCHEME_REGEX=/^https?:\/\//;function _U(t){const e=t.lastIndexOf("/"),n=t.lastIndexOf("?"),s=t.substring(0,e),r=n>e?t.substring(n):"";return[s+"/",r]}function Im(t){return t.match(db.URL_SCHEME_REGEX)!=null}const mk=(t,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let n=!0;if(Array.isArray(t)?n=t.every(s=>Im(s)):n=Im(t),n)return hb(t,e)}return null};Tt.registerSaveRouter(mk);Tt.registerLoadRouter(mk);function hb(t,e){return new db(t,e)}function kU(t,e){return hb(t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Gp{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class gk{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class CU{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=n=>Promise.resolve(e.save(n)))}}function TU(t,e,n,s){const r=arguments;return new CU(yk(...r))}function yk(t,e,n,s){return arguments.length===1?t.modelTopology!=null||t.weightSpecs!=null?new Gp(t):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Gp({modelTopology:t})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Gp({modelTopology:t,weightSpecs:e,weightData:n,trainingConfig:s}))}function NU(t){return new gk(t)}function EU(t){return new gk(t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bk=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:Qs,browserFiles:wU,browserHTTPRequest:kU,concatenateArrayBuffers:UI,copyModel:EL,decodeWeights:MI,decodeWeightsStream:WI,encodeWeights:gm,fromMemory:TU,fromMemorySync:yk,getLoadHandlers:gL,getModelArtifactsForJSON:ky,getModelArtifactsForJSONSync:HI,getModelArtifactsInfoForJSON:gl,getSaveHandlers:qI,getWeightSpecs:ym,http:hb,isHTTPScheme:Im,listModels:TL,loadWeights:vU,moveModel:AL,registerLoadRouter:mL,registerSaveRouter:fL,removeModel:NL,weightsLoaderFactory:fk,withSaveHandler:NU,withSaveHandlerSync:EU},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Ea;function AU(t,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(t==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,s=!1,r=!1,a=!1,i=!1,o=!1;if(t.data instanceof Uint8Array)n=!0;else if(typeof ImageData<"u"&&t instanceof ImageData)s=!0;else if(typeof HTMLVideoElement<"u"&&t instanceof HTMLVideoElement)r=!0;else if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement)a=!0;else if(t.getContext!=null)i=!0;else if(typeof ImageBitmap<"u"&&t instanceof ImageBitmap)o=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${t.constructor.name}`);if(cm(um,q.backendName)!=null){const f={pixels:t},m={numChannels:e};return q.runKernel(um,f,m)}const[l,c]=r?[t.videoWidth,t.videoHeight]:[t.width,t.height];let d;if(i)d=t.getContext("2d").getImageData(0,0,l,c).data;else if(s||n)d=t.data;else if(a||r||o){if(Ea==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")Ea=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else Ea=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Ea.canvas.width=l,Ea.canvas.height=c,Ea.drawImage(t,0,0,l,c),d=Ea.getImageData(0,0,l,c).data}let h;if(e===4)h=new Int32Array(d);else{const f=l*c;h=new Int32Array(f*e);for(let m=0;m<f;m++)for(let g=0;g<e;++g)h[m*e+g]=d[m*4+g]}return H_(h,[c,l,e],"int32")}const xk=U({fromPixels_:AU});function pb(t,e){const n=t.shape.length,s=e.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[s-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[s-1]} vs. ${n}`);if(se(t.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);const r=e.shape,a=r[r.length-1];let i=1;for(let d=0;d<r.length-1;++d)i*=r[d];const o=t.shape,u=r.slice();u.pop();let l=1;for(let d=a;d<n;++d)l*=o[d],u.push(o[d]);const c=[...Ae(t.shape).map(d=>d/l),1].slice(0,a);return[u,i,l,c]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _m=-2,RU=-1;function fb(t,e,n){const s=t.shape.length;O(s===e.length,()=>`Error in slice${s}D: Length of begin ${e} must match the rank of the array (${s}).`),O(s===n.length,()=>`Error in slice${s}D: Length of size ${n} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)O(e[r]+n[r]<=t.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${e[r]+n[r]}) would overflow input.shape[${r}] (${t.shape[r]})`)}function DU(t){const e=[];let n=0;for(;t>0;)t&1&&e.push(n),t/=2,n++;return e}function mb(t,e,n){const s=[];for(let r=0;r<t.length;r++)s[r]=Math.ceil((e[r]-t[r])/n[r]);return s}function wk(t,e,n,s){const r=[...t];for(let a=r.length;a<s.length;a++)r.push(1);for(let a=0;a<n;a++)a===0?r[e]=1:(r.splice(e,0,1),r.pop());return r}function $k(t,e,n){return n<=t?n:n-(e-1)}function vk(t,e){const n=[];for(let s=0;s<t;s++)n.push(e+s);return n}function OU(t,e,n,s,r,a,i,o,u){const l=t.length;let c=new Array(l),d=new Array(l),h=new Array(l);if(e.length&&n>0){const p=e[0],f=n+1;c=Sk(i,p,f,s,t),d=Ik(o,p,f,r,t),h=wk(a,p,f,t)}else for(let p=0;p<l;p++)c[p]=kk(i,s,a,t,p,u),d[p]=Ck(o,r,a,t,p,u),h[p]=_k(a,p,u);return{begin:c,end:d,strides:h}}function Sk(t,e,n,s,r){const a=[...r],i=vk(n,e);for(let o=0;o<a.length;o++)if(i.indexOf(o)>-1)a[o]=0;else{const u=$k(e,n,o);let l=s[u];t&1<<u&&(l=0),a[o]=l}return a}function Ik(t,e,n,s,r){const a=[...r],i=vk(n,e);for(let o=0;o<a.length;o++)if(i.indexOf(o)>-1)a[o]=Number.MAX_SAFE_INTEGER;else{const u=$k(e,n,o);let l=s[u];t&1<<u&&(l=Number.MAX_SAFE_INTEGER),a[o]=l}for(let o=0;o<a.length;o++){const u=r[o];a[o]<0&&(a[o]+=u),a[o]=Za(0,a[o],r[o])}return a}function _k(t,e,n){let s=t[e];return(n&1<<e||s==null)&&(s=1),s}function kk(t,e,n,s,r,a){let i=e[r];const o=n[r]||1;(t&1<<r||a&1<<r||i==null)&&(o>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);const u=s[r];return i<0&&(i+=u),i=Za(0,i,u-1),i}function Ck(t,e,n,s,r,a){let i=e[r];const o=n[r]||1;(t&1<<r||a&1<<r||i==null)&&(o>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);const u=s[r];return i<0&&(i+=u),o>0?i=Za(0,i,u):i=Za(-1,i,u-1),i}function gb(t,e,n){let s=n.length;for(let r=0;r<n.length;r++)if(n[r]>1){s=r;break}for(let r=s+1;r<n.length;r++)if(e[r]>0||n[r]!==t[r])return!1;return!0}function yb(t,e){let n=t.length>0?t[t.length-1]:1;for(let s=0;s<t.length-1;s++)n+=t[s]*e[s];return n}function qh(t,e,n){let s;const r=t.shape.length;typeof e=="number"?s=[e,...new Array(r-1).fill(0)]:e.length<r?s=e.concat(new Array(r-e.length).fill(0)):s=e.slice(),s.forEach(i=>{O(i!==-1,()=>"slice() does not support negative begin indexing.")});let a;return n==null?a=new Array(r).fill(-1):typeof n=="number"?a=[n,...new Array(r-1).fill(-1)]:n.length<r?a=n.concat(new Array(r-n.length).fill(-1)):a=n,a=a.map((i,o)=>i>=0?i:(O(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${o}.`),t.shape[o]-s[o])),[s,a]}function bb(t,e,n,s,r,a,i,o,u){let l;if(s==null?(l=new Array(e.length),l.fill(1)):l=s,i!=null&&(i&i-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const d={dims:l.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:n.slice(),strides:l.slice(),beginMask:r,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:u};for(let $=0;$<d.dims;$++)c&&(1<<$&o)!==0&&d.numAddAxisAfterEllipsis++,1<<$&i&&(c=!0);c||(d.ellipsisMask|=1<<d.dims,d.dims++);const h={dims:t.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};FU(d,h);let p=!0,f=!0,m=!0;const g=[],y=[];for(let $=0;$<t.length;++$){if(h.strides[$]===0)throw Error(`strides[${$}] must be non-zero`);const w=!!(h.shrinkAxisMask&1<<$),v=t[$];if(v===-1){g.push(w?1:-1);continue}const k=[h.beginMask&1<<$,h.endMask&1<<$],C=[h.strides[$]>0?0:-1,h.strides[$]>0?v:v-1];if(w&&h.strides[$]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&h.strides[$]===1;const N=!!(h.beginMask&1<<$&&h.endMask&1<<$);if(h.beginValid&&h.endValid){if(w){const z=h.begin[$]<0?v+h.begin[$]:h.begin[$];if(h.begin[$]=z,h.end[$]=h.begin[$]+1,z<0||z>=v)throw Error(`slice index ${h.begin[$]} of dimension ${$} out of bounds.`)}else h.begin[$]=f1(h.begin[$],0,h.strides[$],v,k,C),h.end[$]=f1(h.end[$],1,h.strides[$],v,k,C);const E=h.strides[$]===1&&h.begin[$]===0&&h.end[$]===v;p=p&&E,f=f&&($===0&&h.strides[$]===1||E)}else p=p&&h.strides[$]===1&&N,f=f&&($===0&&h.strides[$]===1||N);let A,I=!1;if(h.beginValid&&h.endValid?(A=h.end[$]-h.begin[$],I=!0):w?(A=1,I=!0):N&&v>=0&&(h.strides[$]<0?A=-v:A=v,I=!0),I){let E;A===0||A<0!=h.strides[$]<0?E=0:E=Math.trunc(A/h.strides[$])+(A%h.strides[$]!==0?1:0),g.push(E)}else g.push(-1)}for(let $=0;$<h.finalShapeGatherIndices.length;++$){const w=h.finalShapeGatherIndices[$];w>=0?y.push(g[w]):w===_m&&y.push(1)}return{finalShapeSparse:y.filter(($,w)=>h.finalShapeGatherIndices[w]!==_m),finalShape:y,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:h.begin,end:h.end,strides:h.strides}}function FU(t,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let n=0;e.beginValid=t.begin!=null,e.endValid=t.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let s=0;s<t.dims;s++)if(1<<s&t.ellipsisMask){const r=Math.min(e.dims-(t.dims-s)+1+t.numAddAxisAfterEllipsis,e.dims);for(;n<r;n++)e.begin[n]=0,e.end[n]=0,e.strides[n]=1,e.beginMask|=1<<n,e.endMask|=1<<n,e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[n]=s}else if(1<<s&t.newAxisMask)e.finalShapeGatherIndices.push(_m),e.finalShapeGatherIndicesSparse.push(-1);else{if(n===e.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${e.dims} dims, ${e.begin.length}.`);t.begin!=null&&(e.begin[n]=t.begin[s]),t.end!=null&&(e.end[n]=t.end[s]),e.strides[n]=t.strides[s],t.beginMask&1<<s&&(e.beginMask|=1<<n),t.endMask&1<<s&&(e.endMask|=1<<n),t.shrinkAxisMask&1<<s?(e.finalShapeGatherIndices.push(RU),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<n):(e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(s)),e.inputShapeGatherIndicesSparse[n]=s,n++}}function f1(t,e,n,s,r,a){if(r[e])return n>0?a[e]:a[e+1&1];{const i=t<0?s+t:t;return i<a[0]?a[0]:i>a[1]?a[1]:i}}const zU=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:fb,computeFlatOffset:yb,computeOutShape:mb,getNormalizedAxes:OU,isSliceContinous:gb,maskToAxes:DU,parseSliceParams:qh,sliceInfo:bb,startForAxis:kk,startIndicesWithElidedDims:Sk,stopForAxis:Ck,stopIndicesWithElidedDims:Ik,stridesForAxis:_k,stridesWithElidedDims:wk},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LU{static sgd(e){return new cb(e)}static momentum(e,n,s=!1){return new dk(e,n,s)}static rmsprop(e,n=.9,s=0,r=null,a=!1){return new hk(e,n,s,r,a)}static adam(e=.001,n=.9,s=.999,r=null){return new lk(e,n,s,r)}static adadelta(e=.001,n=.95,s=null){return new ok(e,n,s)}static adamax(e=.002,n=.9,s=.999,r=null,a=0){return new ck(e,n,s,r,a)}static adagrad(e,n=.1){return new uk(e,n)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ni=LU;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PU=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:t=>t();function Tk(){return new Promise(t=>PU(()=>t()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xb(t,e){const n=t[0].length;t.forEach((r,a)=>{O(r.length===n,()=>`Error in concat${n}D: rank of tensors[${a}] must be the same as the rank of the rest (${n})`)}),O(e>=0&&e<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const s=t[0];t.forEach((r,a)=>{for(let i=0;i<n;i++)O(i===e||r[i]===s[i],()=>`Error in concat${n}D: Shape of tensors[${a}] (${r}) does not match the shape of the rest (${s}) along the non-concatenated axis ${a}.`)})}function hr(t,e){const n=t[0].slice();for(let s=1;s<t.length;s++)n[e]+=t[s][e];return n}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ws;(function(t){t[t.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",t[t.VALUE_ROWIDS=1]="VALUE_ROWIDS",t[t.ROW_LENGTHS=2]="ROW_LENGTHS",t[t.ROW_SPLITS=3]="ROW_SPLITS",t[t.ROW_LIMITS=4]="ROW_LIMITS",t[t.ROW_STARTS=5]="ROW_STARTS"})(Ws||(Ws={}));function Nk(t,e,n){let s=new Array;if(n==null&&e==null)return s;if(e==null)for(;s.length<t+n.length;)s.push(-1);else s=e.slice();if(n==null)return s;if(t+n.length!==s.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${t+n.length}, but shape.rank = ${s.length}`);for(let r=1;r<n.length;++r){const a=n[r],i=s[s.length-n.length+r],o=s[i];if(a>=0)if(o>=0){if(o!==a)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${r+t}] = ${a} but shape[${r+t}] = ${o}`)}else s[i]=a}return s}function Ek(t){const e={FIRST_DIM_SIZE:Ws.FIRST_DIM_SIZE,VALUE_ROWIDS:Ws.VALUE_ROWIDS,ROW_LENGTHS:Ws.ROW_LENGTHS,ROW_SPLITS:Ws.ROW_SPLITS,ROW_LIMITS:Ws.ROW_LIMITS,ROW_STARTS:Ws.ROW_STARTS},n=[];for(const s of t)if(s in e)n.push(e[s]);else break;return n}function Ak(t){return t.length===0?0:t[0]===Ws.FIRST_DIM_SIZE?t.length-1:t.length}function Rk(t,e){if(t==null||e==null)return;const n=t.length,s=e.length;if(n>=s)throw new Error(`defaultValue.shape=${t} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${s})`);for(let r=0;r<Math.min(n,s-1);++r){const a=t[r],i=e[r+1];if(a>=0&&i>=0&&a!==1&&a!==i)throw new Error(`defaultValue.shape=${t}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${r-t.length}] = ${a} but ragged tensor input.flatValues.shape[${r-t.length}] = ${i}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wb=30;function jh(t){return t<=wb?t:am(t,Math.floor(Math.sqrt(t)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $b(t,e,n){const s=n*(typeof t=="number"?t:t[0]),r=e*(typeof t=="number"?t:t[1]);return[s,r]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Il(t,e,n,s=!0){let r=[];if(s)r=r.concat(e.slice(0)),r.push(t[0]/n),r=r.concat(t.slice(1));else{r=r.concat(t[0]);const a=e.length;for(let i=0;i<a;++i)r=r.concat([t[i+1]/e[i],e[i]]);r=r.concat(t.slice(a+1))}return r}function _l(t,e,n=!0){const s=[];if(n){s.push(e);for(let r=e+1;r<t;++r)r<=2*e?(s.push(r),s.push(r-(e+1))):s.push(r)}else{const r=[],a=[];for(let i=1;i<t;++i)i>=e*2+1||i%2===1?a.push(i):r.push(i);s.push(...r),s.push(0),s.push(...a)}return s}function kl(t,e,n,s=!0){const r=[];s?r.push(t[0]/n):r.push(t[0]*n);for(let a=1;a<t.length;++a)a<=e.length?s?r.push(e[a-1]*t[a]):r.push(t[a]/e[a-1]):r.push(t[a]);return r}function vb(t,e){const n=[0];for(let s=0;s<e;++s)n.push(t[s][0]);return n}function Sb(t,e,n){const s=t.slice(0,1);for(let r=0;r<n;++r)s.push(t[r+1]-e[r][0]-e[r][1]);return s}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kh=1.7580993408473768,Xh=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ib=.3275911,_b=.254829592,kb=-.284496736,Cb=1.421413741,Tb=-1.453152027,Nb=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rr(t,e){if(t.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${e.length}.`);const n=new Float32Array(t.length*2);for(let s=0;s<n.length;s+=2)n[s]=t[s/2],n[s+1]=e[s/2];return n}function Dk(t){const e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let s=0;s<t.length;s+=2)e[s/2]=t[s],n[s/2]=t[s+1];return{real:e,imag:n}}function Ok(t){const e=Math.ceil(t.length/4),n=new Float32Array(e),s=new Float32Array(e);for(let r=0;r<t.length;r+=4)n[Math.floor(r/4)]=t[r],s[Math.floor(r/4)]=t[r+1];return{real:n,imag:s}}function Fk(t){const e=Math.floor(t.length/4),n=new Float32Array(e),s=new Float32Array(e);for(let r=2;r<t.length;r+=4)n[Math.floor(r/4)]=t[r],s[Math.floor(r/4)]=t[r+1];return{real:n,imag:s}}function Eb(t,e){const n=t[e*2],s=t[e*2+1];return{real:n,imag:s}}function zk(t,e,n,s){t[s*2]=e,t[s*2+1]=n}function Lk(t,e){const n=new Float32Array(t/2),s=new Float32Array(t/2);for(let r=0;r<Math.ceil(t/2);r++){const a=(e?2:-2)*Math.PI*(r/t);n[r]=Math.cos(a),s[r]=Math.sin(a)}return{real:n,imag:s}}function Pk(t,e,n){const s=(n?2:-2)*Math.PI*(t/e),r=Math.cos(s),a=Math.sin(s);return{real:r,imag:a}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hp="->",BU=/->/g,m1=",",g1="...";function Ab(t,e){t=t.replace(/\s/g,"");const n=(t.length-t.replace(BU,"").length)/Hp.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${Hp}").`);const[s,r]=t.split(Hp);O(s.indexOf(g1)===-1,()=>`The ellipsis notation ("${g1}") is not supported yet.`);const a=s.split(m1),i=a.length;if(e!==i)throw new Error(`Expected ${i} input tensors, received ${e}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let h=0;h<r.length;++h){const p=r[h];if(!a.some(f=>f.indexOf(p)!==-1))throw new Error(`Output subscripts contain the label ${p} not present in the input subscripts.`);o.indexOf(p)===-1&&o.push(p)}for(let h=0;h<s.length;++h){const p=s[h];o.indexOf(p)===-1&&p!==m1&&o.push(p)}const u=new Array(a.length);for(let h=0;h<i;++h){if(new Set(a[h].split("")).size!==a[h].length)throw new Error(`Found duplicate axes in input component ${a[h]}. Support for duplicate axes in input is not implemented yet.`);u[h]=[];for(let p=0;p<a[h].length;++p)u[h].push(o.indexOf(a[h][p]))}const l=o.length,c=r.length,d=[];for(let h=c;h<l;++h)d.push(h);return{allDims:o,summedDims:d,idDims:u}}function Rb(t,e){let n=new Array(t);n.fill(-1);for(let r=0;r<e.length;++r)n[e[r]]=r;const s=[];for(let r=0;r<t;++r)n[r]===-1&&s.push(r);return n=n.filter(r=>r!==-1),{permutationIndices:n,expandDims:s}}function Db(t,e,n){const s=new Array(t);for(let r=0;r<n.length;++r){const a=n[r].shape;for(let i=0;i<e[r].length;++i)s[e[r][i]]===void 0?s[e[r][i]]=a[i]:O(s[e[r][i]]===a[i],()=>`Expected dimension ${s[e[r][i]]} at axis ${i} of input shaped ${JSON.stringify(a)}, but got dimension ${a[i]}`)}}function Ob(t,e){const n=t,s=[];let r=0;t.length===0&&n.push(-1),r=t.length+1;for(let i=0;i<r;++i)s.push([]);const a=[];for(let i=0;i<n.length;++i){const o=n[i],u=MU(e,o);for(const l of u)a.indexOf(l)===-1&&(s[i].push(l),a.push(l))}return{path:n,steps:s}}function Fb(t){return t.every((e,n)=>e===n)}function MU(t,e){const n=[];for(let s=0;s<t.length;++s)(t[s].length===0||t[s].indexOf(e)!==-1||e===-1)&&n.push(s);return n}function zb(t,e,n=0){let s=[];if(typeof e=="number")O(t.shape[n]%e===0,()=>"Number of splits must evenly divide the axis."),s=new Array(e).fill(t.shape[n]/e);else{const r=e.reduce((i,o)=>(o===-1&&(i+=1),i),0);O(r<=1,()=>"There should be only one negative value in split array.");const a=e.indexOf(-1);if(a!==-1){const i=e.reduce((o,u)=>u>0?o+u:o);e[a]=t.shape[n]-i}O(t.shape[n]===e.reduce((i,o)=>i+o),()=>"The sum of sizes must match the size of the axis dimension."),s=e}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bk(t){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${t}`}function Mk(t,e){return`indices(${t}, 0) is invalid: ${e} < 0`}function Vk(t,e,n){return`indices(${t}, 0) is invalid: ${e} >= ${n}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wk(t,e){return`only one output dimension may be -1, not both ${t} and ${e}`}function Uk(t,e){return`size ${t} must be non-negative, not ${e}`}function Gk(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Hk(t,e){const n=se(t),s=se(e);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${t} outputShape= ${e}`}function qk(t,e){const n=se(t),s=se(e);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${s}. inputShape=${t} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function km(){return"segment ids must be >= 0"}function jk(){return"segment ids are not increasing"}function Kk(t,e){return`Segment id ${t} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function Xk(t,e,n){return`Bad: indices[${t}] == ${e} out of range [0, ${n})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yk(t,e){let n=!1,s;for(t<=wb?(s=t,n=!0):s=am(t,Math.floor(Math.sqrt(t)));!n;)s>e||s===t?n=!0:s=am(t,s+1);return s}function Zk(t,e,n){const s=[],r=t.length;for(let a=0;a<r;a++)a!==e?s.push(t[a]):s.push(n);return s}function Lb(t,e,n,s){const r=e.shape.length,a=t.shape.length;if(s!==0&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>a)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${a}).`);if(n<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${n}).`);for(let d=0;d<s;++d)if(t.shape[d]!==e.shape[d])throw new Error(`x.shape[${d}]: ${t.shape[d]} should be equal to indices.shape[${d}]: ${e.shape[d]}.`);const i=t.shape[n],o=[];let u=1,l=1,c=1;for(let d=0;d<s;++d)o.push(t.shape[d]),u*=t.shape[d];for(let d=s;d<n;d++)o.push(t.shape[d]),l*=t.shape[d];for(let d=s;d<r;d++)o.push(e.shape[d]);for(let d=n+1;d<a;d++)o.push(t.shape[d]),c*=t.shape[d];return{batchSize:u,sliceSize:c,outerSize:l,dimSize:i,outputShape:o}}const VU=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:Lb,computeOutShape:Zk,segOpComputeOptimalWindowSize:Yk},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dr(t){try{return t.map(e=>sa(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function Qk(t){return t.map(e=>ea(e))}const WU=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:_b,ERF_A2:kb,ERF_A3:Cb,ERF_A4:Tb,ERF_A5:Nb,ERF_P:Ib,PARALLELIZE_THRESHOLD:wb,get RowPartitionType(){return Ws},SELU_SCALE:Xh,SELU_SCALEALPHA:Kh,applyActivation:Gh,assertAndGetBroadcastShape:We,assertAxesAreInnerMostDims:fn,assertParamsConsistent:xb,assignToTypedArray:zk,axesAreInnerMostDims:zy,calculateShapes:xi,checkEinsumDimSizes:Db,checkPadOnDimRoundingMode:Nn,combineLocations:k_,combineRaggedTensorToTensorShapes:Nk,complexWithEvenIndex:Ok,complexWithOddIndex:Fk,computeConv2DInfo:rn,computeConv3DInfo:ba,computeDefaultPad:Ny,computeDilation2DInfo:yl,computeOptimalWindowSize:jh,computeOutAndReduceShapes:an,computeOutShape:hr,computePool2DInfo:_s,computePool3DInfo:Or,convertConv2DDataFormat:Fr,decodeEinsumEquation:Ab,eitherStridesOrDilationsAreOne:pn,expandShapeToKeepDim:Lt,exponent:Pk,exponents:Lk,fromStringArrayToUint8:Qk,fromUint8ToStringArray:Dr,getAxesPermutation:At,getBroadcastDims:Xi,getComplexWithIndex:Eb,getEinsumComputePath:Ob,getEinsumPermutation:Rb,getFusedBiasGradient:Uh,getFusedDyActivation:Wh,getImageCenter:$b,getInnerMostAxes:Pt,getPermuted:_l,getRaggedRank:Ak,getReductionAxes:Yt,getReshaped:Il,getReshapedPermuted:kl,getRowPartitionTypesHelper:Ek,getSliceBeginCoords:vb,getSliceSize:Sb,getSparseFillEmptyRowsIndicesDenseShapeMismatch:Bk,getSparseFillEmptyRowsNegativeIndexErrorMessage:Mk,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:Vk,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:Gk,getSparseReshapeInputOutputMismatchErrorMessage:qk,getSparseReshapeInputOutputMultipleErrorMessage:Hk,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:Wk,getSparseReshapeNegativeOutputDimErrorMessage:Uk,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:Xk,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:km,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:jk,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:Kk,getUndoAxesPermutation:xa,isIdentityPermutation:Fb,log:Tz,mergeRealAndImagArrays:Rr,prepareAndValidate:pb,prepareSplitSize:zb,segment_util:VU,shouldFuse:Hh,slice_util:zU,splitRealAndImagArrays:Dk,stridesOrDilationsArePositive:si,tupleValuesAreOne:ia,upcastType:Hn,validateDefaultValueShape:Rk,validateInput:eb,validateUpdateShape:q_,warn:ts},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */pU();/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jk={kernelName:wd,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>j(t,po(ge(n,"float32"),-1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UU={kernelName:$u,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const s=xt(ge(n,"float32")),r=hn(we(Re(1),s));return It(Te(t,r))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GU={kernelName:vu,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const s=hn(we(xt(ge(n,"float32")),1));return Te(t,s)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HU={kernelName:lo,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=We(n.shape,s.shape);return{a:()=>{let o=t;const u=Yt(n.shape,r);return u.length>0&&(o=Ie(o,u)),K(o,n.shape)},b:()=>{let o=t;const u=Yt(s.shape,r);return u.length>0&&(o=Ie(o,u)),K(o,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qU={kernelName:$d,saveAllInputs:!0,gradFunc:(t,e)=>{const n={};return e.forEach((s,r)=>{n[r]=()=>t.clone()}),n}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jU={kernelName:vd,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>rt(n)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KU={kernelName:Sd,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>rt(n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XU={kernelName:Su,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Te(t,hn(we(Re(1),xt(ge(n,"float32")))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YU={kernelName:Iu,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const s=hn(le(Re(1),xt(ge(n,"float32"))));return Te(t,s)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZU={kernelName:Cu,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=We(n.shape,s.shape);return{a:()=>{const o=le(xt(n),xt(s));let u=j(t,Te(s,o));const l=Yt(n.shape,r);return l.length>0&&(u=Ie(u,l)),K(u,n.shape)},b:()=>{const o=le(xt(n),xt(s));let u=It(j(t,Te(n,o)));const l=Yt(s.shape,r);return l.length>0&&(u=Ie(u,l)),K(u,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QU={kernelName:_u,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Te(t,le(xt(ge(n,"float32")),1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JU={kernelName:ku,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Te(t,we(Re(1),xt(ge(n,"float32"))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eG(t,e,n,s,r,a){const i=F(t,"dy","avgPool3dGrad"),o=F(e,"input","avgPool3dGrad");let u=i,l=o,c=!1;o.rank===4&&(c=!0,u=K(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),l=K(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),O(u.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),O(l.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${l.rank}.`),Nn("avgPool3dGrad",r,a);const d={dy:u,input:l},h={filterSize:n,strides:s,pad:r,dimRoundingMode:a},p=q.runKernel(Sg,d,h);return c?K(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const tG=U({avgPool3dGrad_:eG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nG={kernelName:_d,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{filterSize:r,strides:a,pad:i,dimRoundingMode:o}=n;return{x:()=>tG(t,s,r,a,i,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sG(t,e,n,s,r){const a=F(t,"dy","avgPoolGrad"),i=F(e,"input","avgPoolGrad");O(i.rank===a.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${a.rank})`);let o=i,u=a,l=!1;i.rank===3&&(l=!0,o=K(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=K(a,[1,a.shape[0],a.shape[1],a.shape[2]])),O(u.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`),O(o.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);const c={dy:u,input:o},d={filterSize:n,strides:s,pad:r},h=q.runKernel(vg,c,d);return l?K(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const rG=U({avgPoolGrad_:sG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aG={kernelName:Id,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{filterSize:r,strides:a,pad:i}=n;return{x:()=>rG(t,s,r,a,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iG={kernelName:kd,inputsToSave:["a","b"],gradFunc:(t,e,n)=>{const[s,r]=e,{transposeA:a,transposeB:i}=n;return!a&&!i?{a:()=>Qe(t,r,!1,!0),b:()=>Qe(s,t,!0,!1)}:!a&&i?{a:()=>Qe(t,r,!1,!1),b:()=>Qe(t,s,!0,!1)}:a&&!i?{a:()=>Qe(r,t,!1,!0),b:()=>Qe(s,t,!1,!1)}:{a:()=>Qe(r,t,!0,!0),b:()=>Qe(t,s,!0,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oG={kernelName:Cd,gradFunc:(t,e,n)=>{const{blockShape:s,crops:r}=n;return{x:()=>Oh(t,s,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uG={kernelName:_z,gradFunc:(t,e,n)=>{const s=n,r=s.inputShape,a=s.shape,i=Array.from(a);for(let u=r.length-1;u>=0;u--)if(r[u]===a[u])i[u]=1;else if(r[u]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${a}].`);const o=[];for(let u=0;u<i.length;u++)i[u]>1&&o.push(u);return{x:()=>Ie(t,o,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lG={kernelName:Tu,gradFunc:t=>({x:()=>t.clone()})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cG={kernelName:Nu,gradFunc:t=>({x:()=>rt(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dG={kernelName:Eu,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{clipValueMin:r,clipValueMax:a}=n;return{x:()=>bn(mr(wa(s,r),gi(s,a)),t,rt(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hG={kernelName:Nd,inputsToSave:["x"],gradFunc:Jk.gradFunc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pG={kernelName:Ed,saveAllInputs:!0,gradFunc:(t,e,n)=>{const s=e.map(u=>u.shape),{axis:r}=n,a=Ye(r,e[0].shape)[0],i=s.map(u=>u[a]);return Gn(t,i,a).map(u=>()=>u)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fG={kernelName:Ad,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[s,r]=e,{dilations:a,strides:i,pad:o,dataFormat:u}=n;return O(ia(a),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`),{x:()=>Ay(s.shape,t,r,i,o,u),filter:()=>ab(s,t,r.shape,i,o,u)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mG={kernelName:Rd,inputsToSave:["dy","filter"],gradFunc:(t,e,n)=>{const[s,r]=e,{strides:a,pad:i,dataFormat:o,dimRoundingMode:u}=n;return{dy:()=>oa(t,r,a,i,o,1,u),filter:()=>ab(t,s,r.shape,a,i,o,u)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gG(t,e,n,s,r){let a=t;t.rank===4&&(a=K(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]));let i=e;i.rank===4&&(i=K(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),O(a.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`),O(i.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),O(n.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),O(a.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${n[3]}.`),O(i.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`);const o={x:a,dy:i},u={strides:s,pad:r,filterShape:n};return q.runKernel(Tg,o,u)}const yG=U({conv3DBackpropFilter_:gG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bG={kernelName:Dd,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:s,strides:r,pad:a}=n;O(ia(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[i,o]=e;return{x:()=>w_(i.shape,t,o,r,a),filter:()=>yG(i,t,o.shape,r,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xG={kernelName:Au,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>j(It(Xy(ge(n,"float32"))),t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wG={kernelName:Ru,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>j(Yy(ge(n,"float32")),t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $G={kernelName:Od,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{axis:r,exclusive:a,reverse:i}=n;return{x:()=>{const o=At([r],s.rank);let u=Oy(t,r,a,!i);return o!=null&&(u=st(u,o)),u}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vG={kernelName:Fd,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:s,strides:r,pad:a,dimRoundingMode:i}=n,o=s??[1,1];O(ia(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[u,l]=e;return O(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`),O(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${l.rank}.`),O(u.shape[3]===l.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),O(pn(r,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${o}'.`),Nn("depthwiseConv2d",a,i),{x:()=>tk(u.shape,t,l,r,a,o,i),filter:()=>ek(u,t,l.shape,r,a,o,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SG={kernelName:zd,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[s,r]=e,a={x:s,filter:r,dy:t},i={x:s,filter:r,dy:t};return{x:()=>q.runKernel(im,a,n),filter:()=>q.runKernel(om,i,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IG={kernelName:Ou,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e,s={dy:t,y:n};return{x:()=>q.runKernel(Pg,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _G={kernelName:Fu,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,s=j(jn(It(xt(n))),2/Math.sqrt(Math.PI));return{x:()=>j(t,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kG={kernelName:zu,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>j(t,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CG={kernelName:Pd,inputsToSave:["input"],gradFunc:(t,e)=>{const[n]=e;return{input:()=>K(t,n.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TG={kernelName:Lu,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>j(t,jn(n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NG={kernelName:Pu,gradFunc:t=>({x:()=>rt(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EG={kernelName:Bu,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=We(n.shape,s.shape);return{a:()=>{const o=Te(t,ge(s,"float32")),u=Yt(n.shape,r);return u.length>0?K(Ie(o,u),n.shape):o},b:()=>{let o=j(t,ge(n,"float32"));const u=Yt(s.shape,r);u.length>0&&(o=K(Ie(o,u),s.shape));const l=xt(s);return It(Te(o,ge(l,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AG={kernelName:Bd,inputsToSave:["x","mean","variance","scale"],gradFunc:(t,e,n)=>{const{varianceEpsilon:s}=n,[r,a,i,o]=e,u=o??Re(1),l=Yt(a.shape,r.shape),c=[];if(a.rank===1){for(let w=0;w<r.shape.length-1;++w)c.push(r.shape[w]);c.push(1)}const d=we(r,a),h=j(t,u),p=qy(le(i,Re(s))),f=j(j(j(p,p),p),Re(-.5));return{x:()=>a.rank===1?K(j(j(t,gs(K(p,[1,1,1,a.shape[0]]),c)),u),r.shape):K(j(j(t,p),u),r.shape),mean:()=>{let w=j(j(p,Re(-1)),h);return a.rank===1&&(w=Ie(w,l)),K(w,a.shape)},variance:()=>{let w=j(j(f,d),h);return a.rank===1&&(w=Ie(w,l)),K(w,a.shape)},scale:()=>{const w=j(d,p);let v=j(t,w);return a.rank===1&&(v=Ie(v,l)),K(v,a.shape)},offset:()=>{let w=t;return a.rank===1&&(w=Ie(w,l)),K(w,a.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RG={kernelName:Md,inputsToSave:["x","indices"],gradFunc:(t,e,n)=>{const[s,r]=e,{axis:a,batchDims:i}=n,o=Ye(a,s.shape)[0],u=(l,c,d)=>()=>{const h=l.shape,p=c.size,f=h.slice(0,o),m=f.length,g=h.slice(a,h.length).slice(1),y=g.length,b=y1(0,m),$=y1(m+1,m+1+y),w=b1([f,[p],g]),v=K(d,w),k=K(c,[p]),C=b1([[m],b,$]),N=st(v,C);let A=nb(N,k,l.shape[o]);const I=xa(C);return A=st(A,I),A};if(i===1){const l=s.shape[0],c=s.split(l,0);return{x:()=>Kn(c.map((p,f)=>u(p,r.slice(f,1),t.slice(f,1))())).reshape(s.shape),indices:()=>r}}else return{x:u(s,r,t),indices:()=>r}}};function y1(t,e){const n=[];for(let s=t;s<e;++s)n.push(s);return n}function b1(t){const e=[];for(let n=0;n<t.length;++n)for(let s=0;s<t[n].length;++s)e.push(t[n][s]);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DG={kernelName:Mu,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e;return{a:()=>rt(n),b:()=>rt(s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OG={kernelName:Vu,gradFunc:t=>({x:()=>ge(t,"float32")})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FG={kernelName:Wu,gradFunc:t=>({x:()=>rt(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zG={kernelName:Uu,gradFunc:t=>({x:()=>rt(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LG={kernelName:Gu,gradFunc:t=>({x:()=>rt(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PG={kernelName:Wd,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{alpha:r}=n,a=Qn(s,0);return{x:()=>bn(a,t,j(t,r))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BG={kernelName:qu,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Te(t,le(n,1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MG={kernelName:Hu,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Te(t,ge(n,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VG={kernelName:Cz,inputsToSave:[],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s]=e,{axis:r}=n;return{logits:()=>{const i=jn(s);return we(t,j(Ie(t,r,!0),i))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WG(t,e,n,s=5,r=1,a=1,i=.5){const o={x:t,y:e,dy:n},u={depthRadius:s,bias:r,alpha:a,beta:i};return q.runKernel(qg,o,u)}const UG=U({localResponseNormalizationBackprop_:WG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GG={kernelName:Kd,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s,r]=e,{depthRadius:a,bias:i,alpha:o,beta:u}=n;return{x:()=>UG(s,r,t,a,i,o,u)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eC(t,e,n,s){return e.rank<n.rank&&(e=K(e,Lt(e.shape,s))),t.rank<n.rank&&(t=K(t,Lt(t.shape,s))),{x:()=>j(t,ge(Ks(n,e),t.dtype))}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x1={kernelName:Xd,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const s=n,{reductionIndices:r}=s,a=e[0],i=e[1],o=Ye(r,a.shape),u=eC(t,i,a,o);return{x:()=>u.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HG={kernelName:ju,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e;return{a:()=>j(t,ge(wa(n,s),"float32")),b:()=>j(t,ge(iu(n,s),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qG(t,e,n,s,r,a,i){const o=F(t,"dy","maxPool3dGrad"),u=F(e,"input","maxPool3dGrad"),l=F(n,"output","maxPool3dGrad");let c=o,d=u,h=l,p=!1;u.rank===4&&(p=!0,c=K(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),d=K(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),h=K(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),O(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),O(d.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),O(h.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${h.rank}.`),Nn("maxPool3dGrad",a,i);const f={dy:c,input:d,output:h},m={filterSize:s,strides:r,pad:a,dimRoundingMode:i},g=q.runKernel(Kg,f,m);return p?K(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}const jG=U({maxPool3dGrad_:qG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KG={kernelName:Zd,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s,r]=e,{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=n;return{x:()=>jG(t,s,r,a,i,o,u)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XG(t,e,n,s,r,a,i){const o=F(t,"dy","maxPoolGrad"),u=F(e,"input","maxPoolGrad"),l=F(n,"output","maxPoolGrad");O(u.rank===o.rank,()=>`Rank of input (${u.rank}) does not match rank of dy (${o.rank})`),O(o.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),O(u.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`),Nn("maxPoolGrad",a,i);const c={dy:o,input:u,output:l},d={filterSize:s,strides:r,pad:a,dimRoundingMode:i};return q.runKernel(jg,c,d)}const YG=U({maxPoolGrad_:XG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZG={kernelName:Yd,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s,r]=e,{filterSize:a,strides:i,pad:o}=n;return{x:()=>YG(t,s,r,a,i,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QG={kernelName:Qd,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{axis:r}=n,a=Ye(r,s.shape),o=an(s.shape,a)[1],u=se(o);return{x:()=>{const c=s.shape.slice();a.forEach(p=>{c[p]=1});const d=K(t,c);return Te(j(d,Un(s.shape,"float32")),u)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JG={kernelName:Jd,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const s=n,{axis:r}=s,[a,i]=e,o=Ye(r,a.shape),u=eC(t,i,a,o);return{x:()=>u.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eH={kernelName:Ku,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e;return{a:()=>j(t,ge(gi(n,s),"float32")),b:()=>j(t,ge(Qn(n,s),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tH={kernelName:eh,inputsToSave:["x"],gradFunc:(t,e,n)=>{const s=e[0],{paddings:r}=n,a=r.map(i=>i[0]);return{x:()=>nt(t,a,s.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nH={kernelName:Xu,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=We(n.shape,s.shape);return{a:()=>{const o=Yt(n.shape,r);return o.length>0?K(Ie(t,o),n.shape):t},b:()=>{const o=j(t,It(vl(Te(n,s)))),u=Yt(s.shape,r);return u.length>0?K(Ie(o,u),s.shape):o}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sH={kernelName:Yu,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=We(n.shape,s.shape);return{a:()=>{const o=j(t,ge(s,"float32")),u=Yt(n.shape,r);return u.length>0?K(Ie(o,u),n.shape):o},b:()=>{const o=j(t,ge(n,"float32")),u=Yt(s.shape,r);return u.length>0?K(Ie(o,u),s.shape):o}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rH={kernelName:th,gradFunc:t=>({x:()=>It(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aH={kernelName:rh,inputsToSave:["indices"],gradFunc:(t,e)=>{const n=e[0];return{indices:()=>Gt(n.shape,"float32")}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iH={kernelName:sh,gradFunc:t=>({x:()=>rt(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oH={kernelName:ah,saveAllInputs:!0,gradFunc:(t,e,n)=>{const{axis:s}=n;return Is(t,s).map(a=>()=>a)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w1={kernelName:ih,inputsToSave:["x"],gradFunc:(t,e,n)=>{const s=e[0],{paddings:r}=n,a=r.map(i=>i[0]);return{x:()=>nt(t,a,s.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uH={kernelName:Zu,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(t,e)=>{const[n,s,r]=e,a=n,i=s,o=We(a.shape,i.shape);return{a:()=>{const c=ge(i,"float32");let d=j(t,j(c,Er(a,we(c,Re(1)))));const h=Yt(a.shape,o);return h.length>0&&(d=Ie(d,h)),K(d,a.shape)},b:()=>{const c=Qn(a,0),d=bn(c,rs(a),rt(a));let h=j(t,j(r,d));const p=Yt(i.shape,o);return p.length>0&&(h=Ie(h,p)),K(h,i.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lH={kernelName:oh,inputsToSave:["x","alpha"],gradFunc:(t,e)=>{const[n,s]=e,r=Qn(n,0);return{x:()=>bn(r,t,j(t,s)),alpha:()=>{let a=bn(r,rt(t),j(t,n));const i=Yt(s.shape,t.shape);return i.length>0&&(a=Ie(a,i)),K(a,s.shape)}}}};/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cH(t,e,n){const s=t.shape.slice();s[n]=1;const r=K(e,s),a=Hc(t,n,!0,!1),i=Hc(t,n,!0,!0),o=j(a,i);return j(r,o)}function dH(t,e,n){const s=t.shape.length,r=s-n.length,a=At(n,s);let i=t;a!=null&&(i=st(t,a));const o=i.shape.slice(),l=o.splice(s-n.length,n.length).reduce((h,p)=>h*p,1);o.push(l);const c=i.reshape(o);let d=cH(c,e,r);if(d=d.reshape(i.shape),a!=null){const h=xa(a);d=st(d,h)}return d}const hH={kernelName:uh,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{axis:r}=n;let a=[];return r==null?a=s.shape.map((i,o)=>o):typeof r=="number"?a=[r]:a=r,{x:()=>dH(s,t,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pH={kernelName:Du,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=We(n.shape,s.shape);return{a:()=>{const o=Te(t,ge(s,"float32")),u=Yt(n.shape,r);return u.length>0?K(Ie(o,u),n.shape):o},b:()=>{let o=j(t,ge(n,"float32"));const u=Yt(s.shape,r);u.length>0&&(o=K(Ie(o,u),s.shape));const l=xt(s);return It(Te(o,ge(l,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fH={kernelName:Qu,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Te(t,It(xt(n)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mH={kernelName:el,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,s=j(gi(n,6),po(n));return{x:()=>j(t,ge(s,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gH={kernelName:Ju,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>j(t,ge(po(n),"float32"))}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yH={kernelName:lh,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>K(t,n.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bH={kernelName:dh,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[s]=e,r={dy:t,images:s};return{images:()=>q.runKernel(iy,r,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xH={kernelName:ch,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[s]=e,r={dy:t,images:s};return{images:()=>q.runKernel(ay,r,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wH={kernelName:hh,gradFunc:(t,e,n)=>{const{dims:s}=n,r=Ye(s,t.shape);return{x:()=>Ss(t,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $H={kernelName:tl,gradFunc:t=>({x:()=>rt(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vH={kernelName:nl,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>It(Te(t,j(Er(n,1.5),2)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SH={kernelName:ph,inputsToSave:["condition"],gradFunc:(t,e)=>{const[n]=e;return{condition:()=>ge(rt(n),"float32"),t:()=>j(t,ge(n,t.dtype)),e:()=>j(t,ge(Ah(n),t.dtype))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IH={kernelName:sl,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const s=Qn(n,Re(0)),r=Re(Kh),a=Re(Xh),i=j(t,a),o=j(j(t,r),jn(ge(n,"float32")));return bn(s,i,o)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _H={kernelName:ol,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>j(t,j(n,we(Re(1),n)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kH={kernelName:il,gradFunc:t=>({x:()=>rt(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CH={kernelName:rl,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>j(kh(ge(n,"float32")),t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TH={kernelName:al,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>j(Dy(ge(n,"float32")),t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NH={kernelName:fh,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{begin:r,size:a}=n,i=s.shape,[o,u]=qh(s,r,a),l=[];for(let c=0;c<t.rank;c++)l.push([o[c],i[c]-o[c]-u[c]]);return{x:()=>$a(t,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EH={kernelName:bh,outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s]=e,{dim:r}=n,a=!0,i=j(t,s);return{logits:()=>we(i,j(Ie(i,[r],a),s))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AH={kernelName:ul,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>j(t,dr(n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $1={kernelName:gh,gradFunc:(t,e,n)=>{const{blockShape:s,paddings:r}=n;return{x:()=>_h(t,s,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v1={kernelName:yh,gradFunc:(t,e,n)=>{const{axis:s}=n;return{x:()=>Wt(t,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RH={kernelName:ll,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Te(t,j(hn(ge(n,"float32")),2))}}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DH={kernelName:my,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>j(t,j(ge(n,"float32"),2))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OH={kernelName:cl,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=Re(2);return{a:()=>j(t,j(r,we(n,s))),b:()=>j(t,j(r,we(s,n)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FH={kernelName:ml,gradFunc:t=>({x:()=>rt(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zH={kernelName:dl,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=We(n.shape,s.shape);return{a:()=>{let o=t;const u=Yt(n.shape,r);return u.length>0&&(o=Ie(o,u)),K(o,n.shape)},b:()=>{let o=t;const u=Yt(s.shape,r);return u.length>0&&(o=Ie(o,u)),K(It(o),s.shape)}}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LH={kernelName:mh,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,r=s.shape.slice(),{axis:a}=n;Ye(a,s.shape).forEach(l=>{r[l]=1});const o=K(t,r),u=j(o,Un(s.shape,"float32"));return{x:()=>u}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PH={kernelName:hl,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Te(t,xt(kh(n)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BH={kernelName:pl,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>j(we(Re(1),xt(n)),t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MH={kernelName:fl,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{reps:r}=n;return{x:()=>{let i=rt(s);if(s.rank===1)for(let o=0;o<r[0];++o)i=le(i,nt(t,[o*s.shape[0]],[s.shape[0]]));else if(s.rank===2)for(let o=0;o<r[0];++o)for(let u=0;u<r[1];++u)i=le(i,nt(t,[o*s.shape[0],u*s.shape[1]],[s.shape[0],s.shape[1]]));else if(s.rank===3)for(let o=0;o<r[0];++o)for(let u=0;u<r[1];++u)for(let l=0;l<r[2];++l)i=le(i,nt(t,[o*s.shape[0],u*s.shape[1],l*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else if(s.rank===4)for(let o=0;o<r[0];++o)for(let u=0;u<r[1];++u)for(let l=0;l<r[2];++l)for(let c=0;c<r[3];++c)i=le(i,nt(t,[o*s.shape[0],u*s.shape[1],l*s.shape[2],c*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);return i}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VH={kernelName:Mi,gradFunc:(t,e,n)=>{const s=n,{perm:r}=s,a=xa(r);return{x:()=>st(t,a)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WH={kernelName:wh,gradFunc:(t,e,n)=>{const s=n,{axis:r}=s;return{value:()=>Kn(t,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UH={kernelName:$h,inputsToSave:["segmentIds"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>GH(t,n)}}};function GH(t,e){const n=zr(e,rt(e)),s=Sl(t,n);let r=wa(e,Re(0,"int32"));const a=s.rank-r.rank;for(let o=0;o<a;++o)r=_n(r,o+1);r=mr(r,Un(s.shape,"bool"));const i=rt(s);return bn(r,s,i)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HH={kernelName:vh,gradFunc:t=>({x:()=>rt(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qH=[Jk,UU,GU,HU,qU,jU,KU,XU,YU,ZU,QU,JU,nG,aG,iG,oG,uG,lG,cG,dG,hG,pG,mG,fG,bG,xG,wG,$G,vG,SG,pH,IG,_G,kG,CG,TG,EG,NG,AG,RG,DG,OG,FG,zG,LG,PG,BG,MG,VG,GG,x1,x1,HG,KG,ZG,QG,JG,eH,tH,nH,sH,rH,aH,iH,oH,w1,w1,uH,lH,hH,fH,mH,gH,yH,bH,xH,wH,$H,vH,SH,IH,_H,kH,CH,TH,NH,EH,AH,$1,$1,v1,v1,RH,OH,DH,FH,zH,LH,PH,BH,MH,VH,WH,UH,HH];for(const t of qH)Nz(t);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.abs=function(){return this.throwIfDisposed(),Ut(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.acos=function(){return this.throwIfDisposed(),t_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.acosh=function(){return this.throwIfDisposed(),n_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.add=function(t){return this.throwIfDisposed(),le(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.all=function(t,e){return this.throwIfDisposed(),Ty(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.any=function(t,e){return this.throwIfDisposed(),Gc(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.argMax=function(t){return this.throwIfDisposed(),Ki(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.argMin=function(t){return this.throwIfDisposed(),s_(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.asScalar=function(){return this.throwIfDisposed(),O(this.size===1,()=>"The array must have only 1 element."),K(this,[])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.asType=function(t){return this.throwIfDisposed(),ge(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.as1D=function(){return this.throwIfDisposed(),K(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.as2D=function(t,e){return this.throwIfDisposed(),K(this,[t,e])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.as3D=function(t,e,n){return this.throwIfDisposed(),K(this,[t,e,n])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.as4D=function(t,e,n,s){return this.throwIfDisposed(),K(this,[t,e,n,s])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.as5D=function(t,e,n,s,r){return this.throwIfDisposed(),K(this,[t,e,n,s,r])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.asin=function(){return this.throwIfDisposed(),r_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.asinh=function(){return this.throwIfDisposed(),a_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.atan=function(){return this.throwIfDisposed(),i_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.atan2=function(t){return this.throwIfDisposed(),o_(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.atanh=function(){return this.throwIfDisposed(),u_(this)};ae().prototype.avgPool=function(t,e,n,s){return this.throwIfDisposed(),Ih(this,t,e,n,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.batchToSpaceND=function(t,e){return this.throwIfDisposed(),_h(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.batchNorm=function(t,e,n,s,r){return this.throwIfDisposed(),bl(this,t,e,n,s,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.broadcastTo=function(t){return this.throwIfDisposed(),Ui(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.cast=function(t){return this.throwIfDisposed(),ge(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.ceil=function(){return this.throwIfDisposed(),f_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.clipByValue=function(t,e){return this.throwIfDisposed(),qn(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.concat=function(t,e){return this.throwIfDisposed(),t instanceof _t&&(t=[t]),Wt([this,...t],e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.conv1d=function(t,e,n,s,r,a){return this.throwIfDisposed(),Ey(this,t,e,n,s,r,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.conv2dTranspose=function(t,e,n,s,r){return this.throwIfDisposed(),Ry(this,t,e,n,s,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.conv2d=function(t,e,n,s,r,a){return this.throwIfDisposed(),oa(this,t,e,n,s,r,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.cos=function(){return this.throwIfDisposed(),kh(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.cosh=function(){return this.throwIfDisposed(),Dy(this)};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.cumprod=function(t,e,n){return this.throwIfDisposed(),Hc(this,t,e,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.cumsum=function(t,e,n){return this.throwIfDisposed(),Oy(this,t,e,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.depthToSpace=function(t,e){return this.throwIfDisposed(),v_(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.depthwiseConv2d=function(t,e,n,s,r,a){return this.throwIfDisposed(),xl(this,t,e,n,s,r,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.dilation2d=function(t,e,n,s,r){return this.throwIfDisposed(),S_(this,t,e,n,s,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.divNoNan=function(t){return this.throwIfDisposed(),I_(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.div=function(t){return this.throwIfDisposed(),Te(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.dot=function(t){return this.throwIfDisposed(),__(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.elu=function(){return this.throwIfDisposed(),wl(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.equal=function(t){return this.throwIfDisposed(),Ks(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.erf=function(){return this.throwIfDisposed(),Fy(this)};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.euclideanNorm=function(t,e){return this.throwIfDisposed(),T_(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.exp=function(){return this.throwIfDisposed(),jn(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.expandDims=function(t){return this.throwIfDisposed(),_n(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.expm1=function(){return this.throwIfDisposed(),N_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.fft=function(){return this.throwIfDisposed(),Mh(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.flatten=function(){return this.throwIfDisposed(),K(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.floor=function(){return this.throwIfDisposed(),vl(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.floorDiv=function(t){return this.throwIfDisposed(),Cy(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.gather=function(t,e,n){return this.throwIfDisposed(),Sl(this,t,e,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.greaterEqual=function(t){return this.throwIfDisposed(),wa(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.greater=function(t){return this.throwIfDisposed(),Qn(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.ifft=function(){return this.throwIfDisposed(),lu(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.irfft=function(){return this.throwIfDisposed(),Qy(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.isFinite=function(){return this.throwIfDisposed(),E_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.isInf=function(){return this.throwIfDisposed(),A_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.isNaN=function(){return this.throwIfDisposed(),R_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.leakyRelu=function(t){return this.throwIfDisposed(),Th(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.lessEqual=function(t){return this.throwIfDisposed(),gi(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.less=function(t){return this.throwIfDisposed(),iu(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.localResponseNormalization=function(t,e,n,s){return this.throwIfDisposed(),D_(this,t,e,n,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.logSigmoid=function(){return this.throwIfDisposed(),O_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.logSoftmax=function(t){return this.throwIfDisposed(),Py(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.logSumExp=function(t,e){return this.throwIfDisposed(),Eh(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.log=function(){return this.throwIfDisposed(),rs(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.log1p=function(){return this.throwIfDisposed(),Nh(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.logicalAnd=function(t){return this.throwIfDisposed(),mr(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.logicalNot=function(){return this.throwIfDisposed(),Ah(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.logicalOr=function(t){return this.throwIfDisposed(),By(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.logicalXor=function(t){return this.throwIfDisposed(),F_(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.matMul=function(t,e,n){return this.throwIfDisposed(),Qe(this,t,e,n)};ae().prototype.maxPool=function(t,e,n,s){return this.throwIfDisposed(),Rh(this,t,e,n,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.max=function(t,e){return this.throwIfDisposed(),$s(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.maximum=function(t){return this.throwIfDisposed(),zr(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.mean=function(t,e){return this.throwIfDisposed(),Rt(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.min=function(t,e){return this.throwIfDisposed(),au(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.minimum=function(t){return this.throwIfDisposed(),ai(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.mirrorPad=function(t,e){return this.throwIfDisposed(),L_(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.mod=function(t){return this.throwIfDisposed(),P_(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.mul=function(t){return this.throwIfDisposed(),j(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.neg=function(){return this.throwIfDisposed(),It(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.norm=function(t,e,n){return this.throwIfDisposed(),$l(this,t,e,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.notEqual=function(t){return this.throwIfDisposed(),Yi(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.oneHot=function(t,e=1,n=0){return this.throwIfDisposed(),Vy(this,t,e,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.onesLike=function(){return this.throwIfDisposed(),as(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.pad=function(t,e){return this.throwIfDisposed(),$a(this,t,e)};ae().prototype.pool=function(t,e,n,s,r,a){return this.throwIfDisposed(),B_(this,t,e,n,s,r,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.pow=function(t){return this.throwIfDisposed(),Er(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.prelu=function(t){return this.throwIfDisposed(),Fh(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.prod=function(t,e){return this.throwIfDisposed(),M_(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.reciprocal=function(){return this.throwIfDisposed(),V_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.relu=function(){return this.throwIfDisposed(),xr(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.relu6=function(){return this.throwIfDisposed(),Gy(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.reshapeAs=function(t){return this.throwIfDisposed(),K(this,t.shape)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.reshape=function(t){return this.throwIfDisposed(),K(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.resizeBilinear=function(t,e,n){return this.throwIfDisposed(),rk(this,t,e,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.resizeNearestNeighbor=function(t,e,n){return this.throwIfDisposed(),ak(this,t,e,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.reverse=function(t){return this.throwIfDisposed(),Ss(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.rfft=function(){return this.throwIfDisposed(),Vh(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.round=function(){return this.throwIfDisposed(),Hy(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.rsqrt=function(){return this.throwIfDisposed(),qy(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.selu=function(){return this.throwIfDisposed(),jy(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.separableConv2d=function(t,e,n,s,r,a){return this.throwIfDisposed(),Ky(this,t,e,n,s,r,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.sigmoid=function(){return this.throwIfDisposed(),dr(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.sign=function(){return this.throwIfDisposed(),W_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.sin=function(){return this.throwIfDisposed(),Xy(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.sinh=function(){return this.throwIfDisposed(),Yy(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.slice=function(t,e){return this.throwIfDisposed(),nt(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.softmax=function(t){return this.throwIfDisposed(),Bh(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.softplus=function(){return this.throwIfDisposed(),ho(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.spaceToBatchND=function(t,e){return this.throwIfDisposed(),Oh(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.split=function(t,e){return this.throwIfDisposed(),Gn(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.sqrt=function(){return this.throwIfDisposed(),hn(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.square=function(){return this.throwIfDisposed(),xt(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.squaredDifference=function(t){return this.throwIfDisposed(),Jy(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.squeeze=function(t){return this.throwIfDisposed(),bi(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.stack=function(t,e){this.throwIfDisposed();const n=t instanceof _t?[this,t]:[this,...t];return Kn(n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.step=function(t){return this.throwIfDisposed(),po(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.stridedSlice=function(t,e,n,s,r,a,i,o){return this.throwIfDisposed(),U_(this,t,e,n,s,r,a,i,o)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.sub=function(t){return this.throwIfDisposed(),we(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.sum=function(t,e){return this.throwIfDisposed(),Ie(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.tan=function(){return this.throwIfDisposed(),G_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.tanh=function(){return this.throwIfDisposed(),ri(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.tile=function(t){return this.throwIfDisposed(),gs(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.toBool=function(){return this.throwIfDisposed(),ge(this,"bool")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.toFloat=function(){return this.throwIfDisposed(),ge(this,"float32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.toInt=function(){return this.throwIfDisposed(),ge(this,"int32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.topk=function(t,e){return this.throwIfDisposed(),j_(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.transpose=function(t){return this.throwIfDisposed(),st(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.unique=function(t){return this.throwIfDisposed(),K_(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.unsortedSegmentSum=function(t,e){return this.throwIfDisposed(),nb(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.unstack=function(t){return this.throwIfDisposed(),Is(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.where=function(t,e){return this.throwIfDisposed(),bn(t,this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ae().prototype.zerosLike=function(){return this.throwIfDisposed(),rt(this)};/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class ir extends Error{constructor(e){super(e),Object.setPrototypeOf(this,ir.prototype)}}class bs extends Error{constructor(e){super(e),Object.setPrototypeOf(this,bs.prototype)}}class X extends Error{constructor(e){super(e),Object.setPrototypeOf(this,X.prototype)}}class He extends Error{constructor(e){super(e),Object.setPrototypeOf(this,He.prototype)}}class Pb extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Pb.prototype)}}/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class tC{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let n;return this.cache.has(e)&&(n=this.cache.get(e),this.cache.delete(e),this.cache.set(e,n)),n}put(e,n){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const s=this.cache.keys().next().value;this.cache.delete(s)}this.cache.set(e,n)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let n=0;n<this.maxEntries-e;n++){const s=this.cache.keys().next().value;this.cache.delete(s)}this.maxEntries=e}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function oi(t,e){if(Array.isArray(t)){let n=[];for(let s=0;s<e;s++)n=n.concat(t);return n}else{const n=new Array(e);return n.fill(t),n}}function or(t,e){if(!t)throw new Pb(e)}function S1(t,e){let n=0;for(const s of t)s===e&&n++;return n}function Dn(t){return t.length===1?t[0]:t}function ht(t){return Array.isArray(t)?t:[t]}function Sr(t){const n=t.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return n[0]!=="_"?n:"private"+n}function Ba(t){return t.length<=1||t.indexOf("_")===-1?t:t.replace(/[_]+(\w|$)/g,(e,n)=>n.toUpperCase())}let ds={};function Bb(t){if(t==null)return null;const e={};return e.className=t.getClassName(),e.config=t.getConfig(),e}function Cm(t){if(!(t==null||typeof t!="object"))if(Array.isArray(t))t.forEach(e=>Cm(e));else{const e=Object.keys(t);for(const n of e){const s=t[n];s!=null&&typeof s=="object"&&(!Array.isArray(s)&&s.type==="ndarray"&&typeof s.value=="number"?t[n]=s.value:Cm(s))}}}function Cl(t,e={},n={},s="object",r=!1){if(typeof t=="string"){const a=t;let i;if(a in n)i=n[a];else if(a in ds)i=ds[a];else if(i=e[a],i==null)throw new X(`Unknown ${s}: ${t}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}else{const a=t;if(a.className==null||a.config==null)throw new X(`${s}: Improper config format: ${JSON.stringify(a)}.
'className' and 'config' must set.`);const i=a.className;let o,u;if(i in n?[o,u]=n[i]:i in ds?[o,u]=ds.className:i in e&&([o,u]=e[i]),o==null)throw new X(`Unknown ${s}: ${i}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(u!=null){const l={};for(const p of Object.keys(ds))l[p]=ds[p];for(const p of Object.keys(n))l[p]=n[p];const c=a.config;c.customObjects=l;const d=Object.assign({},ds);for(const p of Object.keys(n))ds[p]=n[p];Cm(a.config);const h=u(o,a.config,n,r);return ds=Object.assign({},d),h}else{const l=Object.assign({},ds);for(const d of Object.keys(n))ds[d]=n[d];const c=new o(a.config);return ds=Object.assign({},l),c}}}function jH(t,e){return t<e?-1:t>e?1:0}function Ql(t,e){return-1*jH(t,e)}function ta(t){if(t==null)return t;const e=[];for(const n of t)e.indexOf(n)===-1&&e.push(n);return e}function KH(t){if(t==null)throw new X(`Invalid value in obj: ${JSON.stringify(t)}`);for(const e in t)if(t.hasOwnProperty(e))return!1;return!0}function wi(t,e,n){if(n!=null&&t.indexOf(n)<0)throw new X(`${n} is not a valid ${e}.  Valid values are ${t} or null/undefined.`)}function Mb(t,e,n=0,s=1/0){return or(n>=0),or(s>=n),Array.isArray(t)&&t.length>=n&&t.length<=s&&t.every(r=>typeof r===e)}function nn(t,e){Array.isArray(t)?(O(t.length>0,()=>`${e} is unexpectedly an empty array.`),t.forEach((n,s)=>nn(n,`element ${s+1} of ${e}`))):O(Number.isInteger(t)&&t>0,()=>`Expected ${e} to be a positive integer, but got ${nC(t)}.`)}function nC(t){return t===null?"null":Array.isArray(t)?"["+t.map(e=>nC(e)).join(",")+"]":typeof t=="string"?`"${t}"`:`${t}`}function XH(t,e,n){let s=n!=null?n():Rn(),r;return(...i)=>{const o=n!=null?n():Rn();return o-s<e||(s=o,r=t(...i)),r}}function sC(t){return t==="relu"?"relu":t==="linear"?"linear":t==="elu"?"elu":null}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let YH=0;function rC(){return YH++}const Jl={};function Yh(t=""){return t in Jl||(Jl[t]=0),Jl[t]+=1,t+Jl[t].toString()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const ZH=["channelsFirst","channelsLast"],QH=["nearest","bilinear"],JH=["valid","same","causal"],eq=["max","avg"],tq=["sum","mul","concat","ave"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Ei=new Map;function Bt(t){wi(ZH,"DataFormat",t)}function nq(t){wi(QH,"InterpolationFormat",t)}function os(t){wi(JH,"PaddingMode",t)}function aC(t){wi(eq,"PoolMode",t)}const tu=[],I1="/";function ja(t,e){tu.push(t);try{const n=e();return tu.pop(),n}catch(n){throw tu.pop(),n}}function sq(){return tu.length===0?"":tu.join(I1)+I1}function iC(t){if(!uC(t))throw new Error("Not a valid tensor name: '"+t+"'");return sq()+t}function oC(t){if(!uC(t))throw new Error("Not a valid tensor name: '"+t+"'");Ei.has(t)||Ei.set(t,0);const e=Ei.get(t);if(Ei.set(t,Ei.get(t)+1),e>0){const n=`${t}_${e}`;return Ei.set(n,1),n}else return t}const rq=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function uC(t){return!!t.match(rq)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function aq(t){return t===parseInt(t.toString(),10)}function na(t,e,n){e==null&&(e=0),n==null&&(n=t.length);let s=1;for(let r=e;r<n;++r)s*=t[r];return s}function Qi(t){if(t.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let n=0;n<t.length;n++){const s=t[n];s<e&&(e=s)}return e}function ua(t){if(t.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let n=0;n<t.length;n++){const s=t[n];s>e&&(e=s)}return e}function Xs(t,e){if(e<t)throw new X(`end (${e}) < begin (${t}) is forbidden.`);const n=[];for(let s=t;s<e;++s)n.push(s);return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let qp;function Ht(){return qp==null&&(qp=BI().epsilon()),qp}function Ys(){return"channelsLast"}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function pr(t,e){return ge(t,e)}function Tl(t,e=-1){const n=t.shape.slice();return e<0&&(e=n.length+e+1),n.splice(e,0,1),K(t,n)}function iq(t,e){return ee(()=>{if(t.shape.length!==2)throw new X(`repeat() expects a rank-2 tensor, but received a rank-${t.shape.length} tensor.`);const n=Tl(t,1);return Tm(n,[1,e,1])})}function oq(t){const e=[na(t.shape)];return K(t,e)}function uq(t){if(t.rank<=1)throw new X(`batchFlatten requires a minimum rank of 2. Got rank: ${t.rank}.`);const e=[t.shape[0],na(t.shape,1)];return K(t,e)}function Ka(t,e,n){return ee(()=>{switch(t.rank){case 1:return Lh(t,e,n);case 2:return Zy(t,[e,0],[n,t.shape[1]]);case 3:return Ph(t,[e,0,0],[n,t.shape[1],t.shape[2]]);case 4:return uu(t,[e,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3]]);case 5:return nt(t,[e,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4]]);case 6:return nt(t,[e,0,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4],t.shape[5]]);default:throw new X(`sliceAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}})}function jp(t,e,n){return ee(()=>{switch(t.rank){case 1:return Lh(t,e,n);case 2:return Zy(t,[0,e],[t.shape[0],n]);case 3:return Ph(t,[0,0,e],[t.shape[0],t.shape[1],n]);case 4:return uu(t,[0,0,0,e],[t.shape[0],t.shape[1],t.shape[2],n]);default:throw new X(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function ec(t,e,n,s){return ee(()=>{switch(t.rank){case 1:return Lh(t,e,n);case 2:switch(s){case 1:return Ka(t,e,n);case 2:return jp(t,e,n);default:throw new X(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return Ka(t,e,n);case 2:return Ph(t,[0,e,0],[t.shape[0],n,t.shape[2]]);case 3:return jp(t,e,n);default:throw new X(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return Ka(t,e,n);case 2:return uu(t,[0,e,0,0],[t.shape[0],n,t.shape[2],t.shape[3]]);case 3:return uu(t,[0,0,e,0],[t.shape[0],t.shape[1],n,t.shape[3]]);case 4:return jp(t,e,n);default:throw new X(`The axis is not within the rank of the tensor ${s}`)}default:throw new X(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function Vb(t,e=-1){let n;return e<0&&(n=t[0].rank,n!==0?e=n:e=0),e===t[0].rank&&(e=-1),Wt(t,e)}function _1(t,e){switch(t.rank){case 1:return m_([t,e]);case 2:return g_([t,e],0);case 3:return y_([t,e],0);case 4:return b_([t,e],0);default:throw new X(`concatAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}}function Tm(t,e){if(Array.isArray(e)||(e=[e]),t.rank!==e.length)throw new X(`The length of input n (${e.length}) does not match the number of dimensions in input x (${t.rank})`);return gs(t,e)}function Zh(t,e=0,n=1,s,r){return Uy(t,e,n,s,r)}function fr(t,e,n,s){if(t.rank<2||e.rank<2)throw new He(`dot requires both inputs to be rank >= 2 but got x shape = ${t.shape} and y shape = ${e.shape}`);if(e.rank>=3){const r=t.shape.slice(-1)[0],a=e.shape.slice(-2)[0];if(r!==a)throw new He(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${t.shape} and  y shape = ${e.shape}`)}if(t.rank===2&&e.rank===2)return Sm({a:t,b:e,transposeA:!1,transposeB:!1,bias:s?Nm(t.rank,s,Ys()):null,activation:n});{const r=t.shape.slice(),a=r.pop();t=K(t,[-1,a]);const i=e.shape.slice(),o=i.pop(),u=i.pop(),l=[...i,o],c=Array.from({length:e.rank},(f,m)=>m===0?e.rank-2:m<=e.rank-2?m-1:m);e=K(st(e,c),[u,-1]);const d=[...r,...l];return K(Sm({a:t,b:e,transposeA:!1,transposeB:!1,bias:s?Nm(t.rank,s,Ys()):null,activation:n}),d)}}function lC(t,e,n){return ee(()=>(Array.isArray(e)?e=Cn(e,"int32"):e=ge(e,"int32"),Sl(t,e,n)))}function Nl(t){return j(t,t)}function Nm(t,e,n){const s=e.shape;if(e.rank!==1&&e.rank!==t)throw new X(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${t}`);if(t===5){if(n==="channelsFirst")return s.length===1?K(e,[1,s[0],1,1,1]):K(e,[1,s[3],s[0],s[1],s[2]]);if(n==="channelsLast")return s.length===1?K(e,[1,1,1,1,s[0]]):K(e,[1].concat(s))}else if(t===4){if(n==="channelsFirst")return s.length===1?K(e,[1,s[0],1,1]):K(e,[1,s[2],s[0],s[1]]);if(n==="channelsLast")return s.length===1?K(e,[1,1,1,s[0]]):K(e,[1].concat(s))}else if(t===3){if(n==="channelsFirst")return s.length===1?K(e,[1,s[0],1]):K(e,[1,s[1],s[0]]);if(n==="channelsLast")return s.length===1?K(e,[1,1,s[0]]):K(e,[1].concat(s))}else if(t<3)return e;throw new X(`Unsupported input rank by biasAdd: ${e.rank}`)}function Js(t,e,n){return ee(()=>(n==null&&(n=Ys()),Bt(n),le(t,Nm(t.rank,e,n))))}function lq(t,e=1){if(e!==1)throw new He(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return wl(t)}function cq(t){return ee(()=>Te(t,le(Ut(t),1)))}function cC(t,e,n,s){return ee(()=>Z_(t,e,n,s))}function dq(t){return ee(()=>{const e=le(.5,j(.2,t));return qn(e,0,1)})}function El(t,e,n=!1){return n?t():e()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const hq=["fanIn","fanOut","fanAvg"],pq=["normal","uniform","truncatedNormal"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function fq(t){wi(hq,"FanMode",t)}function mq(t){wi(pq,"Distribution",t)}class ks extends mo{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class dC extends ks{apply(e,n){return Gt(e,n)}}dC.className="Zeros";ce(dC);class Wb extends ks{apply(e,n){return Un(e,n)}}Wb.className="Ones";ce(Wb);class hC extends ks{constructor(e){if(super(),typeof e!="object")throw new X(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new X(`config must have value set but got ${e}`);this.value=e.value}apply(e,n){return ee(()=>j(Re(this.value),Un(e,n)))}getConfig(){return{value:this.value}}}hC.className="Constant";ce(hC);class pC extends ks{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,n){return yi(e,this.minval,this.maxval,n,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}pC.className="RandomUniform";ce(pC);class fC extends ks{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,n){if(n=n||"float32",n!=="float32"&&n!=="int32")throw new He(`randomNormal does not support dType ${n}.`);return Zh(e,this.mean,this.stddev,n,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}fC.className="RandomNormal";ce(fC);class mC extends ks{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,n){if(n=n||"float32",n!=="float32"&&n!=="int32")throw new He(`truncatedNormal does not support dType ${n}.`);return tb(e,this.mean,this.stddev,n,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}mC.className="TruncatedNormal";ce(mC);class gC extends ks{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,n){return ee(()=>{if(e.length!==2||e[0]!==e[1])throw new X("Identity matrix initializer can only be used for 2D square matrices.");return j(this.gain,Ly(e[0]))})}getConfig(){return{gain:this.gain}}}gC.className="Identity";ce(gC);function gq(t,e="channelsLast"){let n,s;if(Bt(e),t.length===2)n=t[0],s=t[1];else if([3,4,5].indexOf(t.length)!==-1){if(e==="channelsFirst"){const r=na(t,2);n=t[1]*r,s=t[0]*r}else if(e==="channelsLast"){const r=na(t,0,t.length-2);n=t[t.length-2]*r,s=t[t.length-1]*r}}else{const r=na(t);n=Math.sqrt(r),s=Math.sqrt(r)}return[n,s]}class Xn extends ks{constructor(e){if(super(),e.scale<0)throw new X(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,fq(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,mq(this.distribution),this.seed=e.seed}apply(e,n){const s=gq(e),r=s[0],a=s[1];let i=this.scale;if(this.mode==="fanIn"?i/=Math.max(1,r):this.mode==="fanOut"?i/=Math.max(1,a):i/=Math.max(1,(r+a)/2),this.distribution==="normal"){const o=Math.sqrt(i);if(n=n||"float32",n!=="float32"&&n!=="int32")throw new He(`${this.getClassName()} does not support dType ${n}.`);return tb(e,0,o,n,this.seed)}else{const o=Math.sqrt(3*i);return yi(e,-o,o,n,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Xn.className="VarianceScaling";ce(Xn);class Ub extends Xn{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Xn.className}}Ub.className="GlorotUniform";ce(Ub);class Gb extends Xn{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Xn.className}}Gb.className="GlorotNormal";ce(Gb);class Hb extends Xn{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Xn.className}}Hb.className="HeNormal";ce(Hb);class qb extends Xn{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Xn.className}}qb.className="HeUniform";ce(qb);class jb extends Xn{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Xn.className}}jb.className="LeCunNormal";ce(jb);class Kb extends Xn{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Xn.className}}Kb.className="LeCunUniform";ce(Kb);class yC extends ks{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,n){return ee(()=>{if(e.length<2)throw new He("Shape must be at least 2D.");if(n!=="int32"&&n!=="float32"&&n!==void 0)throw new TypeError(`Unsupported data type ${n}.`);n=n;const s=se(e.slice(0,-1)),r=e[e.length-1],a=s*r;a>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${a}) elements: Slowness may result.`);const i=[Math.max(r,s),Math.min(r,s)],o=Zh(i,0,1,n,this.seed),u=ik.qr(o,!1);let l=u[0];const d=u[1].flatten().stridedSlice([0],[Math.min(r,s)*Math.min(r,s)],[Math.min(r,s)+1]);return l=j(l,d.sign()),s<r&&(l=l.transpose()),j(Re(this.gain),l.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}yC.className="Orthogonal";ce(yC);const k1={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function C1(t,e={}){return Cl(t,ms.getMap().classNameMap,e,"initializer")}function Et(t){return Bb(t)}function kt(t){if(typeof t=="string"){const e=t in k1?k1[t]:t;if(e==="GlorotNormal")return new Gb;if(e==="GlorotUniform")return new Ub;if(e==="HeNormal")return new Hb;if(e==="HeUniform")return new qb;if(e==="LeCunNormal")return new jb;if(e==="LeCunUniform")return new Kb;{const n={};return n.className=e,n.config={},C1(n)}}else return t instanceof ks?t:C1(t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Em(t){return Array.isArray(t)&&Array.isArray(t[0])}function qc(t){return t.length===0?[]:Array.isArray(t[0])?t:[t]}function Pe(t){let e;if(Array.isArray(t)){if(t.length!==1)throw new X(`Expected Tensor length to be 1; got ${t.length}`);e=t[0]}else e=t;return e}function ut(t){if(Array.isArray(t)&&Array.isArray(t[0])){if(t.length===1)return t=t,t[0];throw new X(`Expected exactly 1 Shape; got ${t.length}`)}else return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function jc(t){let e=0;for(const n of t)n.shape.length===0?e+=1:e+=n.shape.reduce((s,r)=>s*r);return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const T1="Variable";class yq{constructor(e,n="float32",s=T1,r=!0,a=null){this.dtype=n??"float32",this.shape=e.shape,this.id=rC(),s=s??T1,this.originalName=iC(s),this.name=oC(this.originalName),this.trainable_=r,this.constraint=a,this.val=X_(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),bq(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function bq(t,e){if(t.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(t.shape)+" vs. "+JSON.stringify(e.shape))}function Am(t){return t.map(e=>e.read())}function Xb(t){t.forEach(e=>{e[0].write(e[1])})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class qt{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class gr{constructor(e,n,s,r,a,i,o){this.dtype=e,this.shape=n,this.sourceLayer=s,this.inputs=r,this.callArgs=a,this.outputTensorIndex=o,this.id=rC(),i!=null&&(this.originalName=iC(i),this.name=oC(this.originalName)),this.rank=n.length}}let xq=0;class Qh{constructor(e,n){this.callArgs=n,this.id=xq++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const s of e.inboundLayers)s!=null&&s.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const n of this.inboundLayers)n!=null?e.push(n.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let wq=0;class Ze extends mo{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=wq++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let n=e.name;if(!n){const s=this.getClassName();n=Sr(s)+"_"+Yh(s)}if(this.name=n,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let s;if(e.batchInputShape!=null)s=e.batchInputShape;else if(e.inputShape!=null){let a=null;e.batchSize!=null&&(a=e.batchSize),s=[a].concat(e.inputShape)}this.batchInputShape=s;let r=e.dtype;r==null&&(r=e.inputDType),r==null&&(r="float32"),this.dtype=r}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,n){return e.name+"_ib-"+n.toString()}getNodeAtIndex(e,n){if(this.inboundNodes.length===0)throw new bs(`The layer has never been called and thus has no defined ${n}.`);if(this.inboundNodes.length<=e)throw new X(`Asked to get ${n} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return Dn(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return Dn(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new ir(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new ir(`Layer ${this.name} is not connected, no input to return.`);return Dn(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new ir(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new ir(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Dn(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(n=>n.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const n=ht(e);if(this.inputSpec==null||this.inputSpec.length===0)return;const s=ht(this.inputSpec);if(n.length!==s.length)throw new X(`Layer ${this.name} expects ${s.length} inputs, but it received ${n.length} input tensors. Input received: ${e}`);for(let r=0;r<n.length;r++){const a=n[r],i=s[r];if(i==null)continue;const o=a.rank;if(i.ndim!=null&&o!==i.ndim)throw new X(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${i.ndim}, found ndim=${o}`);if(i.maxNDim!=null&&o>i.maxNDim)throw new X(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${i.maxNDim}, found ndim=${o}`);if(i.minNDim!=null&&o<i.minNDim)throw new X(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${i.minNDim}, found ndim=${o}.`);if(i.dtype!=null&&a.dtype!==i.dtype)throw new X(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${i.dtype}, found dtype=${a.dtype}.`);if(i.axes){const u=a.shape;for(const l in i.axes){const c=Number(l),d=i.axes[l],h=c>=0?u[c]:u[u.length+c];if(d!=null&&[d,null].indexOf(h)===-1)throw new X(`Input ${r} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${d} but got shape ${u}.`)}}if(i.shape!=null)for(let u=0;u<i.shape.length;++u){const l=i.shape[u],c=a.shape[u];if(l!=null&&c!=null&&l!==c)throw new X(`Input ${r} is incompatible with layer ${this.name}: expected shape=${i.shape}, found shape=${a.shape}.`)}}}call(e,n){return e}invokeCallHook(e,n){this._callHook!=null&&this._callHook(e,n)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,n){n=n||{},this.assertNotDisposed();const s=ht(e),r=Sq(e),a=Iq(e);if(r===a)throw new X("Arguments to apply() must be all SymbolicTensors or all Tensors");return ja(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const i=[];for(const o of ht(e))i.push(o.shape);this.build(Dn(i)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&a&&(this._refCount=1)}if(this.assertInputCompatibility(e),a){let i=this.call(e,n);this.supportsMasking&&this.setMaskMetadata(e,i);const o=ht(i),u=[];for(let l of o)s.indexOf(l)!==-1&&(l=l.clone()),u.push(l);if(i=Dn(u),this.activityRegularizer!=null)throw new He("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}else{const i=$q(e),o=this.computeOutputShape(i);let u;const l=vq(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?i[0]:i),o!=null&&o.length>0&&Array.isArray(o[0])?u=o.map((c,d)=>new gr(l,c,this,ht(e),n,this.name,d)):u=new gr(l,o,this,ht(e),n,this.name),this.addInboundNode(e,u,null,null,i,o,n),this._refCount++,this.activityRegularizer!=null)throw new He("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return u}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let n=!1;this.batchInputShape.forEach((s,r)=>{s!=null&&e[r]!=null&&e[r]!==s&&(n=!0)}),n&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new ir(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const n of this.inboundNodes){const s=JSON.stringify(n.outputShapes);e.indexOf(s)===-1&&e.push(s)}if(e.length===1){const n=this.inboundNodes[0].outputShapes;return Array.isArray(n)&&Array.isArray(n[0])&&n.length===1?n[0]:n}else throw new ir(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new bs(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return jc(this.weights)}build(e){this.built=!0}getWeights(e=!1){return Am(e?this.trainableWeights:this.weights)}setWeights(e){ee(()=>{const n=this.weights;if(n.length!==e.length)throw new X(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${n.length} weights. Provided weights: ${e}...`);if(n.length===0)return;const s=[],r=Am(n);for(let a=0;a<r.length;++a){const i=r[a],o=n[a],u=e[a];if(!tt(i.shape,u.shape))throw new X(`Layer weight shape ${i.shape} not compatible with provided weight shape ${u.shape}`);s.push([o,u])}Xb(s)})}addWeight(e,n,s,r,a,i,o,u){if(this._addedWeightNames.indexOf(e)!==-1)throw new X(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),s==null&&(s="float32"),this.fastWeightInitDuringBuild&&(r=u!=null?u():kt("zeros"));const l=r.apply(n,s),c=new yq(l,s,e,i,o);return l.dispose(),a!=null&&this.addLoss(()=>a.apply(c.read())),i==null&&(i=!0),i?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=ht(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,n){if(!this.supportsMasking){if(n!=null)if(Array.isArray(n))n.forEach(s=>{if(s!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return n}setMaskMetadata(e,n,s){if(!this.supportsMasking)return;const r=this.computeMask(e,s),a=ht(n),i=ht(r);if(a.length!==i.length)throw new Error(`${this.name} outputs ${a.length} tensors but ${a.length} masks for those tensors`);for(let o=0;o<a.length;o++)a[o].kerasMask=i[o]}addInboundNode(e,n,s,r,a,i,o=null){const u=ht(e);n=ht(n),s=ht(s),r=ht(r),a=qc(a),i=qc(i);const l=[],c=[],d=[];for(const h of u)l.push(h.sourceLayer),c.push(h.nodeIndex),d.push(h.tensorIndex);new Qh({outboundLayer:this,inboundLayers:l,nodeIndices:c,tensorIndices:d,inputTensors:u,outputTensors:n,inputMasks:s,outputMasks:r,inputShapes:a,outputShapes:i},o);for(let h=0;h<n.length;h++)n[h].sourceLayer=this,n[h].nodeIndex=this.inboundNodes.length-1,n[h].tensorIndex=h}getConfig(){const e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function $q(t){t=ht(t);const e=[];for(const n of t)e.push(n.shape);return Dn(e)}function vq(t){return"float32"}function bC(t,e,n){if((e==null||n!=null&&n>0)&&(e=t.sourceLayer,n=t.nodeIndex),e.inboundNodes.length===0)return[t];{const s=e.inboundNodes[n];if(s.inboundLayers.length===0)return s.inputTensors;{const r=[];for(let a=0;a<s.inboundLayers.length;a++){const i=s.inputTensors[a],o=s.inboundLayers[a],u=s.nodeIndices[a],l=bC(i,o,u);for(const c of l)r.indexOf(c)===-1&&r.push(c)}return r}}}function Sq(t){let e=!0;for(const n of ht(t))if(!(n instanceof gr)){e=!1;break}return e}function Iq(t){let e=!0;for(const n of ht(t))if(n instanceof gr){e=!1;break}return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Al extends Ze{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:Yh("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new X("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let n=e.batchInputShape;if(n==null){if(e.inputShape==null)throw new X("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");n=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new X("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=e.dtype||"float32";this.batchInputShape=n,this.dtype=s,this.inputSpec=[{shape:n}];const r=new gr(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new Qh({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[n],outputShapes:[n]})}apply(e,n){throw new X(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}Al.className="InputLayer";ce(Al);function _q(t){if(t.batchShape==null&&t.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(t.batchShape!=null&&t.shape!=null)throw new X("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=t.batchShape;t.shape!=null&&e==null&&(e=[null].concat(t.shape));let n=t.dtype;return n==null&&(n="float32"),new Al({batchInputShape:e,name:t.name,dtype:n,sparse:t.sparse}).inboundNodes[0].outputTensors[0]}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function kq(t,e){if(t.dtype==null||t.dtype===e.dtype)return e;try{return ge(e,t.dtype)}catch{throw new X(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${t.name}' (${t.dtype}).`)}}class Zr{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof Zr)for(const n in e.id2Value)this.id2Value[n]=e.id2Value[n],n in e.id2Mask&&(this.id2Mask[n]=e.id2Mask[n]);else{if(e==null)return;for(const n of e)this.add(n.key,n.value)}}add(e,n,s){if(this.id2Value[e.id]==null)this.id2Value[e.id]=kq(e,n),this.name2Id[e.name]=e.id,s!=null&&(this.id2Mask[e.id]=s);else throw new X(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof gr){if(this.id2Value[e.id]==null)throw new X(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{const n=this.name2Id[e];if(n==null)throw new X(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[n]}}getMask(e){if(e instanceof gr){if(this.id2Value[e.id]==null)throw new X(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{const n=this.name2Id[e];if(n==null)throw new X(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[n]}}disposeMasks(){this.id2Mask!=null&&Ve(this.id2Mask)}}const Kc=new tC,Xc=new tC;function Cq(t){Kc!=null&&Kc.setMaxEntries(t),Xc!=null&&Xc.setMaxEntries(t)}function qo(t,e,n,s){const r=n==null?!1:n.training,a=Array.isArray(t),i=a?t:[t],o=i.map(f=>f.name),u=[],l=e.names();for(const f of o)l.indexOf(f)!==-1?u.push(e.getValue(f)):u.push(null);const c=o.join(",")+"|"+e.names().sort().join(",");let d=Kc.get(c),h;if(d==null){const f=Tq(i,e);d=f.sorted,h=f.recipientCounts,Kc.put(c,d),Xc.put(c,h)}h={},r||Object.assign(h,Xc.get(c));const p=new Zr(e);for(let f=0;f<d.length;++f){const m=d[f],g=m.sourceLayer;if(g instanceof Al)continue;const y=[],b=[],$=[];let w=!1;for(const A of m.inputs){const I=p.getValue(A),E=p.getMask(A);y.push(I),b.push(E),E!=null&&(w=!0),r||(h[A.name]--,h[A.name]===0&&!e.hasKey(A)&&o.indexOf(A.name)===-1&&!I.isDisposed&&A.sourceLayer.stateful!==!0&&$.push(I))}w&&(n=n||{},n.mask=b[0]);const v=ht(g.apply(y,n));let k=null;g.supportsMasking&&(k=g.computeMask(y,b));const C=Eq(m),N=Array.isArray(C)?C:[C];for(let A=0;A<N.length;++A){p.hasKey(N[A])||p.add(N[A],v[A],Array.isArray(k)?k[0]:k);const I=o.indexOf(N[A].name);I!==-1&&(u[I]=v[A])}r||Ve($)}return p.disposeMasks(),a?u:u[0]}function Tq(t,e){O(t!=null&&t.length>0,()=>"Expected at least one fetch, got none");let n=[],s={};if(t.length===1){const r=N1(t[0],e);n=r.sorted,s=r.recipientMap}else{const r=new Set;for(const a of t){const{sorted:i,recipientMap:o}=N1(a,e);for(const u of i)r.has(u.name)||(n.push(u),r.add(u.name));for(const u in o)s[u]==null&&(s[u]=new Set),o[u].forEach(l=>s[u].add(l))}}return{sorted:n,recipientCounts:Nq(s)}}function Nq(t){const e={};for(const n in t)e[n]=t[n].size;return e}function N1(t,e){const n=new Set,s=[],r={};for(const o of e.names())n.add(o);const a=[],i=[];for(a.push(t);a.length>0;){const o=a[a.length-1];if(n.has(o.name)){a.pop();continue}const u=i[i.length-1]===a.length-1;if(o.inputs.length===0||u)a.pop(),s.push(o),n.add(o.name),u&&i.pop();else{i.push(a.length-1);for(const l of o.inputs)r[l.name]==null&&(r[l.name]=new Set),r[l.name].add(o.name),!n.has(l.name)&&a.push(l)}}return{sorted:s,recipientMap:r}}function Eq(t){let e;if(t.sourceLayer.inboundNodes.length===1)e=t.sourceLayer.output;else{let n=null;for(let s=0;s<t.sourceLayer.inboundNodes.length;++s)for(const r of t.sourceLayer.inboundNodes[s].outputTensors)if(r.id===t.id){n=s;break}e=t.sourceLayer.getOutputAt(n)}return e}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aq=te();Aq.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,Cq);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Yb(t,e){return ee(()=>hn(Ie(j(t,t),e,!0)))}class Rl extends mo{getConfig(){return{}}}class xC extends Rl{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return ee(()=>{const n=Yb(e,this.axis),s=qn(n,0,this.maxValue);return j(e,Te(s,le(Ht(),n)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}xC.className="MaxNorm";ce(xC);class wC extends Rl{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return ee(()=>Te(e,le(Ht(),Yb(e,this.axis))))}getConfig(){return{axis:this.axis}}}wC.className="UnitNorm";ce(wC);class $C extends Rl{apply(e){return xr(e)}}$C.className="NonNeg";ce($C);class vC extends Rl{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return ee(()=>{const n=Yb(e,this.axis),s=le(j(this.rate,qn(n,this.minValue,this.maxValue)),j(1-this.rate,n));return j(e,Te(s,le(Ht(),n)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}vC.className="MinMaxNorm";ce(vC);const E1={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Kt(t){return Bb(t)}function A1(t,e={}){return Cl(t,ms.getMap().classNameMap,e,"constraint")}function Xt(t){if(t==null)return null;if(typeof t=="string"){const n={className:t in E1?E1[t]:t,config:{}};return A1(n)}else return t instanceof Rl?t:A1(t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function Aa(t){if(t==null)return;const e=[],n=[],s=[];for(const r in t){const a=t[r];if(typeof a!="number"){const i=a;e.push(i.data()),n.push(r),s.push(i)}}if(e.length>0){const r=await Promise.all(e);for(let a=0;a<r.length;++a)t[n[a]]=r[a][0];Ve(s)}}function SC(t){if(t!=null)for(const e in t){const n=t[e];typeof n!="number"&&n.dispose()}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var R1;(function(t){t[t.SILENT=0]="SILENT",t[t.VERBOSE=1]="VERBOSE"})(R1||(R1={}));const Rq=125;class cu{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,n){}async onEpochEnd(e,n){}async onBatchBegin(e,n){}async onBatchEnd(e,n){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class Dq{constructor(e,n=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=n}append(e){this.callbacks.push(e)}setParams(e){for(const n of this.callbacks)n.setParams(e)}setModel(e){for(const n of this.callbacks)n.setModel(e)}async onEpochBegin(e,n){n==null&&(n={});for(const s of this.callbacks)await s.onEpochBegin(e,n)}async onEpochEnd(e,n){n==null&&(n={});for(const s of this.callbacks)await s.onEpochEnd(e,n)}async onBatchBegin(e,n){n==null&&(n={});for(const s of this.callbacks)await s.onBatchBegin(e,n)}async onBatchEnd(e,n){n==null&&(n={});for(const s of this.callbacks)await s.onBatchEnd(e,n)}async onTrainBegin(e){e==null&&(e={});for(const n of this.callbacks)await n.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(const n of this.callbacks)await n.onTrainEnd(e)}}class Oq extends cu{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,n){n==null&&(n={});const s=n.size==null?0:n.size;this.seen+=s;for(const r in n){const a=n[r];if(typeof a=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+a*s;else{let i;r in this.totals?i=this.totals[r]:this.totals[r]=0;const o=ee(()=>le(this.totals[r],j(a,s)));this.totals[r]=o,i!=null&&i.dispose()}}}async onEpochEnd(e,n){if(n!=null)for(const s of this.params.metrics)this.totals[s]!=null&&(typeof this.totals[s]=="number"?n[s]=this.totals[s]/this.seen:ee(()=>{const r=j(Te(1,this.seen),this.totals[s]);n[s]=r,this.totals[s].dispose(),tn(n[s])}))}}class Fq extends cu{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,n){n==null&&(n={}),this.epoch.push(e);for(const s in n)this.history[s]==null&&(this.history[s]=[]),this.history[s].push(n[s])}async syncData(){const e=[],n=[],s=[];for(const a in this.history){const i=this.history[a];for(let o=0;o<i.length;++o)if(typeof i[o]!="number"){const u=i[o];e.push(u.data()),n.push(a),s.push(o)}}const r=await Promise.all(e);for(let a=0;a<r.length;++a)this.history[n[a]][s[a]].dispose(),this.history[n[a]][s[a]]=r[a][0]}}class zq extends cu{constructor(e,n){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||Tk,this.yieldEvery=n||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=Rq),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");sm(this.yieldEvery)&&(this.maybeWait=XH(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,n,s){const r=[];this.yield!=null&&(await Aa(s),r.push(this.yield(e,n,s))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,n){this.currentEpoch=e,this.epochBegin!=null&&(await Aa(n),await this.epochBegin(e,n))}async onEpochEnd(e,n){const s=[];this.epochEnd!=null&&(await Aa(n),s.push(this.epochEnd(e,n))),this.yieldEvery==="epoch"&&s.push(this.nextFrameFunc()),await Promise.all(s)}async onBatchBegin(e,n){this.batchBegin!=null&&(await Aa(n),await this.batchBegin(e,n))}async onBatchEnd(e,n){const s=[];this.batchEnd!=null&&(await Aa(n),s.push(this.batchEnd(e,n))),this.yieldEvery==="batch"?s.push(this.nextFrameFunc()):sm(this.yieldEvery)&&s.push(this.maybeWait(this.currentEpoch,e,n)),await Promise.all(s)}async onTrainBegin(e){this.trainBegin!=null&&(await Aa(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await Aa(e),await this.trainEnd(e))}}function IC(t,e){return t==null&&(t={}),t instanceof cu?[t]:Array.isArray(t)&&t[0]instanceof cu?t:ht(t).map(s=>new zq(s,e))}class ps{constructor(){}static registerCallbackConstructor(e,n){O(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),ps.checkForDuplicate(n),ps.constructors[e]==null&&(ps.constructors[e]=[]),ps.constructors[e].push(n)}static checkForDuplicate(e){for(const n in ps.constructors)ps.constructors[+n].forEach(r=>{if(r===e)throw new X("Duplicate callback constructor.")})}static clear(){ps.constructors={}}static createCallbacks(e){const n=[];for(const s in ps.constructors){const r=+s;e>=r&&n.push(...ps.constructors[r])}return n.map(s=>new s)}}ps.constructors={};function _C(t,e,n,s,r,a,i,o,u){const l=new Fq,c=[new Oq,...ps.createCallbacks(e)];t!=null&&c.push(...t),c.push(l);const d=new Dq(c);return d.setParams({epochs:n,initialEpoch:s,samples:r,steps:a,batchSize:i,verbose:e,doValidation:o,metrics:u}),{callbackList:d,history:l}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Nr(t,e={},n=!1){return Cl(t,ms.getMap().classNameMap,e,"layer",n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Yc(t,e){return ee(()=>{t.dtype!=="float32"&&(t=ge(t,"float32"));const n=Ie(Nl(t),e,!0),s=co(n.shape,Ht()),r=hn(zr(n,s));return Te(t,r)})}function Jh(t,e){return ee(()=>Rt(Nl(we(e,t)),-1))}function Zb(t,e){return ee(()=>Rt(Ut(we(e,t)),-1))}function Qb(t,e){return ee(()=>{const n=we(t,e),s=qn(Ut(t),Ht(),Number.MAX_VALUE),r=Ut(Te(n,s));return j(100,Rt(r,-1))})}function Lq(t,e){return ee(()=>{const n=qn(e,Ht(),Number.MAX_VALUE),s=rs(le(1,n)),r=qn(t,Ht(),Number.MAX_VALUE),a=rs(le(1,r));return Rt(Nl(we(s,a)),-1)})}function Pq(t,e){return ee(()=>{const n=zr(0,we(1,j(t,e)));return Rt(Nl(n),-1)})}function Bq(t,e){return ee(()=>{const n=zr(0,we(1,j(t,e)));return Rt(n,-1)})}function Mq(t,e){return ee(()=>{const n=Ie(j(t,e),-1),s=$s(j(we(1,t),e),-1);return zr(0,le(1,we(s,n)))})}function Vq(t,e){return ee(()=>{const n=Math.log(2),s=we(e,t),r=we(le(s,ho(j(-2,s))),n);return Rt(r,-1)})}function du(t,e,n=!1){return ee(()=>{if(n)e=Bh(e);else{const s=Ie(e,e.shape.length-1,!0);e=Te(e,s)}return e=qn(e,Ht(),1-Ht()),It(Ie(j(ge(t,"float32"),rs(e)),e.shape.length-1))})}function Zc(t,e,n=!1){return ee(()=>{const s=ge(vl(oq(t)),"int32");e=qn(e,Ht(),1-Ht());const r=e.shape,a=K(Vy(s,r[r.length-1]),r);return du(a,e,n)})}function Wq(t,e){if(!tt(t.shape,e.shape))throw new X(`logits and labels must have the same shape, but got shapes ${JSON.stringify(t.shape)} and ${JSON.stringify(e.shape)}`);return ee(()=>{const n=xr(e),s=It(Ut(e));return le(we(n,j(e,t)),Nh(jn(s)))})}function ep(t,e){return ee(()=>{let n;return n=qn(e,Ht(),1-Ht()),n=rs(Te(n,we(1,n))),Rt(Wq(t,n),-1)})}function Uq(t,e){return ee(()=>{const n=qn(t,Ht(),1),s=qn(e,Ht(),1);return Ie(j(t,rs(Te(n,s))),-1)})}function Gq(t,e){return ee(()=>{const n=rs(le(Ht(),e));return Rt(we(e,j(t,n)),-1)})}function kC(t,e){return ee(()=>{const n=Yc(t,-1),s=Yc(e,-1),r=j(n,s);return It(Ie(r,-1))})}const Qc={meanSquaredError:Jh,meanAbsoluteError:Zb,meanAbsolutePercentageError:Qb,meanSquaredLogarithmicError:Lq,squaredHinge:Pq,hinge:Bq,categoricalHinge:Mq,logcosh:Vq,categoricalCrossentropy:du,sparseCategoricalCrossentropy:Zc,binaryCrossentropy:ep,kullbackLeiblerDivergence:Uq,poisson:Gq,cosineProximity:kC};function Kp(t){if(typeof t=="string"){if(t in Qc)return Qc[t];let e=`Unknown loss ${t}`;throw t.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${t}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new X(e)}else return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function CC(t,e){return ee(()=>{const n=j(.5,as(e)),s=pr(Qn(e,n),t.dtype);return Rt(Ks(t,s),-1)})}function TC(t,e){return ee(()=>pr(Ks(Ki(t,-1),Ki(e,-1)),"float32"))}function Hq(t,e){return ee(()=>ge(Ie(mr(Ks(t,1),Ks(e,1))),"float32"))}function qq(t,e){return ee(()=>ge(Ie(mr(Ks(t,0),Ks(e,1))),"float32"))}function jq(t,e){return ee(()=>{const n=Hq(t,e),s=qq(t,e),r=le(n,s);return ge(bn(Qn(r,0),Te(n,r),0),"float32")})}function Kq(t,e){return ep(t,e)}function Xq(t,e){return t.rank===e.rank&&(t=bi(t,[t.rank-1])),e=Ki(e,-1),e.dtype!==t.dtype&&(e=ge(e,t.dtype)),ge(Ks(t,e),"float32")}const Yq=Jh,Zq=Jh,Qq=Zb,Jq=Zb,e6=Qb,t6=Qb,NC=du,n6=kC,EC=Zc,Jc={binaryAccuracy:CC,categoricalAccuracy:TC,precision:jq,categoricalCrossentropy:NC,sparseCategoricalCrossentropy:EC,mse:Yq,MSE:Zq,mae:Qq,MAE:Jq,mape:e6,MAPE:t6,cosine:n6};function s6(t){if(typeof t=="string"&&t in Jc)return Jc[t];if(typeof t!="string"&&t!=null)return t;throw new X(`Unknown metric ${t}`)}function tc(t){if(or(t!==null,`Unknown LossOrMetricFn ${t}`),typeof t=="string")return t;{let e;for(const n of Object.keys(Qc))if(Qc[n]===t){e=n;break}if(e!==void 0)return e;for(const n of Object.keys(Jc))if(Jc[n]===t){e=n;break}return e!==void 0?e:t.name}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function r6(t){const e={Adagrad:()=>Ni.adagrad(.01),Adadelta:()=>Ni.adadelta(1,.95,Ht()),Adam:()=>Ni.adam(.001,.9,.999,Ht()),Adamax:()=>Ni.adamax(.002,.9,.999,Ht(),0),RMSProp:()=>Ni.rmsprop(.001,.9,0,Ht()),SGD:()=>Ni.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,t in e)return e[t]();throw new X(`Unknown Optimizer ${t}`)}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const D1=1*1024*1024;function O1(t,e,n=!1){if(t==null||typeof t!="object"||Object.getPrototypeOf(t)!==Object.prototype||!Rm(t))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const s=JSON.stringify(t);s.length>D1&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${D1}.`)}}function Rm(t){if(t===null)return!0;if(typeof t=="object")if(Object.getPrototypeOf(t)===Object.prototype){const e=Object.keys(t);for(const n of e)if(typeof n!="string"||!Rm(t[n]))return!1;return!0}else if(Array.isArray(t)){for(const e of t)if(!Rm(e))return!1;return!0}else return!1;else{const e=typeof t;return e==="string"||e==="number"||e==="boolean"}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function a6(t,e,n,s=console.log){const r=o6(t),a=["Layer (type)","Input Shape","Output shape","Param #"];r?(e=e||90,n=n||[.32,.61,.89,1]):(e=e||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(c=>Math.floor(e*c)));let i;if(!r){a.push("Receives inputs"),i=[];for(const c in t.nodesByDepth)i.push(...t.nodesByDepth[c])}s("_".repeat(e)),ed(a,n,s),s("=".repeat(e));const o=t.layers;for(let c=0;c<o.length;++c)r?u6(o[c],n,s):l6(o[c],n,i,s),s((c===o.length-1?"=":"_").repeat(e));t.checkTrainableWeightsConsistency();const u=i6(t),l=jc(t.nonTrainableWeights);s(`Total params: ${u+l}`),s(`Trainable params: ${u}`),s(`Non-trainable params: ${l}`),s("_".repeat(e))}function i6(t){let e;return t.collectedTrainableWeights!=null?e=jc(t.collectedTrainableWeights):e=jc(t.trainableWeights),e}function o6(t){let e=!0;const n=[],s=[];for(const r in t.nodesByDepth)n.push(t.nodesByDepth[r]);for(const r of n){if(r.length>1||r.length===1&&r[0].inboundLayers.length>1){e=!1;break}s.push(...r)}if(e)for(const r of t.layers){let a=!1;for(const i of r.inboundNodes)if(s.indexOf(i)!==-1)if(a){e=!1;break}else a=!0;if(!e)break}return e}function ed(t,e,n=console.log){let s="";for(let r=0;r<t.length;++r)r>0&&(s=s.slice(0,s.length-1)+" "),s+=t[r],s=s.slice(0,e[r]),s+=" ".repeat(e[r]-s.length);n(s)}function u6(t,e,n){let s,r;try{r=t.inboundNodes.map(u=>JSON.stringify(u.inputShapes)).join(",")}catch{r="multiple"}try{s=JSON.stringify(t.outputShape)}catch{s="multiple"}const a=t.name,i=t.getClassName(),o=[`${a} (${i})`,r,s,t.countParams().toString()];ed(o,e,n)}function l6(t,e,n,s){let r,a;try{a=t.inboundNodes.map(d=>JSON.stringify(d.inputShapes)).join(",")}catch{a="multiple"}try{r=JSON.stringify(t.outputShape)}catch{r="multiple"}const i=[];for(const d of t.inboundNodes)if(!(n!=null&&n.length>0&&n.indexOf(d)===-1))for(let h=0;h<d.inboundLayers.length;++h){const p=d.inboundLayers[h].name,f=d.nodeIndices[h],m=d.tensorIndices[h];i.push(`${p}[${f}][${m}]`)}const o=t.name,u=t.getClassName(),l=i.length===0?"":i[0],c=[`${o} (${u})`,a,r,t.countParams().toString(),l];ed(c,e,s);for(let d=1;d<i.length;++d)ed(["","","","",i[d]],e,s)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function AC(t,e,n){return(t==="inboundNodes"||t==="outputLayers"||t==="inputLayers")&&e===0&&typeof n=="string"}function Dm(t,e){if(t===null)return null;if(typeof t=="string")return Ba(t);if(typeof t=="number"||typeof t=="boolean")return t;if(t instanceof Array){const n=[],s=t.length;for(let r=0;r<s;++r){const a=t[r];AC(e,r,a)?n.push(a):n.push(Dm(a,e))}return n}else{const n={};for(const s of Object.keys(t)){const r=t[s];if(s==="name"&&typeof r=="string")n[s]=r;else{const a=Ba(s);n[a]=Dm(r,a)}}return n}}function Om(t,e){if(t==null)return null;if(typeof t=="string")return Sr(t);if(typeof t=="number"||typeof t=="boolean")return t;if(t instanceof Array){const n=[],s=t.length;for(let r=0;r<s;++r){const a=t[r];AC(e,r,a)?n.push(a):n.push(Om(a,e))}return n}else{const n={};for(const s of Object.keys(t)){const r=t[s],a=Sr(s);(s==="name"||s==="className")&&typeof r=="string"?n[a]=r:n[a]=Om(r,s)}return n}}/** @license See the LICENSE file. */const RC="4.22.0";/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const c6=t=>{const e=Object.keys(t);if(e.length===0)return!1;const n=e[0].split("/");return!isNaN(parseInt(n[n.length-1],10))};class Ms extends Ze{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){const b=this.getClassName().toLowerCase();this.name=Yh(b)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],ta(this.inputs).length!==this.inputs.length)throw new X(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(b=>b.name)}`);ta(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(b=>b.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const b of this.outputs){const $=b.sourceLayer,w=b.nodeIndex,v=b.tensorIndex;this.outputLayers.push($),this.outputLayersNodeIndices.push(w),this.outputLayersTensorIndices.push(v)}for(const b of this.inputs){const $=b.sourceLayer,w=b.nodeIndex,v=b.tensorIndex;or(w===0,"input layer has >1 nodes"),or(v===0,"input layer has >1 tensors"),this.inputLayers.push($),this.inputLayersNodeIndices.push(w),this.inputLayersTensorIndices.push(v)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){const $=this.inputLayers[b];if(!($ instanceof Al))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${b} (0-based) originates from layer type ${$.getClassName()}.`);this.inputNames.push($.name),this.feedInputShapes.push($.batchInputShape),this.feedInputNames.push($.name)}for(const b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(b=>b.shape),this.internalOutputShapes=this.outputs.map(b=>b.shape);const n={},s={},r={},a={},i={},o=[],u=(b,$,w,v,k,C)=>{(v==null||k==null||C==null)&&(v=b.sourceLayer,k=b.nodeIndex,C=b.tensorIndex);const N=v.inboundNodes[k];if(w.indexOf(N)!==-1)throw new bs(`The tensor ${b.name} at layer "${v.name}" is part of a cycle.`);if($.indexOf(N)!==-1)return;this.containerNodes.add(Ms.nodeKey(v,k)),v.id in i||(i[v.id]=Object.keys(i).length),w.indexOf(N)===-1&&w.push(N);const A=N.inboundLayers.length;for(let I=0;I<A;I++){const E=N.inputTensors[I],z=N.inboundLayers[I],P=N.nodeIndices[I],H=N.tensorIndices[I];u(E,$,w,z,P,H)}for($.push(N);w.indexOf(N)>=0;)w.splice(w.indexOf(N),1);o.push(N)},l=[],c=[];for(const b of this.outputs)u(b,l,c);const d=o.slice().reverse();for(const b of d){s[b.id]=b,b.id in n||(n[b.id]=0);let $=n[b.id];const w=r[b.outboundLayer.id]==null?0:r[b.outboundLayer.id];$=Math.max($,w),r[b.outboundLayer.id]=$,a[b.outboundLayer.id]=b.outboundLayer,n[b.id]=$;for(let v=0;v<b.inboundLayers.length;v++){const k=b.inboundLayers[v],C=b.nodeIndices[v],N=k.inboundNodes[C],A=n[N.id]==null?0:n[N.id];n[N.id]=Math.max($+1,A),s[N.id]=N}}const h={};for(const b in n){const $=n[b];$ in h||(h[$]=[]),h[$].push(s[b])}const p={};for(const b in r){const $=r[b];$ in p||(p[$]=[]),p[$].push(a[b])}let f=Object.keys(p).map(b=>parseInt(b,10)).sort(Ql);this.layers=[];for(const b of f){const $=p[b];$.sort((w,v)=>{const k=i[w.id],C=i[v.id];return k<C?-1:k>C?1:0});for(const w of $)w instanceof Ms&&this.internalContainerRefs.push(w),this.layers.push(w)}this.layersByDepth=p,f=Object.keys(h).map(b=>parseInt(b,10)).sort(Ql);const m=this.inputs.slice(),g=[];for(const b of f)for(const $ of h[b]){const w=$.outboundLayer;if(w!=null){for(const v of $.inputTensors)if(m.indexOf(v)===-1)throw new bs(`Graph disconnected: cannot obtain value for tensor ${v} at layer "${w.name}". The following previous layers were accessed without issue: ${g}`);for(const v of $.outputTensors)m.push(v);g.push(w.name)}}this.nodesByDepth=h;const y=this.layers.map(b=>b.name);for(const b of y){const $=y.filter(w=>w===b).length;if($!==1)throw new bs(`The name "${b}" is used ${$} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new Qh({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(b=>null),outputMasks:this.outputs.map(b=>null),inputShapes:this.inputs.map(b=>b.shape),outputShapes:this.outputs.map(b=>b.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const n of this.layers)e.numDisposedVariables+=n.dispose().numDisposedVariables;for(const n of this.internalContainerRefs)e.numDisposedVariables+=n.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(n=>{n._trainableWeights.forEach(s=>s.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new X("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const n of this.layers)e=e.concat(n.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const n of this.layers)e.push(...n.nonTrainableWeights);if(!this.trainable){const n=[];for(const s of this.layers)n.push(...s.trainableWeights);return n.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,n=!0){const s={};let r=0;const a=c6(e);a&&this.parseWeights(e);for(const o of this.layers)for(const[u,l]of o.weights.entries()){const c=a?`${l.name.split("/").slice(0,-1).join("/")+"/"}${u}`:l.originalName;if(s[c]!=null)throw new X(`Duplicate weight name: ${c}`);s[c]=l,r++}const i=[];for(const o in e){let u=o;if(s[o]==null){const l=o.split("/");u=l.slice(0,-2).concat([l[l.length-1]]).join("/")}if(s[u]!=null)i.push([s[u],e[o]]);else if(n)throw new X(`Provided weight data has no target variable: ${o}`);delete s[u]}if(n){const o=[];for(const u in s)o.push(u);if(o.length>0)throw new X(`${o.length} of ${r} weights are not set: ${o}`)}Xb(i)}parseWeights(e){for(const n in Object.keys(e)){const s=n.split("/"),r=["vars","layer_checkpoint_dependencies"],a=s.map(i=>i.startsWith("_")?i.slice(1):i).filter(i=>!r.includes(i)).join("/");a!==n&&(e[a]=e[n],delete e[n])}}updatedConfig(){const e=this.getConfig(),n={};return n.className=this.getClassName(),n.config=e,n.kerasVersion=`tfjs-layers ${RC}`,n.backend="TensorFlow.js",n}toJSON(e,n=!0){const s=Om(this.updatedConfig());return n?JSON.stringify(s):s}call(e,n){return ee(()=>{e=ht(e);const s=new Zr;for(let r=0;r<this.inputs.length;++r)s.add(this.inputs[r],e[r]);return qo(this.outputs,s,n)})}computeMask(e,n){return ee(()=>{e=ht(e);let s;return n==null?s=oi(null,e.length):s=ht(n),this.runInternalGraph(e,s)[1]})}computeOutputShape(e){const n=qc(e);if(n.length!==this.inputLayers.length)throw new X(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const s={};for(let o=0;o<n.length;o++){const u=this.inputLayers[o],l=n[o],c=u.name+"_0_0";s[c]=l}const r=Object.keys(this.nodesByDepth).map(o=>parseInt(o,10)).sort(Ql);if(r.length>1)for(const o of r){const u=this.nodesByDepth[o];for(const l of u){const c=l.outboundLayer;if(this.inputLayers.map(m=>m.id).indexOf(c.id)!==-1)continue;const d=[];for(let m=0;m<l.inboundLayers.length;m++){const g=l.inboundLayers[m],y=l.nodeIndices[m],b=l.tensorIndices[m],$=`${g.name}_${y}_${b}`,w=s[$];d.push(w)}const h=c.computeOutputShape(Dn(d)),p=qc(h),f=c.inboundNodes.indexOf(l);for(let m=0;m<p.length;m++){const g=`${c.name}_${f}_${m}`;s[g]=p[m]}}}const a=[],i=[];for(let o=0;o<this.outputLayers.length;o++){const u=this.outputLayers[o],l=this.outputLayersNodeIndices[o],c=this.outputLayersTensorIndices[o],d=`${u.name}_${l}_${c}`;i.push(d)}for(let o=0;o<i.length;o++){const u=i[o];or(u in s),a.push(s[u])}return Dn(a)}runInternalGraph(e,n){n==null&&(n=oi(null,e.length));const s={};for(let u=0;u<this.inputs.length;++u){const l=this.inputs[u],c=e[u],d=n[u];s[l.id]=[c,d]}const r=Object.keys(this.nodesByDepth).map(u=>parseInt(u,10)).sort(Ql);for(const u of r){const l=this.nodesByDepth[u];for(const c of l){const d=c.outboundLayer,h=c.inputTensors,p=c.outputTensors,f=new Array;for(const m of h)m.id in s&&f.push(s[m.id]);if(f.length===h.length){let m={},g,y,b,$;if(c.callArgs!=null&&(m=c.callArgs),f.length===1){const[w,v]=f[0];m.mask==null&&(m.mask=v),b=ht(d.call(w,m)),$=ht(d.computeMask(w,v)),g=[w],y=[v]}else g=f.map(w=>w[0]),y=f.map(w=>w[1]),m.mask==null&&(m.mask=y),b=ht(d.call(g,m)),$=ht(d.computeMask(g,y));if(d.activityRegularizer)throw new He("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let w=0;w<p.length;++w){const v=p[w],k=b[w],C=$[w];s[v.id]=[k,C]}}}}const a=[],i=[],o=[];for(const u of this.outputs){or(u.id in s,`Could not compute output ${u.name} : ${u.id}`);const[l,c]=s[u.id];o.push(l.shape),a.push(l),i.push(c)}return[a,i,o]}buildNodeConversionMap(e){const n={};let s;for(const r of this.layers){s=r instanceof Ms?1:0;for(let a=0;a<r.inboundNodes.length;a++){const i=Ms.nodeKey(r,a);this.containerNodes.has(i)&&(n[i]=s,s+=1)}}return n}getLayer(e,n){if(n!=null)return this.findLayer(n);if(e==null)throw new X("Provide either a layer name or layer index");if(typeof e=="number")return this.findLayer(e);for(const s of this.layers)if(s.name===e)return s;throw new X(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new X(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return ee(()=>{const e=[];for(const n of this.layers)for(let s=0;s<n.inboundNodes.length;++s){const r=Ms.nodeKey(n,s);this.containerNodes.has(r)&&e.push(...n.calculateLosses())}return e})}getConfig(){const e={name:this.name},n=this.buildNodeConversionMap(this.layers),s=[];for(const i of this.layers){const o=i.getClassName(),u=i.getConfig(),l=[];for(let d=0;d<i.inboundNodes.length;d++){const h=i.inboundNodes[d],p=Ms.nodeKey(i,d);let f={};if(this.containerNodes.has(p)){if(h.callArgs)try{JSON.stringify(h.callArgs),f=h.callArgs}catch{console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${h.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),f={}}if(h.inboundLayers.length>0){const m=[];for(let g=0;g<h.inboundLayers.length;g++){const y=h.inboundLayers[g],b=h.nodeIndices[g],$=h.tensorIndices[g],w=Ms.nodeKey(y,b);let v=n[w];v==null&&(v=0),m.push([y.name,v,$,f])}l.push(m)}}}const c={};c.name=i.name,c.className=o,c.config=u,c.inboundNodes=l,s.push(c)}e.layers=s;const r=[];for(let i=0;i<this.inputLayers.length;i++){const o=this.inputLayers[i],u=this.inputLayersNodeIndices[i],l=Ms.nodeKey(o,u);if(!this.containerNodes.has(l))continue;let c=n[l];c==null&&(c=0);const d=this.inputLayersTensorIndices[i];r.push([o.name,c,d])}e.inputLayers=r;const a=[];for(let i=0;i<this.outputLayers.length;i++){const o=this.outputLayers[i],u=this.outputLayersNodeIndices[i],l=Ms.nodeKey(o,u);if(!this.containerNodes.has(l))continue;let c=n[l];c==null&&(c=0);const d=this.outputLayersTensorIndices[i];a.push([o.name,c,d])}return e.outputLayers=a,e}static fromConfig(e,n,s={},r=!1){const a={},i={};function o(g,y){g.name in i?i[g.name].push(y):i[g.name]=[y]}function u(g,y){const b=[];let $;for(const w of y){const v=w[0],k=w[1],C=w[2];if($=w[3]==null?{}:w[3],!(v in a)){o(g,y);return}const N=a[v];if(N.inboundNodes.length<=k){o(g,y);return}const A=N.inboundNodes[k];b.push(A.outputTensors[C])}b.length>0&&g.apply(Dn(b),$)}function l(g){const y=g.name,b=Nr(g,n.customObjects!=null?n.customObjects:{});b.setFastWeightInitDuringBuild(r),a[y]=b,g.inboundNodes.forEach(w=>{if(!(w instanceof Array))throw new X(`Corrupted configuration, expected array for nodeData: ${w}`);o(b,w)})}const c=n.name,d=n.layers;for(const g of d)l(g);for(;!KH(i);)for(const g of d){const y=a[g.name];if(y.name in i){const b=i[y.name];delete i[y.name];for(const $ of b)u(y,$)}}const h=[],p=[],f=n.inputLayers;for(const g of f){const y=g[0],b=g[1],$=g[2];or(y in a);const v=a[y].inboundNodes[b].outputTensors;h.push(v[$])}const m=n.outputLayers;for(const g of m){const y=g[0],b=g[1],$=g[2];or(y in a);const v=a[y].inboundNodes[b].outputTensors;p.push(v[$])}return new e({inputs:h,outputs:p,name:c})}get stateful(){if(this._stateful)throw new X("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){ee(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function d6(t,e,n){const s=e.length;if(t==null||Array.isArray(t)&&t.length===0)return e.map(r=>null);if(s===1)return Array.isArray(t)&&t.length===1?t:typeof t=="object"&&e[0]in t?[t[e[0]]]:[t];if(Array.isArray(t)){if(t.length!==s)throw new Error(`Provided ${n} is an array of ${t.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return t}else if(typeof t=="object"&&Object.keys(t).length>0&&typeof t[Object.keys(t)[0]]=="object"){const r=[];return e.forEach(a=>{a in t?r.push(t[a]):r.push(null)}),r}else throw new Error(`The model has multiple (${s}) outputs, so ${n} must be either an array with ${s} elements or an object with ${e} keys. Provided ${n} not understood: ${JSON.stringify(t)}`)}function DC(t,e){return d6(t,e,"classWeight")}async function OC(t,e,n,s){if(n!=null){const r=ee(()=>{if(t.shape.length===1)return Tr(t);if(t.shape.length===2){if(t.shape[1]>1)return Ki(t,1);if(t.shape[1]===1)return K(t,[t.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${t.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${t.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),a=Array.from(await r.data());Ve(r);const i=[];return a.forEach(o=>{if(n[o]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${o} exists in the data but not in classWeight`);i.push(n[o])}),Cn(i,"float32")}else return null}function h6(t,e){return j(t,e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const p6=32;function FC(t,e){let n,s;const r=e;n=r.xs,s=r.ys,O(n!=null&&s!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const a=F1("input",t.inputNames,n),i=F1("output",t.outputNames,s),o=a[0].shape[0];O(a.length===t.inputs.length,()=>`LayersModel has ${t.inputs.length} inputs, but the dataset provides ${a.length} inputs.  (Expected input keys: ${JSON.stringify(t.inputNames)})`),O(i.length===t.outputs.length,()=>`LayersModel has ${t.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(t.outputNames)})`);for(let u=0;u<a.length;u++)O(a[u].shape[0]===o,()=>`Batch size mismatch: input ${t.inputNames[u]} has ${a[u].shape[0]}; expected  ${o} based on input ${t.inputNames[0]}.`);for(let u=0;u<i.length;u++)O(i[u].shape[0]===o,()=>`Batch size mismatch: output ${t.outputNames[u]} has ${i[u].shape[0]}; expected  ${o} based on input ${t.inputNames[0]}.`);return{xs:a,ys:i}}function F1(t,e,n){if(n instanceof _t)return[n];if(Array.isArray(n))return O(n.length===e.length,()=>`Received an array of ${n.length} Tensors, but expected ${e.length} to match the ${t} keys ${e}.`),n;{const s=[];for(const r of e){if(n[r]==null)throw new X(`The feature data generated by the dataset lacks the required ${t} key '${r}'.`);s.push(n[r])}return s}}function f6(t){if(t.length===3)throw new He("Validation with sample weights is not implemented yet.");return{xs:t[0],ys:t[1]}}async function m6(t,e,n){const s=n.batchesPerEpoch!=null;if(O(t.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),O(n!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),O(n.epochs!=null&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),O(!s||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),O(n.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0;try{const r=n.validationData!=null;let a,i;if(r)if(z1(n.validationData))O(n.validationBatches==null||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{const g=f6(n.validationData);a=g.xs,i=g.ys}const o=t.makeTrainFunction(),u=t.getDedupedMetricsNames();let l;r?l=u.slice().concat(u.map(g=>"val_"+g)):l=u.slice();const c=IC(n.callbacks,n.yieldEvery),d=n.verbose==null?1:n.verbose,{callbackList:h,history:p}=_C(c,d,n.epochs,null,null,g6(e,n),null,r,l);h.setModel(t),t.history=p,await h.onTrainBegin(),t.stopTraining_=!1;let f=n.initialEpoch==null?0:n.initialEpoch,m=await e.iterator();for(;f<n.epochs;){const g={};await h.onEpochBegin(f);let y=0,b=0;for(s||(m=await e.iterator());!s||y<n.batchesPerEpoch;){const $=await m.next();if(s&&$.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if($.value!=null){const{xs:w,ys:v}=FC(t,$.value),k={};k.batch=b,k.size=w[0].shape[0],await h.onBatchBegin(b,k);const C=[];if(n.classWeight!=null){const I=DC(n.classWeight,t.outputNames);for(let E=0;E<I.length;++E)C.push(await OC(v[E],null,I[E]))}const N=w.concat(v).concat(C),A=o(N);Ve(N);for(let I=0;I<u.length;++I){const E=u[I],z=A[I];k[E]=z,tn(z)}await h.onBatchEnd(b,k),SC(k),b++,y++}if(s?y>=n.batchesPerEpoch:$.done){if(r){let w;z1(n.validationData)?w=ht(await t.evaluateDataset(n.validationData,{batches:n.validationBatches})):w=ht(t.evaluate(a,i,{batchSize:n.validationBatchSize==null?p6:n.validationBatchSize,verbose:0}));for(let v=0;v<t.metricsNames.length;++v)g[`val_${t.metricsNames[v]}`]=w[v]}break}if(t.stopTraining_)break}if(await h.onEpochEnd(f,g),f++,t.stopTraining_)break}return await h.onTrainEnd(),await t.history.syncData(),t.history}finally{t.isTraining=!1}}function g6(t,e){let n=null;return e.batchesPerEpoch!=null?n=e.batchesPerEpoch:Number.isFinite(t.size)&&(n=t.size),n}function z1(t){return typeof t.iterator=="function"}function y6(t){return typeof t.next=="function"}async function b6(t,e,n){n=n||{};const s=n.batches!=null,r=t.testFunction;let a=[];if(n.verbose>0)throw new He("Verbose mode is not implemented yet.");O(!s||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);const i=y6(e)?e:await e.iterator();let o=0,u=0;for(;!s||u<n.batches;){const l=await i.next();if(a=ee(()=>{if(l.value){const{xs:c,ys:d}=FC(t,l.value),h=c.concat(d),p=ee(()=>r(h));if(Ve(h),u===0)for(let m=0;m<p.length;++m)a.push(Re(0));const f=h[0].shape[0];for(let m=0;m<p.length;++m){const g=p[m],y=a[m];a[m]=ee(()=>le(a[m],j(f,g))),u>0&&Ve(y)}Ve(p),o+=f,++u}return a}),l.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let l=0;l<a.length;++l){const c=a[l];a[l]=Te(a[l],o),Ve(c)}return Dn(a)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Xp(t){O(t>0&&Number.isInteger(t),()=>`batchSize is required to be a positive integer, but got ${t}`)}function Eo(t,e,n){return t==null?[null]:Array.isArray(t)?t.map(s=>Ka(s,e,n-e)):Ka(t,e,n-e)}function Fm(t,e){return ee(()=>t==null?null:Array.isArray(t)?t.map(n=>Fm(n,e)):lC(t,e.dtype==="int32"?e:ge(e,"int32")))}function Yp(t,e){const n=[];let s=0,r=null;for(;s<t;)r=s+e,r>=t&&(r=t),n.push([s,r]),s=r;return n}function zC(t){const e=[];t instanceof _t&&(t=[t]);for(let n=0;n<t.length;++n){const s=t[n];if(s.rank===1)e.push(Tl(s,1));else{if(s.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(s)}}return e}function Os(t,e){if(t==null)return;const n=[];if(e instanceof _t)n.push(e.id);else if(Array.isArray(e))e.forEach(r=>n.push(r.id));else if(e!=null)for(const r in e){const a=e[r];n.push(a.id)}const s=[];if(t instanceof _t)n.indexOf(t.id)===-1&&s.push(t);else if(Array.isArray(t))t.forEach(r=>{n.indexOf(r.id)===-1&&s.push(r)});else if(t!=null)for(const r in t){const a=t[r];n.indexOf(a.id)===-1&&s.push(a)}s.forEach(r=>{r.isDisposed||r.dispose()})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function x6(t){return t instanceof _t}function zm(t){return Array.isArray(t)}function L1(t){return!x6(t)&&!zm(t)}function P1(t,e,n,s=!0,r=""){if(e==null||e.length===0){if(t!=null){let i=!1;if(zm(t)&&t.length>0)i=!0;else if(L1(t)){for(const o in t)if(t.hasOwnProperty(o)){i=!0;break}}else i=!0;if(i)throw new X(`Error when checking model ${r} expected no data, but got ${t}`)}return[]}if(t==null)return e.map(i=>null);let a;if(L1(t)){t=t,a=[];for(const i of e){if(t[i]==null)throw new X(`No data provided for "${i}". Need data for each key in: ${e}`);a.push(t[i])}}else if(zm(t)){if(t=t,t.length!==e.length)throw new X(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${t}`);a=t}else{if(t=t,e.length>1)throw new X(`The model ${r} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${t.shape}`);a=[t]}if(a=zC(a),n!=null)for(let i=0;i<e.length;++i){if(n[i]==null)continue;const o=a[i];if(o.shape.length!==n[i].length)throw new X(`Error when checking ${r}: expected ${e[i]} to have ${n[i].length} dimension(s). but got array with shape ${o.shape}`);for(let u=0;u<n[i].length;++u){if(u===0&&!s)continue;const l=o.shape[u],c=n[i][u];if(c!=null&&c>=0&&l!==c)throw new X(`${r} expected a batch of elements where each example has shape [${n[i].slice(1,n[i].length)}] (i.e.,tensor shape [*,${n[i].slice(1,n[i].length)}]) but the ${r} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return a}function w6(t,e,n){const s=ta(t.map(a=>a.shape[0]));s.sort();const r=ta(e.map(a=>a.shape[0]));if(r.sort(),s.length>1)throw new X(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(a=>a.shape))}`);if(r.length>1)throw new X(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(a=>a.shape))}`);if(s.length>0&&r.length>0&&!tt(s,r))throw new X(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${r[0]} target sample(s).`)}function $6(t,e,n){const s=[Jh,ep,du];for(let r=0;r<t.length;++r){const a=t[r],i=e[r],o=n[r];if(i!=null){if(i===du&&a.shape[a.shape.length-1]===1)throw new X(`You are passing a target array of shape ${a.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(s.indexOf(i)!==-1){const u=a.shape.slice(1),l=o.slice(1);for(let c=0;c<u.length;++c){const d=u[c],h=l[c];if(h!=null&&d!==h)throw new X(`A target Tensor with shape ${a.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function B1(t,e,n,s=!0,r=""){let a;if(Array.isArray(t)){if(t.length!==e.length)throw new X(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${t.length} Tensors(s).`);a=t}else{if(e.length>1)throw new X(`The model expects ${e.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(t.shape)}.`);a=[t]}if(n!=null)for(let i=0;i<e.length;++i){if(n[i]==null)continue;const o=a[i];if(o.shape.length!==n[i].length)throw new X(`Error when checking ${r}: expected ${e[i]} to have ${n[i].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let u=0;u<n[i].length;++u){if(u===0&&!s)continue;const l=o.shape[u],c=n[i][u];if(c!=null&&c!==l)throw new X(`Error when checking ${r}: expected ${e[i]} to have shape ${JSON.stringify(n[i])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}function v6(t,e){if(t==null||Array.isArray(t)&&t.length===0)return e.map(s=>[]);let n;if(typeof t=="string"||typeof t=="function")n=[t];else if(Array.isArray(t)||typeof t=="object")n=t;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${t}`);if(Array.isArray(n))return e.map(s=>n);{const s=[];for(const r of e){let a=n.hasOwnProperty(r)?n[r]:[];Array.isArray(a)||(a=[a]),s.push(a)}return s}}const S6="layers-model";class Gi extends Ms{constructor(e){super(e),this.isTraining=!1}summary(e,n,s=console.log){if(!this.built)throw new X("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");a6(this,e,n,s)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=r6(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof va))throw new X("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let n=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(const i in e.loss)if(this.outputNames.indexOf(i)===-1)throw new X(`Unknown entry in loss dictionary: "${i}". Only expected the following keys: ${this.outputNames}`);for(const i of this.outputNames)e.loss[i]==null&&console.warn(`Output "${i}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${i} during training`),n.push(Kp(e.loss[i]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new X(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);n=e.loss.map(o=>Kp(o))}else{const i=Kp(e.loss);this.outputs.forEach(o=>{n.push(i)})}this.lossFunctions=n,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let i=0;i<this.outputs.length;++i){const o=this.internalOutputShapes[i],u=this.outputNames[i];this.feedOutputNames.push(u),this.feedOutputShapes.push(o),this.feedLossFns.push(this.lossFunctions[i])}const s=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],ja("loss",()=>{for(let i=0;i<this.outputs.length;++i){if(s.indexOf(i)!==-1)continue;const o=this.lossFunctions[i];this.outputs.length>1&&(this.metricsTensors.push([o,i]),this.metricsNames.push(this.outputNames[i]+"_loss"))}});const r=v6(e.metrics,this.outputNames),a=(i,o,u)=>{this.outputNames.length>1&&(o=this.outputNames[i]+"_"+o),this.metricsNames.push(o),this.metricsTensors.push([u,i])};ja("metric",()=>{for(let i=0;i<this.outputs.length;++i){if(s.indexOf(i)!==-1)continue;const o=r[i];(l=>{let d,h,p;for(const f of l){if(typeof f=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(f)!==-1){const g=this.internalOutputShapes[i];g[g.length-1]===1||this.lossFunctions[i]===ep?["accuracy","acc"].indexOf(f)!==-1?h=CC:["crossentropy","ce"].indexOf(f)!==-1&&(h=Kq):this.lossFunctions[i]===Zc?["accuracy","acc"].indexOf(f)!==-1?h=Xq:["crossentropy","ce"].indexOf(f)!==-1&&(h=EC):["accuracy","acc"].indexOf(f)!==-1?h=TC:["crossentropy","ce"].indexOf(f)!==-1&&(h=NC);let y;["accuracy","acc"].indexOf(f)!==-1?y="acc":["crossentropy","ce"].indexOf(f)!==-1&&(y="ce"),p=h,d=""+y}else p=s6(f),d=""+tc(f);let m;ja(d,()=>{m=p}),a(i,d,m)}})(o)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,n,s={}){const r=s.batchSize==null?32:s.batchSize;Xp(r);const i=this.standardizeUserDataXY(e,n,!0,r);try{const o=i[0].concat(i[1]);this.makeTestFunction();const u=this.testFunction,l=this.testLoop(u,o,r,s.verbose,s.steps);return Dn(l)}finally{Os(i[0],e),Os(i[1],n)}}async evaluateDataset(e,n){return this.makeTestFunction(),b6(this,e,n)}checkNumSamples(e,n,s,r="steps"){let a;if(s!=null){if(a=null,n!=null)throw new X(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${n}`)}else if(e!=null)Array.isArray(e)?a=e[0].shape[0]:a=e.shape[0];else throw new X(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return a}execute(e,n){if(Array.isArray(n)&&n.length===0)throw new X("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(n),r=s?n:[n],a=this.retrieveSymbolicTensors(r),i=new Zr;if(e instanceof _t&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new X(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let u=0;u<this.inputs.length;++u)i.add(this.inputs[u],e[u])}else for(const u of this.inputs){const l=e[u.name];if(l==null)throw new X(`No value is provided for the model's input ${u.name}`);i.add(u,l)}const o=qo(a,i);return s?o:o[0]}retrieveSymbolicTensors(e){const n=oi(null,e.length);let s=e.length;for(const r of this.layers){const a=Array.isArray(r.output)?r.output:[r.output],i=a.map(o=>o.name);for(let o=0;o<e.length;++o){const u=i.indexOf(e[o]);if(u!==-1&&(n[o]=a[u],s--),s===0)break}if(s===0)break}if(s>0){const r=[];throw n.forEach((a,i)=>{a==null&&r.push(e[i])}),new X(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return n}predictLoop(e,n=32,s=!1){return ee(()=>{const r=this.checkNumSamples(e);if(s)throw new He("Verbose predictLoop() is not implemented yet.");const a=Yp(r,n),i=this.outputs.map(o=>[]);for(let o=0;o<a.length;++o)ee(()=>{const l=a[o][0],c=a[o][1],d=Eo(e,l,c),h=[];if(Array.isArray(d))for(let f=0;f<d.length;++f)h.push({key:this.inputs[f],value:d[f]});else h.push({key:this.inputs[0],value:d});const p=new Zr(h);return qo(this.outputs,p)}).forEach((l,c)=>i[c].push(l));return Dn(i.map(o=>Wt(o,0)))})}predict(e,n={}){const s=zC(e);B1(s,this.inputNames,this.feedInputShapes,!1);try{const r=n.batchSize==null?32:n.batchSize;return Xp(r),this.predictLoop(s,r)}finally{Os(s,e)}}predictOnBatch(e){B1(e,this.inputNames,this.feedInputShapes,!0);const n=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,n)}standardizeUserDataXY(e,n,s=!0,r){if(this.optimizer_==null)throw new bs("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const a=[];for(let i=0;i<this.feedOutputShapes.length;++i){const o=this.feedOutputShapes[i];this.feedLossFns[i]===Zc?a.push(o.slice(0,o.length-1).concat([1])):a.push(o)}if(e=P1(e,this.feedInputNames,this.feedInputShapes,!1,"input"),n=P1(n,this.feedOutputNames,a,!1,"target"),w6(e,n),$6(n,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&e[0].shape[0]%r!==0)throw new X(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,n]}async standardizeUserData(e,n,s,r,a=!0,i){const[o,u]=this.standardizeUserDataXY(e,n,a,i);if(s!=null)throw new Error("sample weight is not supported yet.");let l=null;if(r!=null){const c=DC(r,this.outputNames);l=[];for(let d=0;d<c.length;++d)l.push(await OC(u[d],null,c[d]))}return[o,u,l]}testLoop(e,n,s,r=0,a){return ee(()=>{const i=this.checkNumSamples(n,s,a,"steps"),o=[];if(r>0)throw new He("Verbose mode is not implemented yet.");if(a!=null)throw new He("steps mode in testLoop() is not implemented yet");{const u=Yp(i,s),l=Cn(Xs(0,i));for(let c=0;c<u.length;++c){const d=u[c][0],h=u[c][1],p=Ka(l,d,h-d),f=Fm(n,p),m=e(f);if(c===0)for(let g=0;g<m.length;++g)o.push(Re(0));for(let g=0;g<m.length;++g){const y=m[g];o[g]=le(o[g],j(h-d,y))}}for(let c=0;c<o.length;++c)o[c]=Te(o[c],i)}return o})}getDedupedMetricsNames(){const e=this.metricsNames,n=[];for(let s=0;s<e.length;++s){const r=e[s];let a=r;if(S1(e,r)>1){const i=S1(e.slice(0,s),r);a+=`_${i}`}n.push(a)}return n}makeTrainFunction(){return e=>{const n=[],s=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),i=[],o=()=>{const d=[];for(let m=0;m<this.inputs.length;++m)d.push({key:this.inputs[m],value:s[m]});const h=new Zr(d),p=qo(this.outputs,h,{training:!0});let f;for(let m=0;m<this.lossFunctions.length;++m){const g=this.lossFunctions[m];let y=g(r[m],p[m]);a[m]!=null&&(y=h6(y,a[m]));const b=Rt(y);n.push(b),m===0?f=y:f=le(f,y)}for(let m=0;m<this.metricsTensors.length;++m){let g;if(this.outputs.length>1&&m<this.outputs.length)g=n[m];else{const y=this.metricsTensors[m][0],b=this.metricsTensors[m][1];g=Rt(y(r[b],p[b]))}tn(g),i.push(g)}return f=Rt(f),this.calculateLosses().forEach(m=>{f=le(f,m)}),f},u=this.collectedTrainableWeights.map(d=>d.read());return[this.optimizer_.minimize(o,!0,u)].concat(i)}}makeTestFunction(){this.testFunction=e=>ee(()=>{const n=[];let s;const r=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=[];for(let l=0;l<this.inputs.length;++l)i.push({key:this.inputs[l],value:r[l]});const o=new Zr(i),u=qo(this.outputs,o);for(let l=0;l<this.lossFunctions.length;++l){const c=this.lossFunctions[l],d=Rt(c(a[l],u[l]));l===0?s=d:s=le(s,d),n.push(s)}for(let l=0;l<this.metricsTensors.length;++l){const c=this.metricsTensors[l][0],d=this.metricsTensors[l][1],h=Rt(c(a[d],u[d]));n.push(h)}return n})}async fit(e,n,s={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let r,a,i,o,u,l,c,d,h;try{const p=s.batchSize==null?32:s.batchSize;Xp(p);const m=await this.standardizeUserData(e,n,s.sampleWeight,s.classWeight,!1,p);r=m[0],a=m[1],h=m[2];let g=!1,y;if(s.validationData!=null&&s.validationData.length>0){if(g=!0,s.validationData.length===2)u=s.validationData[0],l=s.validationData[1];else throw s.validationData.length===3?new He("validationData including sample weights is not supported yet."):new X(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);const I=await this.standardizeUserData(u,l,null,null,!0,p);c=I[0],d=I[1],y=c.concat(d)}else if(s.validationSplit!=null&&s.validationSplit>0&&s.validationSplit<1){g=!0;const A=Math.floor(r[0].shape[0]*(1-s.validationSplit)),I=r[0].shape[0];c=Eo(r,A,I),i=r,r=Eo(r,0,A),d=Eo(a,A,I),o=a,a=Eo(a,0,A),y=c.concat(d)}else s.validationSteps!=null&&(g=!0);const b=r.concat(a).concat(h);this.checkTrainableWeightsConsistency();const $=this.makeTrainFunction(),w=this.getDedupedMetricsNames();let v,k;g?(this.makeTestFunction(),v=this.testFunction,k=w.slice().concat(w.map(A=>"val_"+A))):(v=null,y=[],k=w.slice());const C=IC(s.callbacks,s.yieldEvery);return await this.fitLoop($,b,w,p,s.epochs,s.verbose,C,v,y,s.shuffle,k,s.initialEpoch,null,null)}finally{this.isTraining=!1,Os(r,e),Os(a,n),Os(i,e),Os(o,n),Os(c,u),Os(d,l),h!=null&&Ve(h)}}async fitLoop(e,n,s,r,a,i,o,u,l,c,d,h,p,f){r==null&&(r=32),a==null&&(a=1),c==null&&(c=!0),h==null&&(h=0);let m=!1;if(u!=null&&l!=null&&(m=!0),f!=null&&(m=!0,p==null))throw new X("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const g=this.checkNumSamples(n,r,p,"steps_per_epoch");let y;g!=null&&(y=Xs(0,g)),i==null&&(i=1);const{callbackList:b,history:$}=_C(o,i,a,h,g,p,r,m,d);b.setModel(this),this.history=$,await b.onTrainBegin(),this.stopTraining_=!1;for(let w=h;w<a;++w){await b.onEpochBegin(w);const v={};if(p!=null)throw new He("stepsPerEpoch mode is not implemented yet.");{if(c==="batch")throw new He("batch shuffling is not implemneted yet");c&&dz(y);const k=Cn(y),C=Yp(g,r);for(let N=0;N<C.length;++N){const A={};if(await b.onBatchBegin(N,A),ee(()=>{const I=C[N][0],E=C[N][1],z=Ka(k,I,E-I);A.batch=N,A.size=E-I;const P=Fm(n,z),H=e(P);for(let G=0;G<s.length;++G){const W=s[G],L=H[G];A[W]=L,tn(L)}if(N===C.length-1&&m){const G=this.testLoop(u,l,r);for(let W=0;W<s.length;++W){const L=s[W],B=G[W];tn(B),v["val_"+L]=B}}}),await b.onBatchEnd(N,A),SC(A),this.stopTraining_)break}k.dispose()}if(await b.onEpochEnd(w,v),this.stopTraining_)break}return await b.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,n){return m6(this,e,n)}async trainOnBatch(e,n){const s=await this.standardizeUserData(e,n),r=s[0],a=s[1],o=this.makeTrainFunction()(r.concat(a)),u=[];for(const l of o){const c=await l.data();u.push(c[0])}return Ve(o),Os(s[0],e),Os(s[1],n),Dn(u)}getNamedWeights(e){const n=[],s=e!=null&&e.trainableOnly,r=s?this.trainableWeights:this.weights,a=this.getWeights(s);for(let i=0;i<r.length;++i)s&&!r[i].trainable||n.push({name:r[i].originalName,tensor:a[i]});return n}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const n=Qw().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=n-Qw().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=Sr(this.loss);else if(Array.isArray(this.loss)){for(const n of this.loss)if(typeof n!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(n=>Sr(n))}else{const n=Object.keys(this.loss);e={};const s=this.loss;for(const r of n)if(typeof s[r]=="string")e[r]=Sr(s[r]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Sr(tc(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Sr(tc(e)));{const e={};for(const n in this.metrics)e[n]=Sr(tc(this.metrics[n]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const n=Dm(e.optimizer_config),s=Nr(n);let r;if(typeof e.loss=="string")r=Ba(e.loss);else if(Array.isArray(e.loss))r=e.loss.map(i=>Ba(i));else if(e.loss!=null){r={};for(const i in e.loss)r[i]=Ba(e.loss[i])}let a;if(Array.isArray(e.metrics))a=e.metrics.map(i=>Ba(i));else if(e.metrics!=null){a={};for(const i in e.metrics)a[i]=Ba(e.metrics[i])}this.compile({loss:r,metrics:a,optimizer:s})}async save(e,n){if(typeof e=="string"){const l=qI(e);if(l.length===0)throw new X(`Cannot find any save handlers for URL '${e}'`);if(l.length>1)throw new X(`Found more than one (${l.length}) save handlers for URL '${e}'`);e=l[0]}if(e.save==null)throw new X("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=await gm(this.getNamedWeights(n)),o={modelTopology:this.toJSON(null,!1),format:S6,generatedBy:`TensorFlow.js tfjs-layers v${RC}`,convertedBy:null};if((n==null?!1:n.includeOptimizer)&&this.optimizer!=null){o.trainingConfig=this.getTrainingConfig();const l="optimizer",{data:c,specs:d}=await gm(await this.optimizer.getWeights(),l);s.specs.push(...d),s.data=UI([s.data,c])}return this.userDefinedMetadata!=null&&(O1(this.userDefinedMetadata,this.name,!0),o.userDefinedMetadata=this.userDefinedMetadata),o.weightData=s.data,o.weightSpecs=s.specs,e.save(o)}setUserDefinedMetadata(e){O1(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}Gi.className="Model";ce(Gi);class LC extends Gi{}LC.className="Functional";ce(LC);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class hu extends Gi{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:Yh("sequential_"),e.layers!=null)for(const n of e.layers)this.add(n)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new X(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const n=e instanceof hu||e instanceof Gi;let s;if(n){if(s=e,s.outputs.length!==1)throw new X("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(s.inputs.length!==1)throw new X("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new X("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const r=_q({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(r)}if(n)this.outputs=s.outputs,this.inputs=s.inputs;else{if(e.inboundNodes.length!==1)throw new X(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new X("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=bC(this.outputs[0])}this.inboundNodes=[],new Qh({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:oi(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{const r=e.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,n){return this.model==null&&this.build(),this.model.call(e,n)}build(e){if(ut(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Gi({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,n,s=console.log){this.built||this.build(),super.summary(e,n,s)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,n,s={}){if(!this.built)throw new bs("The model needs to be compiled before being used.");return this.model.evaluate(e,n,s)}async evaluateDataset(e,n){if(!this.built)throw new bs("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,n)}predict(e,n={}){return this.model==null&&this.build(),this.model.predict(e,n)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,n,s={}){if(!this.built)throw new bs("The model needs to be compiled before being used.");return this.model.fit(e,n,s)}async fitDataset(e,n){if(!this.built)throw new bs("The model needs to be compiled before being used.");return this.model.fitDataset(e,n)}async trainOnBatch(e,n){return this.model.trainOnBatch(e,n)}static fromConfig(e,n,s={},r=!1){let a,i={};if(n instanceof Array){if(n[0].className==null||n[0].className==="Merge")throw new X("Legacy serialization format not supported yet.");a=n}else O(n.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),a=n.layers,delete n.layers,i=n;const o=new e(i);if(!(o instanceof hu))throw new He(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(const u of a){const c=Nr(u,void 0,r);r&&c.setFastWeightInitDuringBuild(!0),o.add(c)}return o}set stopTraining(e){if(this.model==null)throw new X("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new X("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const n of this.layers){const s={};s.className=n.getClassName(),s.config=n.getConfig(),e.push(s)}return{name:this.name,layers:e}}}hu.className="Sequential";ce(hu);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let wn=class extends mo{getConfig(){return{}}};class PC extends wn{apply(e,n=1){return lq(e,n)}}PC.className="elu";ce(PC);class BC extends wn{apply(e){return jy(e)}}BC.className="selu";ce(BC);class MC extends wn{apply(e){return xr(e)}}MC.className="relu";ce(MC);class VC extends wn{apply(e){return ee(()=>ai(6,xr(e)))}}VC.className="relu6";ce(VC);class WC extends wn{apply(e){return e}}WC.className="linear";ce(WC);class UC extends wn{apply(e){return dr(e)}}UC.className="sigmoid";ce(UC);class GC extends wn{apply(e){return dq(e)}}GC.className="hardSigmoid";ce(GC);class HC extends wn{apply(e){return ho(e)}}HC.className="softplus";ce(HC);class qC extends wn{apply(e){return cq(e)}}qC.className="softsign";ce(qC);class jC extends wn{apply(e){return ri(e)}}jC.className="tanh";ce(jC);let Jb=class extends wn{apply(e,n=-1){return Bh(e,n)}};Jb.className="softmax";ce(Jb);class KC extends wn{apply(e,n=-1){return Py(e,n)}}KC.className="logSoftmax";ce(KC);class XC extends wn{apply(e){return ee(()=>ee(()=>{const n=Math.sqrt(2),s=j(.5,le(1,Fy(Te(e,n))));return j(e,s)}))}}XC.className="gelu";ce(XC);class YC extends wn{apply(e){return ee(()=>j(.5,j(e,le(1,ri(j(hn(Te(2,Math.PI)),le(e,j(.044715,Er(e,3)))))))))}}YC.className="gelu_new";ce(YC);class ZC extends wn{apply(e){return ee(()=>j(e,ri(ho(e))))}}ZC.className="mish";ce(ZC);class QC extends wn{apply(e,n=1){return ee(()=>j(dr(j(e,n)),e))}}QC.className="swish";ce(QC);function la(t){return t.getClassName()}function Zp(t,e={}){return Cl(t,ms.getMap().classNameMap,e,"activation")}function ca(t){if(t==null){const e={};return e.className="linear",e.config={},Zp(e)}if(typeof t=="string"){const e={};return e.className=t,e.config={},Zp(e)}else return t instanceof wn?t:Zp(t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function I6(t){if(t!=null&&typeof t!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${t}`)}class JC extends mo{}class eT extends JC{constructor(e){super(),I6(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return ee(()=>{let n=Gt([1]);return this.hasL1&&(n=le(n,Ie(j(this.l1,Ut(e))))),this.hasL2&&(n=le(n,Ie(j(this.l2,Nl(e))))),K(n,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,n){return new e({l1:n.l1,l2:n.l2})}}eT.className="L1L2";ce(eT);const M1={l1l2:"L1L2"};function wt(t){return Bb(t)}function V1(t,e={}){return Cl(t,ms.getMap().classNameMap,e,"regularizer")}function Ct(t){if(t==null)return null;if(typeof t=="string"){const n={className:t in M1?M1[t]:t,config:{}};return V1(n)}else return t instanceof JC?t:V1(t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class tT extends Ze{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,n){e=Pe(e);let s=xr(e);return this.maxValue!=null&&(s=qn(s,0,this.maxValue)),s}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},n=super.getConfig();return Object.assign(e,n),e}}tT.className="ReLU";ce(tT);class nT extends Ze{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,n){const s=Pe(e);return Th(s,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},n=super.getConfig();return Object.assign(e,n),e}}nT.className="LeakyReLU";ce(nT);class sT extends Ze{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=kt(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Ct(e.alphaRegularizer),this.alphaConstraint=Xt(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new X(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=ut(e);const n=e.slice(1);if(this.sharedAxes!=null)for(const r of this.sharedAxes)n[r-1]=1;this.alpha=this.addWeight("alpha",n,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(this.sharedAxes!=null)for(let r=1;r<e.length;++r)s[r]=e[r];this.inputSpec=[new qt({ndim:e.length,axes:s})],this.built=!0}call(e,n){return e=Pe(e),Fh(e,this.alpha.read())}getConfig(){const e={alphaInitializer:Et(this.alphaInitializer),alphaRegularizer:wt(this.alphaRegularizer),alphaConstraint:Kt(this.alphaConstraint),sharedAxes:this.sharedAxes},n=super.getConfig();return Object.assign(e,n),e}}sT.className="PReLU";ce(sT);let rT=class extends Ze{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new He(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,n){const s=Pe(e);return wl(s)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},n=super.getConfig();return Object.assign(e,n),e}};rT.className="ELU";ce(rT);class aT extends Ze{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,n){const s=Pe(e);return j(s,ge(Qn(s,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},n=super.getConfig();return Object.assign(e,n),e}}aT.className="ThresholdedReLU";ce(aT);class iT extends Ze{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new Jb().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,n){return ee(()=>{let s=Pe(e);const r=n.mask;if(r!=null){const a=j(we(Un(s.shape),ge(r,s.dtype)),Re(-1e9));s=le(s,a)}return this.axis instanceof Array?this.axis.length>1?jn(we(s,Eh(s,this.axis,!0))):this.softmax(s,this.axis[0]):this.softmax(s,this.axis)})}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},n=super.getConfig();return Object.assign(e,n),e}}iT.className="Softmax";ce(iT);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Hi(t,e,n){if(typeof t=="number")return oi(t,e);if(t.length!==e)throw new X(`The ${n} argument must be an integer or tuple of ${e} integers. Received: ${t.length} elements.`);for(let s=0;s<e;++s){const r=t[s];if(!aq(r))throw new X(`The ${n} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(t)} including a non-integer number ${r}`)}return t}function qs(t,e,n,s,r=1){if(t==null)return t;const a=e+(e-1)*(r-1);let i;return n==="same"?i=t:i=t-a+1,Math.floor((i+s-1)/s)}function ur(t,e,n,s){if(t==null)return null;if(s==="valid")t=t*e+ua([n-e,0]);else if(s==="same")t=t*e;else throw new X(`Unsupport padding mode: ${s}.`);return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function e0(t,e){return ee(()=>(Bt(e),e==="channelsFirst"?st(t,[0,2,3,1]):t))}function oT(t,e){return ee(()=>(Bt(e),e==="channelsFirst"?st(t,[0,2,3,4,1]):t))}function _6(t,e,n,s=1,r="valid",a,i=1){return ee(()=>{if(a==null&&(a=Ys()),Bt(a),t.shape.length!==3)throw new X(`The input of a conv1dWithBias operation should be 3, but is ${t.shape.length} instead.`);if(e.shape.length!==3)throw new X(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(n!=null&&n.shape.length!==1)throw new X(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if(a==="channelsFirst"&&(t=st(t,[0,2,1])),r==="causal")throw new He("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=Ey(t,e,s,r==="same"?"same":"valid","NWC",i);return n!=null&&(o=Js(o,n)),o})}function W1(t,e,n,s=[1,1],r="valid",a,i,o=null){return ee(()=>{if(a==null&&(a=Ys()),Bt(a),t.rank!==3&&t.rank!==4)throw new X(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${t.rank}.`);if(e.rank!==3&&e.rank!==4)throw new X(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${t.rank}.`);let u=e0(t,a);if(r==="causal")throw new He("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return u=J_({x:u,filter:e,strides:s,pad:r==="same"?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),a==="channelsFirst"&&(u=st(u,[0,3,1,2])),u})}function k6(t,e,n,s=[1,1,1],r="valid",a,i){return ee(()=>{if(a==null&&(a=Ys()),Bt(a),t.rank!==4&&t.rank!==5)throw new X(`conv3dWithBias expects input to be of rank 4 or 5, but received ${t.rank}.`);if(e.rank!==4&&e.rank!==5)throw new X(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${t.rank}.`);let o=oT(t,a);if(r==="causal")throw new He("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=x_(o,e,s,r==="same"?"same":"valid","NDHWC",i),n!=null&&(o=Js(o,n)),a==="channelsFirst"&&(o=st(o,[0,4,1,2,3])),o})}class tp extends Ze{constructor(e,n){if(super(n),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",tp.verifyArgs(n),this.rank=e,nn(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new He(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Hi(n.kernelSize,e,"kernelSize"),this.strides=Hi(n.strides==null?1:n.strides,e,"strides"),this.padding=n.padding==null?"valid":n.padding,os(this.padding),this.dataFormat=n.dataFormat==null?"channelsLast":n.dataFormat,Bt(this.dataFormat),this.activation=ca(n.activation),this.useBias=n.useBias==null?!0:n.useBias,this.biasInitializer=kt(n.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Xt(n.biasConstraint),this.biasRegularizer=Ct(n.biasRegularizer),this.activityRegularizer=Ct(n.activityRegularizer),this.dilationRate=Hi(n.dilationRate==null?1:n.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new X(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new X(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new X(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(or("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!Mb(e.kernelSize,"number",1,3))throw new X(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:la(this.activation),useBias:this.useBias,biasInitializer:Et(this.biasInitializer),biasRegularizer:wt(this.biasRegularizer),activityRegularizer:wt(this.activityRegularizer),biasConstraint:Kt(this.biasConstraint)},n=super.getConfig();return Object.assign(e,n),e}}class go extends tp{constructor(e,n){super(e,n),this.kernel=null,go.verifyArgs(n),this.filters=n.filters,nn(this.filters,"filters"),this.kernelInitializer=kt(n.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Xt(n.kernelConstraint),this.kernelRegularizer=Ct(n.kernelRegularizer)}build(e){e=ut(e);const n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new X(`The channel dimension of the input should be defined. Found ${e[n]}`);const s=e[n],r=this.kernelSize.concat([s,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[n]:s}}],this.built=!0}call(e,n){return ee(()=>{e=Pe(e);let s;const r=this.bias==null?null:this.bias.read(),a=sC(this.activation.getClassName());if(a!=null&&this.rank===2)s=W1(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,a);else{if(this.rank===1)s=_6(e,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)s=W1(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)s=k6(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new He("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(s=this.activation.apply(s))}return s})}computeOutputShape(e){e=ut(e);const n=[],s=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let a=0;a<s.length;++a){const i=qs(s[a],this.kernelSize[a],this.padding,this.strides[a],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[a]);n.push(i)}let r=[e[0]];return this.dataFormat==="channelsLast"?(r=r.concat(n),r.push(this.filters)):(r.push(this.filters),r=r.concat(n)),r}getConfig(){const e={filters:this.filters,kernelInitializer:Et(this.kernelInitializer),kernelRegularizer:wt(this.kernelRegularizer),kernelConstraint:Kt(this.kernelConstraint)},n=super.getConfig();return Object.assign(e,n),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new X(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class Dl extends go{constructor(e){super(2,e),Dl.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!Mb(e.kernelSize,"number",1,2))throw new X(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}Dl.className="Conv2D";ce(Dl);class Ol extends go{constructor(e){super(3,e),Ol.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new X(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}Ol.className="Conv3D";ce(Ol);class uT extends Dl{constructor(e){if(super(e),this.inputSpec=[new qt({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new X(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=ut(e),e.length!==4)throw new X("Input should have rank 4; Received input shape: "+JSON.stringify(e));const n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new X("The channel dimension of the inputs should be defined. Found `None`.");const s=e[n],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new qt({ndim:4,axes:{[n]:s}})],this.built=!0}call(e,n){return ee(()=>{let s=Pe(e);if(s.shape.length!==4)throw new X(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,a=r[0];let i,o;this.dataFormat==="channelsFirst"?(i=2,o=3):(i=1,o=2);const u=r[i],l=r[o],c=this.kernelSize[0],d=this.kernelSize[1],h=this.strides[0],p=this.strides[1],f=ur(u,h,c,this.padding),m=ur(l,p,d,this.padding),g=[a,f,m,this.filters];this.dataFormat!=="channelsLast"&&(s=st(s,[0,2,3,1]));let y=Ry(s,this.kernel.read(),g,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(y=st(y,[0,3,1,2])),this.bias!=null&&(y=Js(y,this.bias.read(),this.dataFormat)),this.activation!=null&&(y=this.activation.apply(y)),y})}computeOutputShape(e){e=ut(e);const n=e.slice();let s,r,a;this.dataFormat==="channelsFirst"?(s=1,r=2,a=3):(s=3,r=1,a=2);const i=this.kernelSize[0],o=this.kernelSize[1],u=this.strides[0],l=this.strides[1];return n[s]=this.filters,n[r]=ur(n[r],u,i,this.padding),n[a]=ur(n[a],l,o,this.padding),n}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}uT.className="Conv2DTranspose";ce(uT);class lT extends Ol{constructor(e){if(super(e),this.inputSpec=[new qt({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new X(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=ut(e),e.length!==5)throw new X("Input should have rank 5; Received input shape: "+JSON.stringify(e));const n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new X("The channel dimension of the inputs should be defined. Found `None`.");const s=e[n],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new qt({ndim:5,axes:{[n]:s}})],this.built=!0}call(e,n){return ee(()=>{let s=Pe(e);if(s.shape.length!==5)throw new X(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,a=r[0];let i,o,u;this.dataFormat==="channelsFirst"?(u=2,i=3,o=4):(u=1,i=2,o=3);const l=r[u],c=r[i],d=r[o],h=this.kernelSize[0],p=this.kernelSize[1],f=this.kernelSize[2],m=this.strides[0],g=this.strides[1],y=this.strides[2],b=ur(l,m,h,this.padding),$=ur(c,g,p,this.padding),w=ur(d,y,f,this.padding),v=[a,b,$,w,this.filters];this.dataFormat!=="channelsLast"&&(s=st(s,[0,2,3,4,1]));let k=$_(s,this.kernel.read(),v,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(k=st(k,[0,4,1,2,3])),this.bias!==null&&(k=Js(k,this.bias.read(),this.dataFormat)),this.activation!==null&&(k=this.activation.apply(k)),k})}computeOutputShape(e){e=ut(e);const n=e.slice();let s,r,a,i;this.dataFormat==="channelsFirst"?(s=1,r=2,a=3,i=4):(s=4,r=1,a=2,i=3);const o=this.kernelSize[0],u=this.kernelSize[1],l=this.kernelSize[2],c=this.strides[0],d=this.strides[1],h=this.strides[2];return n[s]=this.filters,n[r]=ur(n[r],c,o,this.padding),n[a]=ur(n[a],d,u,this.padding),n[i]=ur(n[i],h,l,this.padding),n}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}lT.className="Conv3DTranspose";ce(lT);class cT extends go{constructor(e,n){if(super(e,n),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,n.filters==null)throw new X("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(n.kernelInitializer!=null||n.kernelRegularizer!=null||n.kernelConstraint!=null)throw new X("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(n.padding!=null&&n.padding!=="same"&&n.padding!=="valid")throw new X(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(n.padding)}`);this.depthMultiplier=n.depthMultiplier==null?1:n.depthMultiplier,this.depthwiseInitializer=kt(n.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Ct(n.depthwiseRegularizer),this.depthwiseConstraint=Xt(n.depthwiseConstraint),this.pointwiseInitializer=kt(n.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Ct(n.pointwiseRegularizer),this.pointwiseConstraint=Xt(n.pointwiseConstraint)}build(e){if(e=ut(e),e.length<this.rank+2)throw new X(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null||e[n]<0)throw new X(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[n])}`);const s=e[n],r=this.kernelSize.concat([s,this.depthMultiplier]),a=[];for(let o=0;o<this.rank;++o)a.push(1);a.push(s*this.depthMultiplier,this.filters);const i=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,i,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,i,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,i,this.biasConstraint):this.bias=null,this.inputSpec=[new qt({ndim:this.rank+2,axes:{[n]:s}})],this.built=!0}call(e,n){return ee(()=>{e=Pe(e);let s;if(this.rank===1)throw new He("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=st(e,[0,2,3,1])),s=Ky(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=Js(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),this.dataFormat==="channelsFirst"&&(s=st(s,[0,3,1,2])),s})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Et(this.depthwiseInitializer),e.pointwiseInitializer=Et(this.pointwiseInitializer),e.depthwiseRegularizer=wt(this.depthwiseRegularizer),e.pointwiseRegularizer=wt(this.pointwiseRegularizer),e.depthwiseConstraint=Kt(this.depthwiseConstraint),e.pointwiseConstraint=Kt(this.pointwiseConstraint),e}}cT.className="SeparableConv";class dT extends cT{constructor(e){super(2,e)}}dT.className="SeparableConv2D";ce(dT);class np extends go{constructor(e){super(1,e),np.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!Mb(e.kernelSize,"number",1,1))throw new X(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}np.className="Conv1D";ce(np);class hT extends Ze{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,n){return ee(()=>{if(e=Pe(e),this.dataFormat==="channelsLast"){const s=ec(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return ec(s,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const s=ec(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return ec(s,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}}hT.className="Cropping2D";ce(hT);class pT extends Ze{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Bt(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,nq(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){const n=e[2]==null?null:this.size[0]*e[2],s=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],n,s]}else{const n=e[1]==null?null:this.size[0]*e[1],s=e[2]==null?null:this.size[1]*e[2];return[e[0],n,s,e[3]]}}call(e,n){return ee(()=>{let s=Pe(e);const r=s.shape;if(this.dataFormat==="channelsFirst"){s=st(s,[0,2,3,1]);const a=this.size[0]*r[2],i=this.size[1]*r[3],o=this.interpolation==="nearest"?ys.resizeNearestNeighbor(s,[a,i]):ys.resizeBilinear(s,[a,i]);return st(o,[0,3,1,2])}else{const a=this.size[0]*r[1],i=this.size[1]*r[2];return this.interpolation==="nearest"?ys.resizeNearestNeighbor(s,[a,i]):ys.resizeBilinear(s,[a,i])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},n=super.getConfig();return Object.assign(e,n),e}}pT.className="UpSampling2D";ce(pT);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function C6(t,e,n=[1,1],s="valid",r,a){return ee(()=>{r==null&&(r=Ys()),Bt(r);let i=e0(t,r);if(t.rank!==4)throw new X(`Input for depthwiseConv2d is required to be 4-D, but is instead ${t.rank}-D`);if(e.rank!==4)throw new X(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return i=xl(i,e,n,s==="same"?"same":"valid","NHWC",a),r==="channelsFirst"&&(i=st(i,[0,3,1,2])),i})}class fT extends tp{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=kt(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Xt(e.depthwiseConstraint),this.depthwiseRegularizer=Ct(e.depthwiseRegularizer)}build(e){if(e=ut(e),e.length<4)throw new X(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const n=this.dataFormat==="channelsFirst"?1:3;if(e[n]==null||e[n]<0)throw new X(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[n]}).`);const s=e[n],r=[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,n){return ee(()=>{e=Pe(e);let s=C6(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=Js(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),s})}computeOutputShape(e){e=ut(e);const n=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,a=qs(n,this.kernelSize[0],this.padding,this.strides[0]),i=qs(s,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],r,a,i]:[e[0],a,i,r]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Et(this.depthwiseInitializer),e.depthwiseRegularizer=wt(this.depthwiseRegularizer),e.depthwiseConstraint=Kt(this.depthwiseRegularizer),e}}fT.className="DepthwiseConv2D";ce(fT);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function mT(t,e,n,s){if(Array.isArray(t)){if(e!=null||n!=null)throw new X("When inputs is an array, neither initialState or constants should be provided");s!=null&&(n=t.slice(t.length-s,t.length),t=t.slice(0,t.length-s)),t.length>1&&(e=t.slice(1,t.length)),t=t[0]}function r(a){return a==null||Array.isArray(a)?a:[a]}return e=r(e),n=r(n),{inputs:t,initialState:e,constants:n}}function gT(t,e,n,s=!1,r,a,i=!1,o=!1){return ee(()=>{const u=e.shape.length;if(u<3)throw new X(`Input should be at least 3D, but is ${u}D.`);const l=[1,0].concat(Xs(2,u));e=st(e,l),i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),r!=null&&(r=ge(ge(r,"bool"),"float32"),r.rank===u-1&&(r=_n(r,-1)),r=st(r,l)),s&&(e=Ss(e,0),r!=null&&(r=Ss(r,0)));const c=[];let d,h=n;const p=e.shape[0],f=Is(e);let m;r!=null&&(m=Is(r));for(let y=0;y<p;++y){const b=f[y],$=ee(()=>t(b,h));if(r==null)d=$[0],h=$[1];else{const w=ee(()=>{const v=m[y],k=we(as(v),v),C=le(j($[0],v),j(h[0],k)),N=h.map((A,I)=>le(j($[1][I],v),j(A,k)));return{output:C,newStates:N}});d=w.output,h=w.newStates}o&&c.push(d)}let g;return o&&(g=Kn(c,1)),[d,g,h]})}class Sa extends Ze{constructor(e){super(e);let n;if(e.cell==null)throw new X("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?n=new s0({cells:e.cell}):n=e.cell,n.stateSize==null)throw new X("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=n,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new qt({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Xs(0,e).map(n=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){Em(e)&&(e=e[0]),e=e;let n=this.cell.stateSize;Array.isArray(n)||(n=[n]);const s=n[0];let r;if(this.returnSequences?r=[e[0],e[1],s]:r=[e[0],s],this.returnState){const a=[];for(const i of n)a.push([e[0],i]);return[r].concat(a)}else return r}computeMask(e,n){return ee(()=>{Array.isArray(n)&&(n=n[0]);const s=this.returnSequences?n:null;if(this.returnState){const r=this.states.map(a=>null);return[s].concat(r)}else return s})}get states(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,n=[];for(let s=0;s<e;++s)n.push(null);return n}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new He("Constants support is not implemented in RNN yet.");Em(e)&&(e=e[0]),e=e;const n=this.stateful?e[0]:null,s=e.slice(2);this.inputSpec[0]=new qt({shape:[n,null,...s]});const r=[e[0]].concat(e.slice(2));this.cell.build(r);let a;if(Array.isArray(this.cell.stateSize)?a=this.cell.stateSize:a=[this.cell.stateSize],this.stateSpec!=null){if(!tt(this.stateSpec.map(i=>i.shape[i.shape.length-1]),a))throw new X(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(i=>new qt({shape:[null,i]}));this.stateful&&this.resetStates()}resetStates(e,n=!1){ee(()=>{if(!this.stateful)throw new ir("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(s==null)throw new X("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>Gt([s,r])):this.states_=[Gt([s,this.cell.stateSize])];else if(e==null)Ve(this.states_),this.keptStates!=null&&(Ve(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>Gt([s,r])):this.states_[0]=Gt([s,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new X(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);n===!0?this.keptStates.push(this.states_.slice()):Ve(this.states_);for(let r=0;r<this.states_.length;++r){const a=e[r],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,o=[s,i];if(!tt(a.shape,o))throw new X(`State ${r} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${a.shape}`);this.states_[r]=a}}this.states_=this.states_.map(r=>tn(r.clone()))})}apply(e,n){let s=n==null?null:n.initialState,r=n==null?null:n.constants;n==null&&(n={});const a=mT(e,s,r,this.numConstants);e=a.inputs,s=a.initialState,r=a.constants;let i=[],o=[];if(s!=null){n.initialState=s,i=i.concat(s),this.stateSpec=[];for(const l of s)this.stateSpec.push(new qt({shape:l.shape}));o=o.concat(this.stateSpec)}if(r!=null&&(n.constants=r,i=i.concat(r),this.numConstants=r.length),i[0]instanceof gr){const l=[e].concat(i),c=this.inputSpec.concat(o),d=this.inputSpec;this.inputSpec=c;const h=super.apply(l,n);return this.inputSpec=d,h}else return super.apply(e,n)}call(e,n){return ee(()=>{const s=n==null?null:n.mask,r=n==null?null:n.training;let a=n==null?null:n.initialState;e=Pe(e),a==null&&(this.stateful?a=this.states_:a=this.getInitialState(e));const i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==i)throw new X(`RNN Layer has ${i} state(s) but was passed ${a.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const o={training:r},l=gT((f,m)=>{const g=this.cell.call([f].concat(m),o);return[g[0],g.slice(1)]},e,a,this.goBackwards,s,null,this.unroll,this.returnSequences),c=l[0],d=l[1],h=l[2];this.stateful&&this.resetStates(h,r);const p=this.returnSequences?d:c;return this.returnState?[p].concat(h):p})}getInitialState(e){return ee(()=>{let n=Gt(e.shape);return n=Ie(n,[1,2]),n=Tl(n),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?Tm(n,[1,s]):n):this.cell.stateSize>1?[Tm(n,[1,this.cell.stateSize])]:[n]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(n.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===Sa.className&&(n.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),e),n)}static fromConfig(e,n,s={}){const r=n.cell,a=Nr(r,s);return new e(Object.assign(n,{cell:a}))}}Sa.className="RNN";ce(Sa);class sp extends Ze{}class t0 extends sp{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,nn(this.units,"units"),this.activation=ca(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=kt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=kt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=kt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Ct(e.kernelRegularizer),this.recurrentRegularizer=Ct(e.recurrentRegularizer),this.biasRegularizer=Ct(e.biasRegularizer),this.kernelConstraint=Xt(e.kernelConstraint),this.recurrentConstraint=Xt(e.recurrentConstraint),this.biasConstraint=Xt(e.biasConstraint),this.dropout=Qi([1,ua([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Qi([1,ua([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=ut(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,n){return ee(()=>{if(e=e,e.length!==2)throw new X(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let s=e[1];e=e[0];const r=n.training==null?!1:n.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=da({ones:()=>as(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=da({ones:()=>as(s),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let a;const i=this.dropoutMask,o=this.recurrentDropoutMask;i!=null?a=fr(j(e,i),this.kernel.read()):a=fr(e,this.kernel.read()),this.bias!=null&&(a=Js(a,this.bias.read())),o!=null&&(s=j(s,o));let u=le(a,fr(s,this.recurrentKernel.read()));return this.activation!=null&&(u=this.activation.apply(u)),[u,u]})}getConfig(){const e=super.getConfig(),n={units:this.units,activation:la(this.activation),useBias:this.useBias,kernelInitializer:Et(this.kernelInitializer),recurrentInitializer:Et(this.recurrentInitializer),biasInitializer:Et(this.biasInitializer),kernelRegularizer:wt(this.kernelRegularizer),recurrentRegularizer:wt(this.recurrentRegularizer),biasRegularizer:wt(this.biasRegularizer),activityRegularizer:wt(this.activityRegularizer),kernelConstraint:Kt(this.kernelConstraint),recurrentConstraint:Kt(this.recurrentConstraint),biasConstraint:Kt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),n)}}t0.className="SimpleRNNCell";ce(t0);class yT extends Sa{constructor(e){e.cell=new t0(e),super(e)}call(e,n){return ee(()=>{this.cell.dropoutMask!=null&&(Ve(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ve(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=n==null?null:n.mask,r=n==null?null:n.training,a=n==null?null:n.initialState;return super.call(e,{mask:s,training:r,initialState:a})})}static fromConfig(e,n){return new e(n)}}yT.className="SimpleRNN";ce(yT);class n0 extends sp{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new X("GRUCell does not support reset_after parameter set to true.");this.units=e.units,nn(this.units,"units"),this.activation=ca(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=ca(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=kt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=kt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=kt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Ct(e.kernelRegularizer),this.recurrentRegularizer=Ct(e.recurrentRegularizer),this.biasRegularizer=Ct(e.biasRegularizer),this.kernelConstraint=Xt(e.kernelConstraint),this.recurrentConstraint=Xt(e.recurrentConstraint),this.biasConstraint=Xt(e.biasConstraint),this.dropout=Qi([1,ua([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Qi([1,ua([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=ut(e);const n=e[e.length-1];this.kernel=this.addWeight("kernel",[n,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,n){return ee(()=>{if(e=e,e.length!==2)throw new X(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const s=n.training==null?!1:n.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=da({ones:()=>as(e),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=da({ones:()=>as(r),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,i=this.recurrentDropoutMask;let o,u,l;0<this.dropout&&this.dropout<1&&(e=j(e,a[0]));let c=fr(e,this.kernel.read());this.useBias&&(c=Js(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=j(r,i[0]));const d=this.recurrentKernel.read(),[h,p]=Gn(d,[2*this.units,this.units],d.rank-1),f=fr(r,h),[m,g,y]=Gn(c,3,c.rank-1),[b,$]=Gn(f,2,f.rank-1);o=this.recurrentActivation.apply(le(m,b)),u=this.recurrentActivation.apply(le(g,$));const w=fr(j(u,r),p);l=this.activation.apply(le(y,w));const v=le(j(o,r),j(le(1,It(o)),l));return[v,v]})}getConfig(){const e=super.getConfig(),n={units:this.units,activation:la(this.activation),recurrentActivation:la(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Et(this.kernelInitializer),recurrentInitializer:Et(this.recurrentInitializer),biasInitializer:Et(this.biasInitializer),kernelRegularizer:wt(this.kernelRegularizer),recurrentRegularizer:wt(this.recurrentRegularizer),biasRegularizer:wt(this.biasRegularizer),activityRegularizer:wt(this.activityRegularizer),kernelConstraint:Kt(this.kernelConstraint),recurrentConstraint:Kt(this.recurrentConstraint),biasConstraint:Kt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),n)}}n0.className="GRUCell";ce(n0);class bT extends Sa{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new n0(e),super(e)}call(e,n){return ee(()=>{this.cell.dropoutMask!=null&&(Ve(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ve(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=n==null?null:n.mask,r=n==null?null:n.training,a=n==null?null:n.initialState;return super.call(e,{mask:s,training:r,initialState:a})})}static fromConfig(e,n){return n.implmentation===0&&(n.implementation=1),new e(n)}}bT.className="GRU";ce(bT);class rp extends sp{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,nn(this.units,"units"),this.activation=ca(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=ca(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=kt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=kt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=kt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=Ct(e.kernelRegularizer),this.recurrentRegularizer=Ct(e.recurrentRegularizer),this.biasRegularizer=Ct(e.biasRegularizer),this.kernelConstraint=Xt(e.kernelConstraint),this.recurrentConstraint=Xt(e.recurrentConstraint),this.biasConstraint=Xt(e.biasConstraint),this.dropout=Qi([1,ua([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Qi([1,ua([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var n;e=ut(e);const s=e[e.length-1];this.kernel=this.addWeight("kernel",[s,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){const a=this.biasInitializer,i=this.units;r=new(n=class extends ks{apply(u,l){const c=a.apply([i]),d=new Wb().apply([i]),h=a.apply([i*2]);return _1(_1(c,d),h)}},n.className="CustomInit",n)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,n){return ee(()=>{const s=n.training==null?!1:n.training;if(e=e,e.length!==3)throw new X(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1];const a=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=da({ones:()=>as(e),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=da({ones:()=>as(r),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=this.recurrentDropoutMask;let u,l,c,d;0<this.dropout&&this.dropout<1&&(e=j(e,i[0]));let h=fr(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=j(r,o[0])),h=le(h,fr(r,this.recurrentKernel.read())),this.useBias&&(h=Js(h,this.bias.read()));const[p,f,m,g]=Gn(h,4,h.rank-1);u=this.recurrentActivation.apply(p),l=this.recurrentActivation.apply(f),c=le(j(l,a),j(u,this.activation.apply(m))),d=this.recurrentActivation.apply(g);const y=j(d,this.activation.apply(c));return[y,y,c]})}getConfig(){const e=super.getConfig(),n={units:this.units,activation:la(this.activation),recurrentActivation:la(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Et(this.kernelInitializer),recurrentInitializer:Et(this.recurrentInitializer),biasInitializer:Et(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:wt(this.kernelRegularizer),recurrentRegularizer:wt(this.recurrentRegularizer),biasRegularizer:wt(this.biasRegularizer),activityRegularizer:wt(this.activityRegularizer),kernelConstraint:Kt(this.kernelConstraint),recurrentConstraint:Kt(this.recurrentConstraint),biasConstraint:Kt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),n)}}rp.className="LSTMCell";ce(rp);class xT extends Sa{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new rp(e),super(e)}call(e,n){return ee(()=>{this.cell.dropoutMask!=null&&(Ve(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ve(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=n==null?null:n.mask,r=n==null?null:n.training,a=n==null?null:n.initialState;return super.call(e,{mask:s,training:r,initialState:a})})}static fromConfig(e,n){return n.implmentation===0&&(n.implementation=1),new e(n)}}xT.className="LSTM";ce(xT);class s0 extends sp{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const n of this.cells.slice().reverse())Array.isArray(n.stateSize)?e.push(...n.stateSize):e.push(n.stateSize);return e}call(e,n){return ee(()=>{e=e;let s=e.slice(1);const r=[];for(const o of this.cells.slice().reverse())Array.isArray(o.stateSize)?r.push(s.splice(0,o.stateSize.length)):r.push(s.splice(0,1));r.reverse();const a=[];let i;for(let o=0;o<this.cells.length;++o){const u=this.cells[o];s=r[o],o===0?i=[e[0]].concat(s):i=[i[0]].concat(s),i=u.call(i,n),a.push(i.slice(1))}s=[];for(const o of a.slice().reverse())s.push(...o);return[i[0]].concat(s)})}build(e){Em(e)&&(e=e[0]),e=e;let n;this.cells.forEach((s,r)=>{ja(`RNNCell_${r}`,()=>{s.build(e),Array.isArray(s.stateSize)?n=s.stateSize[0]:n=s.stateSize,e=[e[0],n]})}),this.built=!0}getConfig(){const e=super.getConfig(),n=a=>({className:a.getClassName(),config:a.getConfig()}),r={cells:this.cells.map(n)};return Object.assign(Object.assign({},e),r)}static fromConfig(e,n,s={}){const r=[];for(const a of n.cells)r.push(Nr(a,s));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const n of this.cells)e.push(...n.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const n of this.cells)e.push(...n.nonTrainableWeights);if(!this.trainable){const n=[];for(const s of this.cells)n.push(...s.trainableWeights);return n.concat(e)}return e}getWeights(){const e=[];for(const n of this.cells)e.push(...n.weights);return Am(e)}setWeights(e){const n=[];for(const s of this.cells){const r=s.weights.length,a=e.splice(r);for(let i=0;i<s.weights.length;++i)n.push([s.weights[i],a[i]])}Xb(n)}}s0.className="StackedRNNCells";ce(s0);function da(t){const{ones:e,rate:n,training:s=!1,count:r=1,dropoutFunc:a}=t,i=()=>a!=null?a(e(),n):cC(e(),n),o=()=>El(i,e,s);return!r||r<=1?tn(o().clone()):Array(r).fill(void 0).map(o).map(l=>tn(l.clone()))}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var T6=function(t,e){var n={};for(var s in t)Object.prototype.hasOwnProperty.call(t,s)&&e.indexOf(s)<0&&(n[s]=t[s]);if(t!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,s=Object.getOwnPropertySymbols(t);r<s.length;r++)e.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(t,s[r])&&(n[s[r]]=t[s[r]]);return n};class wT extends Sa{constructor(e){if(e.unroll)throw new He("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new He("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new qt({ndim:5})]}call(e,n){return ee(()=>{if(this.cell.dropoutMask!=null&&(Ve(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ve(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),n&&n.constants)throw new X("ConvRNN2D cell does not support constants");const s=n==null?null:n.mask,r=n==null?null:n.training,a=n==null?null:n.initialState;return super.call(e,{mask:s,training:r,initialState:a})})}computeOutputShape(e){let n=this.computeSingleOutputShape(e);return this.returnSequences||(n=[n[0],...n.slice(2)]),this.returnState&&(n=[n,...Array(2).fill([e[0],...n.slice(-3)])]),n}getInitialState(e){return ee(()=>{const{stateSize:n}=this.cell,s=e.shape,r=this.computeSingleOutputShape(s),a=[r[0],...r.slice(2)],i=Gt(a);return Array.isArray(n)?Array(n.length).fill(i):[i]})}resetStates(e,n=!1){ee(()=>{if(!this.stateful)throw new ir("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,r=this.computeSingleOutputShape(s),a=[r[0],...r.slice(2)];if(s[0]==null)throw new X("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Gt(a)):this.states_=[Gt(a)];else if(e==null)Ve(this.states_),this.keptStates!=null&&(Ve(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Gt(a)):this.states_[0]=Gt(a);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new X(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);n?this.keptStates.push(this.states_.slice()):Ve(this.states_);for(let o=0;o<this.states_.length;++o){const u=e[o],l=a;if(!tt(u.shape,l))throw new X(`State ${o} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${u.shape}`);this.states_[o]=u}}this.states_=this.states_.map(o=>tn(o.clone()))})}computeSingleOutputShape(e){const{dataFormat:n,filters:s,kernelSize:r,padding:a,strides:i,dilationRate:o}=this.cell,u=n==="channelsFirst",l=e[u?3:2],c=e[u?4:3],d=qs(l,r[0],a,i[0],o[0]),h=qs(c,r[1],a,i[1],o[1]);return[...e.slice(0,2),...u?[s,d,h]:[d,h,s]]}}wT.className="ConvRNN2D";class r0 extends rp{constructor(e){const{filters:n,kernelSize:s,strides:r,padding:a,dataFormat:i,dilationRate:o}=e;super(Object.assign(Object.assign({},e),{units:n})),this.filters=n,nn(this.filters,"filters"),this.kernelSize=Hi(s,2,"kernelSize"),this.kernelSize.forEach(u=>nn(u,"kernelSize")),this.strides=Hi(r||1,2,"strides"),this.strides.forEach(u=>nn(u,"strides")),this.padding=a||"valid",os(this.padding),this.dataFormat=i||"channelsLast",Bt(this.dataFormat),this.dilationRate=Hi(o||1,2,"dilationRate"),this.dilationRate.forEach(u=>nn(u,"dilationRate"))}build(e){var n;e=ut(e);const s=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[s]==null)throw new X(`The channel dimension of the input should be defined. Found ${e[s]}`);const r=e[s],a=4,i=this.kernelSize.concat([r,this.filters*a]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const o=this.kernelSize.concat([this.filters,this.filters*a]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",o,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let u;if(this.unitForgetBias){const l=this.biasInitializer,c=this.filters;u=new(n=class extends ks{apply(h,p){const f=l.apply([c]),m=Un([c]),g=l.apply([c*2]);return Vb([f,m,g])}},n.className="CustomInit",n)}else u=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*a],null,u,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,n){return ee(()=>{if(e.length!==3)throw new X(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const s=n.training||!1,r=e[0],a=e[1],i=e[2],o=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=da({ones:()=>as(r),rate:this.dropout,training:s,count:o,dropoutFunc:this.dropoutFunc}));const u=this.dropoutMask,l=(ne,M,Z)=>!M||!M[Z]?ne:j(M[Z],ne);let c=l(r,u,0),d=l(r,u,1),h=l(r,u,2),p=l(r,u,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=da({ones:()=>as(a),rate:this.recurrentDropout,training:s,count:o,dropoutFunc:this.dropoutFunc}));const f=this.recurrentDropoutMask;let m=l(a,f,0),g=l(a,f,1),y=l(a,f,2),b=l(a,f,3);const $=3,[w,v,k,C]=Gn(this.kernel.read(),o,$),[N,A,I,E]=this.useBias?Gn(this.bias.read(),o):[null,null,null,null];c=this.inputConv(c,w,N,this.padding),d=this.inputConv(d,v,A,this.padding),h=this.inputConv(h,k,I,this.padding),p=this.inputConv(p,C,E,this.padding);const[z,P,H,G]=Gn(this.recurrentKernel.read(),o,$);m=this.recurrentConv(m,z),g=this.recurrentConv(g,P),y=this.recurrentConv(y,H),b=this.recurrentConv(b,G);const W=this.recurrentActivation.apply(le(c,m)),L=this.recurrentActivation.apply(le(d,g)),B=le(j(L,i),j(W,this.activation.apply(le(h,y)))),Y=j(this.recurrentActivation.apply(le(p,b)),this.activation.apply(B));return[Y,Y,B]})}getConfig(){const e=super.getConfig(),{units:n}=e,s=T6(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},s),r)}inputConv(e,n,s,r){const a=oa(e,n,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return s?Js(a,s,this.dataFormat):a}recurrentConv(e,n){return oa(e,n,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}r0.className="ConvLSTM2DCell";ce(r0);class $T extends wT{constructor(e){const n=new r0(e);super(Object.assign(Object.assign({},e),{cell:n}))}static fromConfig(e,n){return new e(n)}}$T.className="ConvLSTM2D";ce($T);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class a0 extends Ze{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;const n=e.shape,s=[];for(let r=0;r<this.noiseShape.length;++r)s.push(this.noiseShape[r]==null?n[r]:this.noiseShape[r]);return s}call(e,n){return ee(()=>{this.invokeCallHook(e,n);const s=Pe(e);if(0<this.rate&&this.rate<1){const r=n.training==null?!1:n.training,a=this.getNoiseShape(s);return El(()=>cC(s,this.rate,a,this.seed),()=>s,r)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},n=super.getConfig();return Object.assign(e,n),e}dispose(){return super.dispose()}}a0.className="Dropout";ce(a0);class vT extends a0{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const n=e.shape;return[n[0],1,n[2]]}}vT.className="SpatialDropout1D";ce(vT);class ST extends Ze{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let n=null;e.batchSize!=null&&(n=e.batchSize),this.batchInputShape=[n,e.inputDim]}this.units=e.units,nn(this.units,"units"),this.activation=ca(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=kt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=kt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Xt(e.kernelConstraint),this.biasConstraint=Xt(e.biasConstraint),this.kernelRegularizer=Ct(e.kernelRegularizer),this.biasRegularizer=Ct(e.biasRegularizer),this.activityRegularizer=Ct(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=ut(e);const n=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[n,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:n}}],this.built=!0}computeOutputShape(e){e=ut(e);const n=e.slice();return n[n.length-1]=this.units,n}call(e,n){return ee(()=>{this.invokeCallHook(e,n);const s=Pe(e),r=sC(this.activation.getClassName());let a;return r!=null?a=fr(s,this.kernel.read(),r,this.bias?this.bias.read():null):(a=fr(s,this.kernel.read()),this.bias!=null&&(a=Js(a,this.bias.read())),this.activation!=null&&(a=this.activation.apply(a))),a})}getConfig(){const e={units:this.units,activation:la(this.activation),useBias:this.useBias,kernelInitializer:Et(this.kernelInitializer),biasInitializer:Et(this.biasInitializer),kernelRegularizer:wt(this.kernelRegularizer),biasRegularizer:wt(this.biasRegularizer),activityRegularizer:wt(this.activityRegularizer),kernelConstraint:Kt(this.kernelConstraint),biasConstraint:Kt(this.biasConstraint)},n=super.getConfig();return Object.assign(e,n),e}}ST.className="Dense";ce(ST);class IT extends Ze{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=ut(e);for(const n of e.slice(1))if(n==null)throw new X(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],na(e,1)]}call(e,n){return ee(()=>{this.invokeCallHook(e,n);let s=Pe(e);if(this.dataFormat==="channelsFirst"&&s.rank>1){const r=[0];for(let a=2;a<s.rank;++a)r.push(a);r.push(1),s=st(s,r)}return uq(s)})}getConfig(){const e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);const n=super.getConfig();return Object.assign(e,n),e}}IT.className="Flatten";ce(IT);class _T extends Ze{constructor(e){super(e),this.supportsMasking=!0,this.activation=ca(e.activation)}call(e,n){return ee(()=>{this.invokeCallHook(e,n);const s=Pe(e);return this.activation.apply(s)})}getConfig(){const e={activation:la(this.activation)},n=super.getConfig();return Object.assign(e,n),e}}_T.className="Activation";ce(_T);class kT extends Ze{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,n){return ee(()=>(e=Pe(e),iq(e,this.n)))}getConfig(){const e={n:this.n},n=super.getConfig();return Object.assign(e,n),e}}kT.className="RepeatVector";ce(kT);class CT extends Ze{constructor(e){super(e),this.targetShape=e.targetShape;for(let n=0;n<this.targetShape.length;++n)this.isUnknown(this.targetShape[n])&&(this.targetShape[n]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,n){const s="Total size of new array must be unchanged.",r=n.slice();let a=1,i=null;for(let u=0;u<r.length;++u){const l=r[u];if(this.isUnknown(l))if(i===null)i=u;else throw new X("Can only specifiy one unknown dimension.");else a*=l}const o=na(e);if(i!==null){if(a===0||o%a!==0)throw new X(s);r[i]=o/a}else if(o!==a)throw new X(s);return r}computeOutputShape(e){let n=!1;for(let s=0;s<e.length;++s)if(this.isUnknown(e[s])){n=!0;break}return n?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,n){return ee(()=>{this.invokeCallHook(e,n);const s=Pe(e),r=s.shape,a=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return K(s,a)})}getConfig(){const e={targetShape:this.targetShape},n=super.getConfig();return Object.assign(e,n),e}}CT.className="Reshape";ce(CT);class TT extends Ze{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const n=Xs(1,e.dims.length+1);if(!tt(e.dims.slice().sort(),n))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new qt({ndim:this.dims.length+1})]}computeOutputShape(e){e=ut(e);const n=e.slice();return this.dims.forEach((s,r)=>{n[r+1]=e[s]}),n}call(e,n){return st(Pe(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},n=super.getConfig();return Object.assign(e,n),e}}TT.className="Permute";ce(TT);class NT extends Ze{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),n={maskValue:this.maskValue};return Object.assign(n,e),n}computeMask(e,n){const s=Pe(e);return Gc(Yi(s,this.maskValue),-1)}call(e,n){return ee(()=>{this.invokeCallHook(e,n);const s=Pe(e),i=Gc(Yi(s,this.maskValue),-1,!0);return j(s,ge(i,s.dtype))})}}NT.className="Masking";ce(NT);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class ET extends Ze{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let n=null;e.batchSize!=null&&(n=e.batchSize),e.inputLength==null?this.batchInputShape=[n,null]:this.batchInputShape=[n].concat(ht(e.inputLength))}this.inputDim=e.inputDim,nn(this.inputDim,"inputDim"),this.outputDim=e.outputDim,nn(this.outputDim,"outputDim"),this.embeddingsInitializer=kt(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Ct(e.embeddingsRegularizer),this.activityRegularizer=Ct(e.activityRegularizer),this.embeddingsConstraint=Xt(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,n){return ee(()=>this.maskZero?(e=Pe(e),Yi(e,rt(e))):null)}computeOutputShape(e){if(e=ut(e),this.inputLength==null)return[...e,this.outputDim];const n=ht(this.inputLength);if(n.length!==e.length-1)throw new X(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let s=0;for(let r=0;r<n.length;++r){const a=n[r],i=e[r+1];if(a!=null&&i!=null&&a!==i)throw new X(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);a==null&&(n[s]=i),s++}}return[e[0],...n,this.outputDim]}call(e,n){return ee(()=>{this.invokeCallHook(e,n);let s=Pe(e);s.dtype!=="int32"&&(s=pr(s,"int32"));const r=lC(this.embeddings.read(),K(s,[s.size]));return K(r,ut(this.computeOutputShape(s.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Et(this.embeddingsInitializer),embeddingsRegularizer:wt(this.embeddingsRegularizer),activityRegularizer:wt(this.activityRegularizer),embeddingsConstraint:Kt(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},n=super.getConfig();return Object.assign(e,n),e}}ET.className="Embedding";ce(ET);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class $i extends Ze{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new He}computeElementwiseOpOutputShape(e,n){if(e==null||n==null)return null;if(e.length<n.length)return this.computeElementwiseOpOutputShape(n,e);if(n.length===0)return e;const s=e.slice(0,e.length-n.length);for(let r=0;r<n.length;++r){const a=e[e.length-n.length+r],i=n[r];if(a==null||i==null||a<0||i<0)s.push(null);else if(a===1)s.push(i);else if(i===1)s.push(a);else{if(a!==i)throw new X("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(n));s.push(a)}}return s}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[ut(e)]),e=e,e.length<2)throw new X(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let n=[];for(const a of e)a!=null&&a[0]!==null&&n.push(a[0]);if(n=ta(n),n.length>1)throw new X(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let s=e[0]==null?null:e[0].slice(1);for(let a=1;a<e.length;++a){const i=e[a]==null?null:e[a].slice(1);s=this.computeElementwiseOpOutputShape(s,i)}const r=e.map(a=>a.length);e.indexOf(null)===-1&&ta(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,n){return ee(()=>{if(e=e,this.reshapeRequired){const s=[],r=e.map(a=>a.rank);if(r.indexOf(null)===-1){const a=ua(r);for(let i of e){const o=i.rank;for(let u=0;u<a-o;++u)i=Tl(i,1);s.push(i)}return this.mergeFunction(s)}else{let a=!1;for(const u of e){const l=u.rank;if(l==null){const c=u.shape,d=c[0],h=c.slice(1).concat([d]);let p=K(u,[d].concat(na(c.slice(1))));p=st(p,[1,0]),p=K(p,h),s.push(p),a=!0}else if(l>1){const c=Xs(1,l).concat([0]);s.push(st(u,c)),a=!0}else s.push(u)}let i=this.mergeFunction(s);const o=i.rank;if(a){if(o==null){const u=i.shape,l=u.length,c=u[l-1],d=[c].concat(u.slice(0,u.length-1));i=K(st(K(i,[-1,c]),[1,0]),d)}else if(o>1){const u=[o-1].concat(Xs(0,o-1));i=st(i,u)}}return i}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let n;e[0]==null?n=null:n=e[0].slice(1);for(let r=1;r<e.length;++r){const a=e[r]==null?null:e[r].slice(1);n=this.computeElementwiseOpOutputShape(n,a)}let s=[];for(const r of e)r!=null&&r[0]!==null&&s.push(r[0]);return s=ta(s),s.length===1?n=s.concat(n):n=[null].concat(n),n}computeMask(e,n){return ee(()=>{if(n==null)return null;if(!Array.isArray(n))throw new X("`mask` should be an Array");if(!Array.isArray(e))throw new X("`inputs` should be an Array");if(n.length!==e.length)throw new X(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${n.length})`);if(n.every(r=>r==null))return null;n=n.map(r=>r==null?r:_n(r,0));let s=n[0];for(let r=1;r<n.length-1;++r)s=mr(s,n[r]);return s})}}class AT extends $i{constructor(e){super(e)}mergeFunction(e){return ee(()=>{let n=e[0].clone();for(let s=1;s<e.length;++s)n=le(n,e[s]);return n})}}AT.className="Add";ce(AT);class RT extends $i{constructor(e){super(e)}mergeFunction(e){return ee(()=>{let n=e[0].clone();for(let s=1;s<e.length;++s)n=j(n,e[s]);return n})}}RT.className="Multiply";ce(RT);class DT extends $i{constructor(e){super(e)}mergeFunction(e){return ee(()=>{let n=e[0].clone();for(let s=1;s<e.length;++s)n=le(n,e[s]);return j(1/e.length,n)})}}DT.className="Average";ce(DT);class OT extends $i{constructor(e){super(e)}mergeFunction(e){return ee(()=>{let n=e[0];for(let s=1;s<e.length;++s)n=zr(n,e[s]);return n})}}OT.className="Maximum";ce(OT);class FT extends $i{constructor(e){super(e)}mergeFunction(e){return ee(()=>{let n=e[0];for(let s=1;s<e.length;++s)n=ai(n,e[s]);return n})}}FT.className="Minimum";ce(FT);class zT extends $i{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new X("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let n=!0;for(const r of e)if(r!=null){n=!1;break}if(n)return;const s=[];for(let r=0;r<e.length;++r){const a=e[r].slice();a.splice(this.axis,1);let i=!1;for(const o of s)if(tt(o,a)){i=!0;break}i||s.push(a)}if(s.length>1)throw new X("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return ee(()=>Vb(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new X("A `Concatenate` layer should be called on a list of inputs.");const n=e,s=n[0].slice(),r=this.axis<0?s.length+this.axis:this.axis;for(const a of n.slice(1)){if(s[r]==null||a[r]==null){s[r]=null;break}s[r]+=a[r]}return s}computeMask(e,n){if(n==null)return null;if(!Array.isArray(n))throw new X("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new X("`inputs` should be an array for Concatenate");if(n.length!==e.length)throw new X(`Mismatch in the length of mask (${n.length}) and the legnth of inputs (${e.length})`);return ee(()=>{let s=!0;if(n.forEach(i=>{if(i!=null){s=!1;return}}),s)return null;const r=[];for(let i=0;i<e.length;++i)n[i]==null?r.push(ge(as(e[i]),"bool")):n[i].rank<e[i].rank?r.push(_n(n[i],-1)):r.push(n[i]);const a=Wt(r,this.axis);return Ty(a,-1,!1)})}getConfig(){const e={axis:this.axis},n=super.getConfig();return Object.assign(e,n),e}}zT.className="Concatenate";ce(zT);function Ao(t,e){for(;t<0;)t+=e;return t}function N6(t,e,n){if(t.shape.length>3||e.shape.length>3)throw new He("batchDot is not implemented for tensors of 4D or higher rank yet");if(O(t.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${t.shape.length}`),O(t.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof n=="number"&&(n=[n,n]),t.dtype==="complex64"||e.dtype==="complex64")throw new He("batchDot is not implemented for complex64-type Tensors yet.");const s=t.shape.length,r=e.shape.length;n==null&&(n=[s-1,r-2]);const a=n;return ee(()=>{let i;if(s>r){i=s-r;const u=[];for(let l=0;l<i;++l)u.push(1);e=K(e,e.shape.concat(u))}else if(r>s){i=r-s;const u=[];for(let l=0;l<i;++l)u.push(1);t=K(t,t.shape.concat(u))}else i=0;let o;if(t.shape.length===2&&e.shape.length===2)a[0]===a[1]?o=Ie(j(t,e),a[0]):o=Ie(j(st(t,[1,0]),e),a[1]);else{const u=a[0]!==t.shape.length-1,l=a[1]===e.shape.length-1;o=Qe(t,e,u,l)}if(i>0){let u;s>r?u=s+r-3:u=s-1;const l=[];for(let c=u;c<u+i;++c)l.push(c);o=bi(o,l)}return o.shape.length===1&&(o=_n(o,1)),o})}class LT extends $i{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){O(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const n=e[0],s=e[1];if(n.length>3||s.length>3)throw new He("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(n,s);if(n[r[0]]!==s[r[1]])throw new X(`Dimension incompatibility: ${n[r[0]]} !== ${s[r[1]]}`)}mergeFunction(e){if(e.length!==2)throw new X(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let n=e[0],s=e[1],r;return Array.isArray(this.axes)?r=this.axes.map((a,i)=>Ao(a,e[i].shape.length)):r=[Ao(this.axes,n.shape.length),Ao(this.axes,s.shape.length)],this.normalize&&(n=Yc(n,r[0]),s=Yc(s,r[1])),N6(n,s,r)}interpretAxes(e,n){let s;return Array.isArray(this.axes)?s=this.axes:s=[Ao(this.axes,e.length),Ao(this.axes,n.length)],s}computeOutputShape(e){O(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const n=e[0].slice(),s=e[1].slice();if(n.length>3||s.length>3)throw new He("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(n,s);n.splice(r[0],1),s.splice(r[1],1),s.splice(0,1);const a=n.concat(s);return a.length===1&&a.push(1),a}computeMask(e,n){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},n=super.getConfig();return Object.assign(e,n),e}}LT.className="Dot";ce(LT);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class PT extends Ze{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),n={stddev:this.stddev};return Object.assign(n,e),n}call(e,n){return ee(()=>{this.invokeCallHook(e,n);const s=Pe(e);return El(()=>le(Zh(s.shape,0,this.stddev),s),()=>s,n.training||!1)})}}PT.className="GaussianNoise";ce(PT);class BT extends Ze{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),n={rate:this.rate};return Object.assign(n,e),n}call(e,n){return ee(()=>{this.invokeCallHook(e,n);const s=Pe(e);return this.rate>0&&this.rate<1?El(()=>{const a=Math.sqrt(this.rate/(1-this.rate));return j(s,Zh(s.shape,1,a))},()=>s,n.training||!1):s})}}BT.className="GaussianDropout";ce(BT);class MT extends Ze{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Pe(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),n={rate:this.rate};return Object.assign(n,e),n}call(e,n){return ee(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(e);return El(()=>{const a=Pe(e),o=-1.6732632423543772*1.0507009873554805;let u=wa(yi(s),this.rate);u=pr(u,"float32");const l=((1-this.rate)*(1+this.rate*o**2))**-.5,c=-l*o*this.rate,d=le(j(a,u),j(le(u,-1),o));return le(j(d,l),c)},()=>Pe(e),n.training||!1)}return e})}}MT.className="AlphaDropout";ce(MT);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function pu(t,e,n,s,r,a=.001){let i;if(t.rank===2)i=c_(t,e,n,s,r,a);else if(t.rank===3)i=d_(t,e,n,s,r,a);else if(t.rank===4)i=h_(t,e,n,s,r,a);else throw new He(`batchNormalization is not implemented for array of rank ${t.rank} yet`);return i}function E6(t,e,n,s,r=.001){return ee(()=>{const a=Dh(t,s),i=a.mean,o=a.variance;return[pu(t,i,o,n,e,r),i,o]})}function A6(t,e,n,s,r=.001){return ee(()=>{const a=Dh(t,s),i=a.mean,o=a.variance,u=[];for(const f of Xs(0,t.rank))s.indexOf(f)!==-1?u.push(1):u.push(t.shape[f]);const l=K(i,u),c=K(o,u),d=e==null?null:K(e,u),h=n==null?null:K(n,u);return[pu(t,l,c,h,d,r),i,o]})}function R6(t,e,n,s,r=.001){return tt(s.slice().sort(),Xs(0,t.rank-1))?E6(t,e,n,s,r):A6(t,e,n,s,r)}class VT extends Ze{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=kt(e.betaInitializer||"zeros"),this.gammaInitializer=kt(e.gammaInitializer||"ones"),this.movingMeanInitializer=kt(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=kt(e.movingVarianceInitializer||"ones"),this.betaConstraint=Xt(e.betaConstraint),this.gammaConstraint=Xt(e.gammaConstraint),this.betaRegularizer=Ct(e.betaRegularizer),this.gammaRegularizer=Ct(e.gammaRegularizer)}build(e){e=ut(e);const n=this.axis>=0?this.axis:this.axis+e.length,s=e[n];if(s==null)throw new X(`Axis ${n} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new qt({ndim:e.length,axes:{[n]:s}})];const r=[s];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,n){return ee(()=>{const s=n.training==null?!1:n.training,r=Pe(e),a=r.shape,i=a.length,o=Xs(0,i),u=this.axis>=0?this.axis:this.axis+i;o.splice(u,1);const l=oi(1,i);l[u]=a[u];const c=o.slice();c.sort();const d=!tt(c,Xs(0,i).slice(0,i-1)),h=()=>{if(d){const b=K(this.movingMean.read(),l),$=K(this.movingVariance.read(),l),w=this.center?K(this.beta.read(),l):null,v=this.scale?K(this.gamma.read(),l):null;return pu(r,b,$,w,v,this.epsilon)}else return pu(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!s)return h();const[p,f,m]=R6(r,this.gamma.read(),this.beta.read(),o,this.epsilon),g=(b,$,w)=>{ee(()=>{const v=1-w,k=b.read(),C=j(we(k,$),v);b.write(we(k,C))})};return(()=>{g(this.movingMean,f,this.momentum),g(this.movingVariance,m,this.momentum)})(),p})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Et(this.betaInitializer),gammaInitializer:Et(this.gammaInitializer),movingMeanInitializer:Et(this.movingMeanInitializer),movingVarianceInitializer:Et(this.movingVarianceInitializer),betaRegularizer:wt(this.betaRegularizer),gammaRegularizer:wt(this.gammaRegularizer),betaConstraint:Kt(this.betaConstraint),gammaConstraint:Kt(this.gammaConstraint)},n=super.getConfig();return Object.assign(e,n),e}}VT.className="BatchNormalization";ce(VT);class WT extends Ze{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const n of this.axis)if(!Number.isInteger(n))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=kt(e.betaInitializer||"zeros"),this.gammaInitializer=kt(e.gammaInitializer||"ones"),this.betaRegularizer=Ct(e.betaRegularizer),this.gammaRegularizer=Ct(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=ut(e);const n=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let a=0;a<this.axis.length;++a)this.axis[a]<0&&(this.axis[a]+=n);for(const a of this.axis)if(a<0||a>=n)throw new Error(`Invalid axis: ${a}`);if(this.axis.length!==ta(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(a=>e[a]),r=!0;this.scale?this.gamma=this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,n){const s=Pe(e),r=s.shape,a=r.length;return ee(()=>{let{mean:o,variance:u}=Dh(s,this.axis,!0);const l=oi(1,a);for(const m of this.axis)l[m]=r[m];const c=m=>m!=null&&m.shape.length!==a?K(m,l):m;let d=this.scale?c(this.gamma.read()):null,h=this.center?c(this.beta.read()):null;const p=[],f=[];for(let m=0;m<a;++m)this.axis.indexOf(m)!==-1?(p.push(r[m]),f.push(1)):(p.push(1),f.push(r[m]));return o=gs(o,p),u=gs(u,p),d!=null&&(d=gs(d,f)),h!=null&&(h=gs(h,f)),pu(s,o,u,h,d,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Et(this.betaInitializer),gammaInitializer:Et(this.gammaInitializer),betaRegularizer:wt(this.betaRegularizer),gammaRegularizer:wt(this.gammaRegularizer)},n=super.getConfig();return Object.assign(e,n),e}}WT.className="LayerNormalization";ce(WT);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function D6(t,e,n){return ee(()=>{if(t.rank!==4)throw new X(`temporalPadding expects input tensor to be 4-D, but received a ${t.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new X("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(n==null&&(n=Ys()),n!=="channelsLast"&&n!=="channelsFirst")throw new X(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let s;return n==="channelsFirst"?s=[[0,0],[0,0],e[0],e[1]]:s=[[0,0],e[0],e[1],[0,0]],$a(t,s)})}class UT extends Ze{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?Ys():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new X(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let n,s;if(typeof e.padding[0]=="number")n=[e.padding[0],e.padding[0]],s=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new X(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(n=e.padding[0],e.padding[1].length!==2)throw new X(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);s=e.padding[1]}this.padding=[n,s]}this.inputSpec=[new qt({ndim:4})]}computeOutputShape(e){e=ut(e);let n,s;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?n=e[2]+this.padding[0][0]+this.padding[0][1]:n=null,e[3]!=null&&e[3]>=0?s=e[3]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],e[1],n,s]):(e[1]!=null&&e[1]>=0?n=e[1]+this.padding[0][0]+this.padding[0][1]:n=null,e[2]!=null&&e[2]>=0?s=e[2]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],n,s,e[3]])}call(e,n){return ee(()=>D6(Pe(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}}UT.className="ZeroPadding2D";ce(UT);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function ap(t,e,n,s,r,a){return ee(()=>{Bt(r),aC(a),os(s),n==null&&(n=[1,1]),s==null&&(s="valid"),r==null&&(r=Ys()),a==null&&(a="max"),t=e0(t,r);let i;const o=s==="same"?"same":"valid";return a==="max"?i=Rh(t,e,n,o):i=Ih(t,e,n,o),r==="channelsFirst"&&(i=st(i,[0,3,1,2])),i})}function GT(t,e,n,s,r,a){return ee(()=>{Bt(r),aC(a),os(s),n==null&&(n=[1,1,1]),s==null&&(s="valid"),r==null&&(r=Ys()),a==null&&(a="max"),t=oT(t,r);let i;const o=s==="same"?"same":"valid";return a==="max"?i=z_(t,e,n,o):i=l_(t,e,n,o),r==="channelsFirst"&&(i=st(i,[0,4,1,2,3])),i})}class HT extends Ze{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new X(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(nn(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new X(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);nn(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,os(this.padding),this.inputSpec=[new qt({ndim:3})]}computeOutputShape(e){e=ut(e);const n=qs(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],n,e[2]]}call(e,n){return ee(()=>{this.invokeCallHook(e,n),e=Tl(Pe(e),2);const s=this.poolingFunction(Pe(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return bi(s,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},n=super.getConfig();return Object.assign(e,n),e}}class qT extends HT{constructor(e){super(e)}poolingFunction(e,n,s,r,a){return Bt(a),os(r),ap(e,n,s,r,a,"max")}}qT.className="MaxPooling1D";ce(qT);class jT extends HT{constructor(e){super(e)}poolingFunction(e,n,s,r,a){return Bt(a),os(r),ap(e,n,s,r,a,"avg")}}jT.className="AveragePooling1D";ce(jT);class KT extends Ze{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new X(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];nn(this.poolSize,"poolSize"),nn(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Bt(this.dataFormat),os(this.padding),this.inputSpec=[new qt({ndim:4})]}computeOutputShape(e){e=ut(e);let n=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2];return n=qs(n,this.poolSize[0],this.padding,this.strides[0]),s=qs(s,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],n,s]:[e[0],n,s,e[3]]}call(e,n){return ee(()=>(this.invokeCallHook(e,n),this.poolingFunction(Pe(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}}class XT extends KT{constructor(e){super(e)}poolingFunction(e,n,s,r,a){return Bt(a),os(r),ap(e,n,s,r,a,"max")}}XT.className="MaxPooling2D";ce(XT);class YT extends KT{constructor(e){super(e)}poolingFunction(e,n,s,r,a){return Bt(a),os(r),ap(e,n,s,r,a,"avg")}}YT.className="AveragePooling2D";ce(YT);class ZT extends Ze{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new X(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];nn(this.poolSize,"poolSize"),nn(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Bt(this.dataFormat),os(this.padding),this.inputSpec=[new qt({ndim:5})]}computeOutputShape(e){e=ut(e);let n=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[4]:e[3];return n=qs(n,this.poolSize[0],this.padding,this.strides[0]),s=qs(s,this.poolSize[1],this.padding,this.strides[1]),r=qs(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],n,s,r]:[e[0],n,s,r,e[4]]}call(e,n){return ee(()=>(this.invokeCallHook(e,n),this.poolingFunction(Pe(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}}class QT extends ZT{constructor(e){super(e)}poolingFunction(e,n,s,r,a){return Bt(a),os(r),GT(e,n,s,r,a,"max")}}QT.className="MaxPooling3D";ce(QT);class JT extends ZT{constructor(e){super(e)}poolingFunction(e,n,s,r,a){return Bt(a),os(r),GT(e,n,s,r,a,"avg")}}JT.className="AveragePooling3D";ce(JT);class eN extends Ze{constructor(e){super(e),this.inputSpec=[new qt({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,n){throw new He}}class tN extends eN{constructor(e){super(e||{})}call(e,n){return ee(()=>{const s=Pe(e);return Rt(s,1)})}}tN.className="GlobalAveragePooling1D";ce(tN);class nN extends eN{constructor(e){super(e||{})}call(e,n){return ee(()=>{const s=Pe(e);return $s(s,1)})}}nN.className="GlobalMaxPooling1D";ce(nN);class sN extends Ze{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Bt(this.dataFormat),this.inputSpec=[new qt({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,n){throw new He}getConfig(){const e={dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}}class rN extends sN{call(e,n){return ee(()=>{const s=Pe(e);return this.dataFormat==="channelsLast"?Rt(s,[1,2]):Rt(s,[2,3])})}}rN.className="GlobalAveragePooling2D";ce(rN);class aN extends sN{call(e,n){return ee(()=>{const s=Pe(e);return this.dataFormat==="channelsLast"?$s(s,[1,2]):$s(s,[2,3])})}}aN.className="GlobalMaxPooling2D";ce(aN);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class iN extends Ze{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},n=super.getConfig();return Object.assign(e,n),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,n,s={}){const r=n.layer,a=Nr(r,s);delete n.layer;const i={layer:a};return Object.assign(i,n),new e(i)}}class oN extends iN{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=ut(e),e.length<3)throw new X(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const n=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(n),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=ut(e);const n=[e[0]].concat(e.slice(2)),s=this.layer.computeOutputShape(n),r=e[1];return[s[0],r].concat(s.slice(1))}call(e,n){return ee(()=>(e=Pe(e),gT((i,o)=>[Pe(this.layer.call(i,n)),[]],e,[],!1,null,null,!1,!0)[1]))}}oN.className="TimeDistributed";ce(oN);function O6(t){wi(tq,"BidirectionalMergeMode",t)}const F6="concat";class uN extends iN{constructor(e){super(e);const n=e.layer.getConfig(),s={};s.className=e.layer.getClassName(),s.config=n,this.forwardLayer=Nr(s),n.goBackwards=n.goBackwards!==!0;const r={};if(r.className=e.layer.getClassName(),r.config=n,this.backwardLayer=Nr(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?F6:e.mergeMode,O6(this.mergeMode),e.weights)throw new He("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const n=e.length,s=Math.floor(n/2);this.forwardLayer.setWeights(e.slice(0,s)),this.backwardLayer.setWeights(e.slice(s))}computeOutputShape(e){let n=this.forwardLayer.computeOutputShape(e);Array.isArray(n)&&Array.isArray(n[0])||(n=[n]),n=n;let s,r,a;return this.returnState&&(a=n.slice(1)),s=n[0],s=s,this.mergeMode==="concat"?(s[s.length-1]*=2,r=[s]):this.mergeMode==null?r=[s,s.slice()]:r=[s],this.returnState?this.mergeMode==null?r.concat(a).concat(a.slice()):[s].concat(a).concat(a.slice()):Dn(r)}apply(e,n){let s=n==null?null:n.initialState,r=n==null?null:n.constants;n==null&&(n={});const a=mT(e,s,r,this.numConstants);if(e=a.inputs,s=a.initialState,r=a.constants,Array.isArray(e)&&(s=e.slice(1),e=e[0]),(s==null||s.length===0)&&r==null)return super.apply(e,n);const i=[],o=[];if(s!=null){const l=s.length;if(l%2>0)throw new X("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");n.initialState=s,i.push(...s);const c=s.map(d=>new qt({shape:d.shape}));this.forwardLayer.stateSpec=c.slice(0,l/2),this.backwardLayer.stateSpec=c.slice(l/2),o.push(...c)}if(r!=null)throw new He("Support for constants in Bidirectional layers is not implemented yet.");const u=i[0]instanceof gr;for(const l of i)if(l instanceof gr!==u)throw new X("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(u){const l=[e].concat(i),c=this.inputSpec.concat(o),d=this.inputSpec;this.inputSpec=c;const h=super.apply(l,n);return this.inputSpec=d,h}else return super.apply(e,n)}call(e,n){return ee(()=>{const s=n.initialState;let r,a;if(s==null)r=this.forwardLayer.call(e,n),a=this.backwardLayer.call(e,n);else{const u=s.slice(0,s.length/2),l=s.slice(s.length/2);r=this.forwardLayer.call(e,Object.assign(n,{initialState:u})),a=this.backwardLayer.call(e,Object.assign(n,{initialState:l}))}let i;this.returnState&&(Array.isArray(r)&&(i=r.slice(1).concat(a.slice(1))),r=r[0],a=a[0]),this.returnSequences&&(a=Ss(a,1));let o;return this.mergeMode==="concat"?o=Vb([r,a]):this.mergeMode==="sum"?o=le(r,a):this.mergeMode==="ave"?o=j(.5,le(r,a)):this.mergeMode==="mul"?o=j(r,a):this.mergeMode==null&&(o=[r,a]),this.returnState?this.mergeMode==null?o.concat(i):[o].concat(i):o})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){ja(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),ja(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,n){Array.isArray(n)&&(n=n[0]);let s;if(this.returnSequences?this.mergeMode==null?s=[n,n]:s=n:this.mergeMode==null?s=[null,null]:s=null,this.returnState){const a=this.forwardLayer.states.map(i=>null);return Array.isArray(s)?s.concat(a).concat(a):[s].concat(a).concat(a)}else return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},n=super.getConfig();return Object.assign(e,n),e}static fromConfig(e,n){const s=Nr(n.layer);if(delete n.layer,n.numConstants!=null)throw new He("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=n;return r.layer=s,new e(r)}}uN.className="Bidirectional";ce(uN);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class lN extends Ze{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},n=super.getConfig();return Object.assign(e,n),e}call(e,n){return ee(()=>(e=Pe(e),e.dtype!=="float32"&&(e=pr(e,"float32")),le(j(e,this.scale),this.offset)))}}lN.className="Rescaling";ce(lN);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const{resizeBilinear:z6,cropAndResize:L6}=ys;class cN extends Ze{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,n,s,r,a,i,o,u){return ee(()=>{let l,c=!1;const d=n/i,h=s/o,p=(r+n)/i,f=(a+s)/o,m=[d,h,p,f],g=[];e.rank===3?(c=!0,l=Kn([e])):l=e;for(let v=0;v<l.shape[0];v++)g.push(m);const y=Hs(g,[g.length,4]),b=Zi(0,g.length,1,"int32"),w=L6(l,y,b,[r,a],"nearest");return pr(c?Pe(Is(w)):w,u)})}upsize(e,n,s,r){return ee(()=>{const a=z6(e,[n,s]);return pr(a,r)})}call(e,n){return ee(()=>{const s=Pe(e),r=s.dtype,a=s.shape,i=a[a.length-3],o=a[a.length-2];let u=0;i!==this.height&&(u=Math.floor((i-this.height)/2));let l=0;return o!==this.width&&(l=Math.floor((o-this.width)/2),l===0&&(l=1)),u>=0&&l>=0?this.centerCrop(s,u,l,this.height,this.width,i,o,r):this.upsize(e,this.height,this.width,r)})}getConfig(){const e={height:this.height,width:this.width},n=super.getConfig();return Object.assign(e,n),e}computeOutputShape(e){e=ut(e);const n=e.length-3,s=e.length-2;return e[n]=this.height,e[s]=this.width,e}}cN.className="CenterCrop";ce(cN);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function P6(t,e,n,s){let r=Pe(t);if(r.dtype!=="int32"&&(r=pr(r,"int32")),e==="int")return r;const a=r.shape;if(r.rank===0&&(r=_n(r,-1)),e==="oneHot"&&r.shape[r.shape.length-1]!==1&&(r=_n(r,-1)),r.rank>2)throw new X(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${a} which would result in output rank ${r.rank}.`);const i=["multiHot","oneHot"].includes(e),o=r;let u;if(typeof s<"u"&&e==="count"?u=vm(o,s,n,i):u=vm(o,[],n,i),e!=="tfIdf")return u;if(s)return j(u,s);throw new X("When outputMode is 'tfIdf', weights must be provided.")}/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class dN extends Ze{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},n=super.getConfig();return Object.assign(e,n),e}computeOutputShape(e){return e=ut(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,n){return ee(()=>{e=Pe(e),e.dtype!=="int32"&&(e=pr(e,"int32"));let s;if(typeof n.countWeights<"u"){if(this.outputMode!=="count")throw new X(`countWeights is not used when outputMode !== count.
              Received countWeights=${n.countWeights}`);s=Pe(n.countWeights)}const r=$s(e),a=au(e),i=Qn(this.numTokens,r).bufferSync().get(0),o=wa(a,0).bufferSync().get(0);if(!(i&&o))throw new X(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return P6(e,this.outputMode,this.numTokens,s)})}}dN.className="CategoryEncoding";ce(dN);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const B6=["bilinear","nearest"],U1=new Set(B6);class hN extends Ze{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(U1.has(e.interpolation))this.interpolation=e.interpolation;else throw new X(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=ut(e);const n=e[2];return[this.height,this.width,n]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},n=super.getConfig();return Object.assign(e,n),e}call(e,n){return ee(()=>{const s=[this.height,this.width];if(this.interpolation==="bilinear")return ys.resizeBilinear(e,s,!this.cropToAspectRatio);if(this.interpolation==="nearest")return ys.resizeNearestNeighbor(e,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...U1]} are supported`)})}}hN.className="Resizing";ce(hN);/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class pN{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}}pN.className="RandomSeed";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class fN extends Ze{constructor(e){super(e),this.randomGenerator=new pN(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},n=super.getConfig();return Object.assign(e,n),e}}fN.className="BaseRandomLayer";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const M6=["bilinear","nearest"],G1=new Set(M6);class mN extends fN{constructor(e){super(e);const{factor:n,interpolation:s="bilinear"}=e;if(this.factor=n,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new X(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new X(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new X(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(s)if(G1.has(s))this.interpolation=s;else throw new X(`Invalid interpolation parameter: ${s} is not implemented`)}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},n=super.getConfig();return Object.assign(e,n),e}computeOutputShape(e){e=ut(e);const n=e[2];return[this.imgHeight,-1,n]}call(e,n){return ee(()=>{const s=Pe(e);this.imgHeight=s.shape[s.shape.length-3];const r=s.shape[s.shape.length-2];this.widthFactor=yi([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let a=this.widthFactor.dataSync()[0]*r;a=Math.round(a);const i=[this.imgHeight,a];switch(this.interpolation){case"bilinear":return ys.resizeBilinear(e,i);case"nearest":return ys.resizeNearestNeighbor(e,i);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...G1]} are supported`)}})}}mN.className="RandomWidth";ce(mN);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V6=te();V6.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,t=>{t&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var Mn;(function(t){t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_QINT16=15]="DT_QINT16",t[t.DT_QUINT16=16]="DT_QUINT16",t[t.DT_UINT16=17]="DT_UINT16",t[t.DT_COMPLEX128=18]="DT_COMPLEX128",t[t.DT_HALF=19]="DT_HALF",t[t.DT_RESOURCE=20]="DT_RESOURCE",t[t.DT_VARIANT=21]="DT_VARIANT",t[t.DT_UINT32=22]="DT_UINT32",t[t.DT_UINT64=23]="DT_UINT64",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",t[t.DT_QINT16_REF=115]="DT_QINT16_REF",t[t.DT_QUINT16_REF=116]="DT_QUINT16_REF",t[t.DT_UINT16_REF=117]="DT_UINT16_REF",t[t.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",t[t.DT_HALF_REF=119]="DT_HALF_REF",t[t.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",t[t.DT_VARIANT_REF=121]="DT_VARIANT_REF",t[t.DT_UINT32_REF=122]="DT_UINT32_REF",t[t.DT_UINT64_REF=123]="DT_UINT64_REF"})(Mn||(Mn={}));var H1;(function(t){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))})(H1||(H1={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W6={};function gN(t){return W6[t]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _(t,e,n,s,r){const a=e.inputParams[t];if(a&&a.inputIndexStart!==void 0){const o=a.inputIndexStart,u=a.inputIndexEnd===0?void 0:a.inputIndexEnd===void 0?o+1:a.inputIndexEnd,l=o<0?e.inputNames.length+o:o;if(a.type==="tensor")return ln(e.inputNames[l],n,s,r);if(a.type==="tensors"){const h=e.inputs.slice(o,u);return e.inputNames.slice(o,u).filter((f,m)=>{var g;return((g=h[m])===null||g===void 0?void 0:g.op)!=="NoOp"}).map(f=>ln(f,n,s,r))}const c=ln(e.inputNames[l],n,s,r),d=c.dataSync();return a.type==="number"?d[0]:ws(c.shape,d)}const i=e.attrParams[t];return i&&i.value}function ln(t,e,n,s){const[r,a]=Vn(t,n);if(s!=null){const o=s.getHashTableHandleByName(r);if(o!=null)return o}const i=n.currentContextIds.find(o=>!!e[td(r,o)]);return i!==void 0?e[td(r,i)][a]:void 0}function q1(t,e,n){return e[td(t,n.currentContextId)]}function Ir(t,e){const[n,s,r]=Vn(t,e);return[td(n,e&&e.currentContextId),s,r]}function td(t,e){return e?`${t}-${e}`:t}function Vn(t,e){if(t==="")return["",0,void 0];const n=e!=null&&e.parseNodeNameCache!=null;if(n){const a=e.parseNodeNameCache.get(t);if(a!=null)return a}const s=t.split(":");let r;if(s.length===1)r=[t,0,void 0];else{const a=s[0],i=s.length===3?s[1]:void 0,o=Number(s[s.length-1]);r=[a,o,i]}return n&&e.parseNodeNameCache.set(t,r),r}function Dc(t,e,n){let s=_("pad",t,e,n);if(s==="explicit"){s=_("explicitPaddings",t,e,n);const r=[[0,0],[0,0],[0,0],[0,0]];for(let a=0;a<4;a++)r[a][0]=s[a*2],r[a][1]=s[a*2+1];return r}return s}function _r(t){return t.kept?t:Tr(t)}/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U6=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],G6=Object.freeze(Object.defineProperty({__proto__:null,json:U6},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H6=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],q6=Object.freeze(Object.defineProperty({__proto__:null,json:H6},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j6=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],K6=Object.freeze(Object.defineProperty({__proto__:null,json:j6},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X6=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],Y6=Object.freeze(Object.defineProperty({__proto__:null,json:X6},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z6=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],Q6=Object.freeze(Object.defineProperty({__proto__:null,json:Z6},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J6=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],ej=Object.freeze(Object.defineProperty({__proto__:null,json:J6},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tj=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],nj=Object.freeze(Object.defineProperty({__proto__:null,json:tj},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sj=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],rj=Object.freeze(Object.defineProperty({__proto__:null,json:sj},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aj=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],ij=Object.freeze(Object.defineProperty({__proto__:null,json:aj},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oj=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],uj=Object.freeze(Object.defineProperty({__proto__:null,json:oj},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lj=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],cj=Object.freeze(Object.defineProperty({__proto__:null,json:lj},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dj=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],hj=Object.freeze(Object.defineProperty({__proto__:null,json:dj},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pj=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],fj=Object.freeze(Object.defineProperty({__proto__:null,json:pj},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mj=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],gj=Object.freeze(Object.defineProperty({__proto__:null,json:mj},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yj=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],bj=Object.freeze(Object.defineProperty({__proto__:null,json:yj},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xj=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],wj=Object.freeze(Object.defineProperty({__proto__:null,json:xj},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $j=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],vj=Object.freeze(Object.defineProperty({__proto__:null,json:$j},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sj=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],Ij=Object.freeze(Object.defineProperty({__proto__:null,json:Sj},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _j=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],kj=Object.freeze(Object.defineProperty({__proto__:null,json:_j},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class j1{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[G6,q6,K6,Y6,Q6,ej,nj,rj,ij,uj,cj,hj,fj,gj,bj,wj,vj,Ij,kj],n=[].concat(...e.map(s=>s.json));this.opMappers=n.reduce((s,r)=>(s[r.tfOpName]=r,s),{})}transformGraph(e,n={}){const s=e.node,r=[],a=[],i=[],o=s.reduce((m,g)=>(m[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?r.push(m[g.name]):g.op==="Const"?a.push(m[g.name]):(g.input==null||g.input.length===0)&&i.push(m[g.name]),m),{});let u=[];const l=[];let c={},d={};n!=null&&(c=this.mapSignatureEntries(n.inputs),d=this.mapSignatureEntries(n.outputs));const h=Object.keys(o);h.forEach(m=>{const g=o[m];g.inputNames.forEach((y,b)=>{const[$,,w]=Ir(y),v=o[$];if(v.outputs!=null){const k=v.outputs.indexOf(w);if(k!==-1){const C=`${$}:${k}`;g.inputNames[b]=C}}g.inputs.push(v),v.children.push(g)})}),Object.keys(d).length===0?h.forEach(m=>{const g=o[m];g.children.length===0&&l.push(g)}):Object.keys(d).forEach(m=>{const[g]=Ir(m),y=o[g];y!=null&&(y.signatureKey=d[m],l.push(y))}),Object.keys(c).length>0?Object.keys(c).forEach(m=>{const[g]=Ir(m),y=o[g];y&&(y.signatureKey=c[m],u.push(y))}):u=r;let p={};e.library!=null&&e.library.function!=null&&(p=e.library.function.reduce((m,g)=>(m[g.signature.name]=this.mapFunction(g),m),{}));const f={nodes:o,inputs:u,outputs:l,weights:a,placeholders:r,signature:n,functions:p};return i.length>0&&(f.initNodes=i),f}mapSignatureEntries(e){return Object.keys(e||{}).reduce((n,s)=>(n[e[s].name]=s,n),{})}mapNode(e){const n=gN(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const s={name:e.name,op:e.op,category:n.category,inputNames:(e.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:n.outputs};return n.inputs!=null&&(s.inputParams=n.inputs.reduce((r,a)=>(r[a.name]={type:a.type,inputIndexStart:a.start,inputIndexEnd:a.end},r),{})),n.attrs!=null&&(s.attrParams=n.attrs.reduce((r,a)=>{const i=a.type;let o;switch(a.type){case"string":o=Lm(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=Lm(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"string[]":o=Gm(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=Gm(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number":o=Bm(e.attr,a.tfName,a.defaultValue||0),o===void 0&&a.tfDeprecatedName&&(o=Bm(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number[]":o=Um(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=Um(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool":o=Pm(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=Pm(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool[]":o=qm(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=qm(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape":o=Wm(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=Wm(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape[]":o=Hm(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=Hm(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype":o=Mm(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=Mm(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype[]":o=Vm(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=Vm(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"func":o=K1(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=K1(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${a.type} for op: ${e.op}`)}return r[a.name]={value:o,type:i},r},{})),s}mapFunction(e){const n=e.nodeDef,s=[],r=[];let a={};n!=null&&(a=n.reduce((d,h)=>(d[h.name]=this.mapNode(h),h.op==="Const"&&r.push(d[h.name]),d),{}));const i=[],o=[];e.signature.inputArg.forEach(d=>{const[h]=Ir(d.name),p={name:h,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:i0(d.type),type:"dtype"}},children:[]};p.signatureKey=d.name,i.push(p),a[h]=p}),Object.keys(a).forEach(d=>{const h=a[d];h.inputNames.forEach((p,f)=>{const[m,,g]=Ir(p),y=a[m];if(y.outputs!=null){const b=y.outputs.indexOf(g);if(b!==-1){const $=`${m}:${b}`;h.inputNames[f]=$}}h.inputs.push(y),y.children.push(h)})});const l=e.ret;e.signature.outputArg.forEach(d=>{const[h,p]=Ir(l[d.name]),f=a[h];f!=null&&(f.defaultOutput=p,o.push(f))});const c=this.mapArgsToSignature(e);return{nodes:a,inputs:i,outputs:o,weights:r,placeholders:s,signature:c}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((n,s)=>(n[s.name]=this.mapArgToTensorInfo(s),n),{}),outputs:e.signature.outputArg.reduce((n,s)=>(n[s.name]=this.mapArgToTensorInfo(s,e.ret),n),{})}}mapArgToTensorInfo(e,n){let s=e.name;return n!=null&&(s=n[s]),{name:s,dtype:e.type}}}function Cj(t){const e=te().global;if(typeof e.atob<"u")return e.atob(t);if(typeof Buffer<"u")return new Buffer(t,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function yN(t,e){const n=Array.isArray(t)?String.fromCharCode.apply(null,t):Cj(t);return e?n:n.toLowerCase()}function Lm(t,e,n,s=!1){const r=t[e];return r!=null?yN(r.s,s):n}function Pm(t,e,n){const s=t[e];return s?s.b:n}function Bm(t,e,n){const s=t[e]||{},r=s.i!=null?s.i:s.f!=null?s.f:n;return typeof r=="number"?r:parseInt(r,10)}function i0(t){switch(typeof t=="string"&&(t=Mn[t]),t){case Mn.DT_FLOAT:case Mn.DT_HALF:return"float32";case Mn.DT_INT32:case Mn.DT_INT64:case Mn.DT_INT8:case Mn.DT_UINT8:return"int32";case Mn.DT_BOOL:return"bool";case Mn.DT_DOUBLE:return"float32";case Mn.DT_STRING:return"string";case Mn.DT_COMPLEX64:case Mn.DT_COMPLEX128:return"complex64";default:return null}}function K1(t,e,n){const s=t[e];return s&&s.func?s.func.name:n}function Mm(t,e,n){const s=t[e];return s&&s.type?i0(s.type):n}function Vm(t,e,n){const s=t[e];return s&&s.list&&s.list.type?s.list.type.map(r=>i0(r)):n}function bN(t){if(!t.unknownRank)return t.dim!=null?t.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function Wm(t,e,n){const s=t[e];return s&&s.shape?bN(s.shape):n}function Um(t,e,n){const s=t[e];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(r=>typeof r=="number"?r:parseInt(r,10)):n}function Gm(t,e,n,s=!1){const r=t[e];return r&&r.list&&r.list.s?r.list.s.map(a=>yN(a,s)):n}function Hm(t,e,n){const s=t[e];return s&&s.list&&s.list.shape?s.list.shape.map(r=>bN(r)):n}function qm(t,e,n){const s=t[e];return s&&s.list&&s.list.b?s.list.b:n}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Tj{constructor(e,n,s){this.node=e,this.tensorMap=n,this.context=s,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(r=>this.getInput(r)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((r,a)=>(r[a]=this.getAttr(a),r),{}))}getInput(e){return ln(e,this.tensorMap,this.context)}getAttr(e,n){const s=this.node.rawAttrs[e];if(s.tensor!=null)return ln(e,this.tensorMap,this.context);if(s.i!=null||s.f!=null)return Bm(this.node.rawAttrs,e,n);if(s.s!=null)return Lm(this.node.rawAttrs,e,n);if(s.b!=null)return Pm(this.node.rawAttrs,e,n);if(s.shape!=null)return Wm(this.node.rawAttrs,e,n);if(s.type!=null)return Mm(this.node.rawAttrs,e,n);if(s.list!=null){if(s.list.i!=null||s.list.f!=null)return Um(this.node.rawAttrs,e,n);if(s.list.s!=null)return Gm(this.node.rawAttrs,e,n);if(s.list.shape!=null)return Hm(this.node.rawAttrs,e,n);if(s.list.b!=null)return qm(this.node.rawAttrs,e,n);if(s.list.type!=null)return Vm(this.node.rawAttrs,e,n)}return n}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mn=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:LI,abs:Ut,acos:t_,acosh:n_,add:le,addN:qL,all:Ty,any:Gc,argMax:Ki,argMin:s_,asin:r_,asinh:a_,atan:i_,atan2:o_,atanh:u_,avgPool:Ih,avgPool3d:l_,basicLSTMCell:mP,batchNorm:bl,batchNorm2d:c_,batchNorm3d:d_,batchNorm4d:h_,batchToSpaceND:_h,bincount:p_,bitwiseAnd:IP,booleanMaskAsync:uV,broadcastArgs:kP,broadcastTo:Ui,buffer:qe,cast:ge,ceil:f_,clipByValue:qn,clone:Tr,complex:ra,concat:Wt,concat1d:m_,concat2d:g_,concat3d:y_,concat4d:b_,conv1d:Ey,conv2d:oa,conv2dTranspose:Ry,conv3d:x_,conv3dTranspose:$_,cos:kh,cosh:Dy,cosineWindow:rb,cumprod:Hc,cumsum:Oy,denseBincount:vm,depthToSpace:v_,depthwiseConv2d:xl,diag:XP,dilation2d:S_,div:Te,divNoNan:I_,dot:__,dropout:Z_,einsum:zi,elu:wl,enclosingPowerOfTwo:Q_,ensureShape:aB,equal:Ks,erf:Fy,euclideanNorm:T_,exp:jn,expandDims:_n,expm1:N_,eye:Ly,fft:Mh,fill:co,floor:vl,floorDiv:Cy,fused:EV,gather:Sl,gatherND:bV,greater:Qn,greaterEqual:wa,ifft:lu,imag:Ch,image:ys,inTopKAsync:vV,irfft:Qy,isFinite:E_,isInf:A_,isNaN:R_,leakyRelu:Th,less:iu,lessEqual:gi,linalg:ik,linspace:AB,localResponseNormalization:D_,log:rs,log1p:Nh,logSigmoid:O_,logSoftmax:Py,logSumExp:Eh,logicalAnd:mr,logicalNot:Ah,logicalOr:By,logicalXor:F_,losses:oU,lowerBound:jB,matMul:Qe,max:$s,maxPool:Rh,maxPool3d:z_,maxPoolWithArgmax:ZB,maximum:zr,mean:Rt,meshgrid:eM,min:au,minimum:ai,mirrorPad:L_,mod:P_,moments:Dh,movingAverage:dV,mul:j,multiRNNCell:iM,multinomial:uM,neg:It,norm:$l,notEqual:Yi,oneHot:Vy,ones:Un,onesLike:as,op:U,outerProduct:pM,pad:$a,pad1d:gM,pad2d:bM,pad3d:wM,pad4d:vM,pool:B_,pow:Er,prelu:Fh,print:e_,prod:M_,raggedGather:EM,raggedRange:RM,raggedTensorToTensor:OM,rand:zM,randomGamma:r4,randomNormal:Uy,randomStandardNormal:o4,randomUniform:yi,randomUniformInt:c4,range:Zi,real:ou,reciprocal:V_,relu:xr,relu6:Gy,reshape:K,reverse:Ss,reverse1d:y4,reverse2d:x4,reverse3d:$4,reverse4d:S4,rfft:Vh,round:Hy,rsqrt:qy,scalar:Re,scatterND:pV,searchSorted:My,selu:jy,separableConv2d:Ky,setdiff1dAsync:N4,sigmoid:dr,sign:W_,signal:iU,sin:Xy,sinh:Yy,slice:nt,slice1d:Lh,slice2d:Zy,slice3d:Ph,slice4d:uu,softmax:Bh,softplus:ho,spaceToBatchND:Oh,sparse:uU,sparseToDense:gV,spectral:aU,split:Gn,sqrt:hn,square:xt,squaredDifference:Jy,squeeze:bi,stack:Kn,step:po,stridedSlice:U_,string:lU,sub:we,sum:Ie,tan:G_,tanh:ri,tensor:Hs,tensor1d:Cn,tensor2d:eu,tensor3d:H_,tensor4d:X4,tensor5d:Y4,tensor6d:Z4,tensorScatterUpdate:J4,tile:gs,topk:j_,transpose:st,truncatedNormal:tb,unique:K_,unsortedSegmentSum:nb,unstack:Is,upperBound:aV,variable:X_,where:bn,whereAsync:Y_,zeros:Gt,zerosLike:rt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nj=(t,e,n,s=mn)=>{switch(t.op){case"BiasAdd":case"AddV2":case"Add":return[s.add(_("a",t,e,n),_("b",t,e,n))];case"AddN":return[s.addN(_("tensors",t,e,n))];case"FloorMod":case"Mod":return[s.mod(_("a",t,e,n),_("b",t,e,n))];case"Mul":return[s.mul(_("a",t,e,n),_("b",t,e,n))];case"RealDiv":case"Div":return[s.div(_("a",t,e,n),_("b",t,e,n))];case"DivNoNan":return[s.divNoNan(_("a",t,e,n),_("b",t,e,n))];case"FloorDiv":return[s.floorDiv(_("a",t,e,n),_("b",t,e,n))];case"Sub":return[s.sub(_("a",t,e,n),_("b",t,e,n))];case"Minimum":return[s.minimum(_("a",t,e,n),_("b",t,e,n))];case"Maximum":return[s.maximum(_("a",t,e,n),_("b",t,e,n))];case"Pow":return[s.pow(_("a",t,e,n),_("b",t,e,n))];case"SquaredDifference":return[s.squaredDifference(_("a",t,e,n),_("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ej=(t,e,n,s=mn)=>{switch(t.op){case"Abs":case"ComplexAbs":return[s.abs(_("x",t,e,n))];case"Acos":return[s.acos(_("x",t,e,n))];case"Acosh":return[s.acosh(_("x",t,e,n))];case"Asin":return[s.asin(_("x",t,e,n))];case"Asinh":return[s.asinh(_("x",t,e,n))];case"Atan":return[s.atan(_("x",t,e,n))];case"Atan2":return[s.atan2(_("x",t,e,n),_("y",t,e,n))];case"Atanh":return[s.atanh(_("x",t,e,n))];case"Ceil":return[s.ceil(_("x",t,e,n))];case"Complex":return[s.complex(_("real",t,e,n),_("imag",t,e,n))];case"Cos":return[s.cos(_("x",t,e,n))];case"Cosh":return[s.cosh(_("x",t,e,n))];case"Elu":return[s.elu(_("x",t,e,n))];case"Erf":return[s.erf(_("x",t,e,n))];case"Exp":return[s.exp(_("x",t,e,n))];case"Expm1":return[s.expm1(_("x",t,e,n))];case"Floor":return[s.floor(_("x",t,e,n))];case"Log":return[s.log(_("x",t,e,n))];case"Log1p":return[s.log1p(_("x",t,e,n))];case"Imag":return[s.imag(_("x",t,e,n))];case"Neg":return[s.neg(_("x",t,e,n))];case"Reciprocal":return[s.reciprocal(_("x",t,e,n))];case"Real":return[s.real(_("x",t,e,n))];case"Relu":return[s.relu(_("x",t,e,n))];case"Round":return[s.round(_("x",t,e,n))];case"Selu":return[s.selu(_("x",t,e,n))];case"Sigmoid":return[s.sigmoid(_("x",t,e,n))];case"Sin":return[s.sin(_("x",t,e,n))];case"Sign":return[s.sign(_("x",t,e,n))];case"Sinh":return[s.sinh(_("x",t,e,n))];case"Softplus":return[s.softplus(_("x",t,e,n))];case"Sqrt":return[s.sqrt(_("x",t,e,n))];case"Square":return[s.square(_("x",t,e,n))];case"Tanh":return[s.tanh(_("x",t,e,n))];case"Tan":return[s.tan(_("x",t,e,n))];case"ClipByValue":return[s.clipByValue(_("x",t,e,n),_("clipValueMin",t,e,n),_("clipValueMax",t,e,n))];case"Relu6":return[s.relu6(_("x",t,e,n))];case"Rsqrt":return[s.rsqrt(ln(t.inputNames[0],e,n))];case"LeakyRelu":return[s.leakyRelu(_("x",t,e,n),_("alpha",t,e,n))];case"Prelu":return[s.prelu(_("x",t,e,n),_("alpha",t,e,n))];case"IsNan":return[s.isNaN(ln(t.inputNames[0],e,n))];case"IsInf":return[s.isInf(ln(t.inputNames[0],e,n))];case"IsFinite":return[s.isFinite(ln(t.inputNames[0],e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fs(t,e,n=""){if(!(typeof t=="number"||typeof e=="number")){O(t.length===e.length,()=>n+` Shapes ${t} and ${e} must match`);for(let s=0;s<t.length;s++){const r=t[s],a=e[s];O(r<0||a<0||r===a,()=>n+` Shapes ${t} and ${e} must match`)}}}function X1(t){return!(typeof t=="number"||t.some(e=>e<0))}function Ro(t,e,n){let s=jm(t,n);const r=!X1(s);if(r&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(r&&e.forEach(a=>{s=jm(a.shape,s)}),!X1(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function jm(t,e){if(typeof t=="number")return e;if(typeof e=="number")return t;if(t.length!==e.length)throw new Error(`Incompatible ranks during merge: ${t} vs. ${e}`);const n=[];for(let s=0;s<t.length;++s){const r=t[s],a=e[s];if(r>=0&&a>=0&&r!==a)throw new Error(`Incompatible shape during merge: ${t} vs. ${e}`);n[s]=r>=0?r:a}return n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Aj{constructor(e,n,s,r,a,i,o){this.name=e,this.dtype=n,this.maxSize=s,this.elementShape=r,this.identicalElementShapes=a,this.dynamicSize=i,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=Re(0),tn(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(n=>{(e==null||!e.has(n.tensor.id))&&n.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const n=this.tensors[e];if(n.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(n.cleared=!0),n.read=!0,n.tensor}readMany(e){return e.map(n=>this.read(n))}write(e,n){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[e]||{};if(n.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${n.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=n.shape),fs(this.elementShape,n.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);s.tensor=n,tn(n),s.written=!0,this.tensors[e]=s}writeMany(e,n){if(e.length!==n.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${n.length}.`);e.forEach((s,r)=>this.write(s,n[r]))}gather(e,n){if(n&&n!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${n}`);if(e)e=e.slice(0,this.size());else{e=[];for(let r=0;r<this.size();r++)e.push(r)}if(e.length===0)return Hs([],[0].concat(this.elementShape));const s=this.readMany(e);return fs(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),Kn(s,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Hs([],[0].concat(this.elementShape));const n=[];for(let r=0;r<this.size();r++)n.push(r);const s=this.readMany(n);return fs(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),Wt(s,0)}scatter(e,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const s=Math.max(...e);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(e,Is(n,0))}split(e,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);let s=0;const r=e.map(u=>(s+=u,s));if(s!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${n.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const a=s===0?0:n.size/s,i=[];ee(()=>{n=K(n,[1,s,a]);for(let u=0;u<e.length;++u){const c=[0,u===0?0:r[u-1],0],d=[1,e[u],a];i[u]=K(nt(n,c,d),this.elementShape)}return i});const o=[];for(let u=0;u<e.length;u++)o[u]=u;this.writeMany(o,i)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ui{get id(){return this.idTensor.id}constructor(e,n,s,r=-1){this.tensors=e,this.elementShape=n,this.elementDtype=s,e!=null&&e.forEach(a=>{if(s!==a.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${a.dtype}`);fs(n,a.shape,"TensorList shape mismatch: "),tn(a)}),this.idTensor=Re(0),this.maxNumElements=r,tn(this.idTensor)}copy(){return new ui([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(n=>{(e==null||!e.has(n.id))&&n.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,n,s=-1){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(s!==-1&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);fs(e,this.elementShape,"TensorList shape mismatch: ");const r=Ro(this.elementShape,this.tensors,e);return ee(()=>{const a=this.tensors.map(i=>K(i,r));return Kn(a,0)})}popBack(e,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const s=Ro(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,fs(r.shape,e,"TensorList shape mismatch: "),K(r,s)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(fs(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");tn(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const n=new ui([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=e;for(let s=0;s<Math.min(this.tensors.length,e);++s)n.tensors[s]=this.tensors[s];return n}getItem(e,n,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);fs(this.tensors[e].shape,n,"TensorList shape mismatch: ");const r=Ro(this.elementShape,this.tensors,n);return K(this.tensors[e],r)}setItem(e,n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);fs(this.elementShape,n.shape,"TensorList shape mismatch: "),tn(n),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=n}gather(e,n,s){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);fs(this.elementShape,s,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=Ro(this.elementShape,this.tensors,s);return e.length===0?Hs([],[0].concat(r)):ee(()=>{const a=e.map(i=>K(this.tensors[i],r));return Kn(a,0)})}concat(e,n){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);fs(this.elementShape,n,"TensorList shape mismatch: ");const s=Ro(this.elementShape,this.tensors,n);return this.size()===0?Hs([],[0].concat(s)):ee(()=>{const r=this.tensors.map(a=>K(a,s));return Wt(r,0)})}}function Rj(t,e,n){const s=t.dtype;if(t.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${t.shape}`);if(t.dtype!==n)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${n}`);const r=t.shape.slice(1);fs(r,e,"TensorList shape mismatch: ");const a=Is(t);return new ui(a,e,s)}function Dj(t,e,n,s){return new ui([],t,e,s)}function Oj(t,e,n,s){if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const r=Math.max(...e);if(s!=null&&s!==-1&&r>=s)throw new Error(`Max index must be < array size (${r}  vs. ${s})`);const a=new ui([],n,t.dtype,s),i=Is(t,0);return e.forEach((o,u)=>{a.setItem(o,i[u])}),a}function Fj(t,e,n){let s=0;const r=e.map(c=>(s+=c,s));if(s!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${t.shape}`);const a=t.shape.slice(1),i=jm(a,n),o=s===0?0:t.size/s,u=ee(()=>{const c=[];t=K(t,[1,s,o]);for(let d=0;d<e.length;++d){const p=[0,d===0?0:r[d-1],0],f=[1,e[d],o];c[d]=K(nt(t,p,f),i)}return t.dispose(),c}),l=new ui([],n,t.dtype,e.length);for(let c=0;c<u.length;c++)l.setItem(c,u[c]);return l}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zj=async(t,e,n)=>{switch(t.op){case"If":case"StatelessIf":{const s=_("thenBranch",t,e,n),r=_("elseBranch",t,e,n),a=_("cond",t,e,n),i=_("args",t,e,n);return(await a.data())[0]?n.functionMap[s].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const s=_("body",t,e,n),r=_("cond",t,e,n),a=_("args",t,e,n),i=await n.functionMap[r].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap),o=a.map(c=>c.id);let u=await i[0].data();i.forEach(c=>{!c.kept&&o.indexOf(c.id)===-1&&c.dispose()});let l=a;for(;u[0];){const c=l;l=await n.functionMap[s].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);const d=l.map(p=>p.id);c.forEach(p=>{!p.kept&&o.indexOf(p.id)===-1&&d.indexOf(p.id)===-1&&p.dispose()});const h=await n.functionMap[r].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);u=await h[0].data(),h.forEach(p=>{!p.kept&&o.indexOf(p.id)===-1&&d.indexOf(p.id)===-1&&p.dispose()})}return l}case"LoopCond":{const s=_("pred",t,e,n);return[_r(s)]}case"Switch":{const s=_("pred",t,e,n);let r=_("data",t,e,n);return r.kept||(r=_r(r)),(await s.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{const s=t.inputNames.find(r=>ln(r,e,n)!==void 0);if(s){const r=ln(s,e,n);return[_r(r)]}return}case"Enter":{const s=_("frameName",t,e,n),r=_("tensor",t,e,n);return n.enterFrame(s),[_r(r)]}case"Exit":{const s=_("tensor",t,e,n);return n.exitFrame(),[_r(s)]}case"NextIteration":{const s=_("tensor",t,e,n);return n.nextIteration(),[_r(s)]}case"TensorArrayV3":{const s=_("size",t,e,n),r=_("dtype",t,e,n),a=_("elementShape",t,e,n),i=_("dynamicSize",t,e,n),o=_("clearAfterRead",t,e,n),u=_("identicalElementShapes",t,e,n),l=_("name",t,e,n),c=new Aj(l,r,s,a,u,i,o);return n.addTensorArray(c),[c.idTensor,Re(1)]}case"TensorArrayWriteV3":{const s=_("tensorArrayId",t,e,n),r=_("index",t,e,n),a=_("tensor",t,e,n),i=n.getTensorArray(s.id);return i.write(r,a),[i.idTensor]}case"TensorArrayReadV3":{const s=_("tensorArrayId",t,e,n),r=_("index",t,e,n);return[n.getTensorArray(s.id).read(r)]}case"TensorArrayGatherV3":{const s=_("tensorArrayId",t,e,n),r=_("indices",t,e,n),a=_("dtype",t,e,n);return[n.getTensorArray(s.id).gather(r,a)]}case"TensorArrayScatterV3":{const s=_("tensorArrayId",t,e,n),r=_("indices",t,e,n),a=_("tensor",t,e,n),i=n.getTensorArray(s.id);return i.scatter(r,a),[i.idTensor]}case"TensorArrayConcatV3":{const s=_("tensorArrayId",t,e,n),r=n.getTensorArray(s.id),a=_("dtype",t,e,n);return[r.concat(a)]}case"TensorArraySplitV3":{const s=_("tensorArrayId",t,e,n),r=_("tensor",t,e,n),a=_("lengths",t,e,n),i=n.getTensorArray(s.id);return i.split(a,r),[i.idTensor]}case"TensorArraySizeV3":{const s=_("tensorArrayId",t,e,n),r=n.getTensorArray(s.id);return[Re(r.size(),"int32")]}case"TensorArrayCloseV3":{const s=_("tensorArrayId",t,e,n),r=n.getTensorArray(s.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{const s=_("tensorListId",t,e,n),r=_("index",t,e,n),a=_("tensor",t,e,n),i=n.getTensorList(s.id);return i.setItem(r,a),[i.idTensor]}case"TensorListGetItem":{const s=_("tensorListId",t,e,n),r=_("index",t,e,n),a=_("elementShape",t,e,n),i=_("elementDType",t,e,n);return[n.getTensorList(s.id).getItem(r,a,i)]}case"TensorListScatterV2":case"TensorListScatter":{const s=_("indices",t,e,n),r=_("tensor",t,e,n),a=_("elementShape",t,e,n),i=_("numElements",t,e,n),o=Oj(r,s,a,i);return n.addTensorList(o),[o.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=_("elementShape",t,e,n),r=_("elementDType",t,e,n);let a;t.op==="TensorListReserve"?a="numElements":a="maxNumElements";const i=_(a,t,e,n),o=t.op==="TensorListReserve"?-1:i,u=Dj(s,r,i,o);return n.addTensorList(u),[u.idTensor]}case"TensorListGather":{const s=_("tensorListId",t,e,n),r=_("indices",t,e,n),a=_("elementShape",t,e,n),i=_("elementDType",t,e,n);return[n.getTensorList(s.id).gather(r,i,a)]}case"TensorListStack":{const s=_("tensorListId",t,e,n),r=_("elementShape",t,e,n),a=_("elementDType",t,e,n),i=_("numElements",t,e,n);return[n.getTensorList(s.id).stack(r,a,i)]}case"TensorListFromTensor":{const s=_("tensor",t,e,n),r=_("elementShape",t,e,n),a=_("elementDType",t,e,n),i=Rj(s,r,a);return n.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=_("tensorListId",t,e,n),r=n.getTensorList(s.id),a=_("dtype",t,e,n),i=_("elementShape",t,e,n);return[r.concat(a,i)]}case"TensorListPushBack":{const s=_("tensorListId",t,e,n),r=_("tensor",t,e,n),a=n.getTensorList(s.id);return a.pushBack(r),[a.idTensor]}case"TensorListPopBack":{const s=_("tensorListId",t,e,n),r=_("elementShape",t,e,n),a=_("elementDType",t,e,n);return[n.getTensorList(s.id).popBack(r,a)]}case"TensorListSplit":{const s=_("tensor",t,e,n),r=_("elementShape",t,e,n),a=_("lengths",t,e,n),i=Fj(s,a,r);return n.addTensorList(i),[i.idTensor]}case"TensorListLength":{const s=_("tensorListId",t,e,n),r=n.getTensorList(s.id);return[Re(r.size(),"int32")]}case"TensorListResize":{const s=_("tensorListId",t,e,n),r=_("size",t,e,n),i=n.getTensorList(s.id).resize(r);return n.addTensorList(i),[i.idTensor]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y1(t,e,n){const[s,r]=_("fusedOps",t,e,n),a=s==="biasadd",i=!a,o=r==="prelu",u=s==="fusedbatchnorm",l=_("numArgs",t,e,n);if(a){if(o&&l!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&a&&l!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=_("strides",t,e,n),d=Dc(t,e,n),h=_("dataFormat",t,e,n).toUpperCase(),p=_("dilations",t,e,n);let[f,m]=_("args",t,e,n);i&&(m=f,f=void 0);const g=_("leakyreluAlpha",t,e,n);return{stride:c,pad:d,dataFormat:h,dilations:p,biasArg:f,preluArg:m,activationFunc:r,leakyreluAlpha:g}}const Lj=(t,e,n,s=mn)=>{switch(t.op){case"Conv1D":{const r=_("stride",t,e,n),a=_("pad",t,e,n),i=_("dataFormat",t,e,n).toUpperCase(),o=_("dilation",t,e,n);return[s.conv1d(_("x",t,e,n),_("filter",t,e,n),r,a,i,o)]}case"Conv2D":{const r=_("strides",t,e,n),a=Dc(t,e,n),i=_("dataFormat",t,e,n).toUpperCase(),o=_("dilations",t,e,n);return[s.conv2d(_("x",t,e,n),_("filter",t,e,n),[r[1],r[2]],a,i,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:r,pad:a,dataFormat:i,dilations:o,biasArg:u,preluArg:l,activationFunc:c,leakyreluAlpha:d}=Y1(t,e,n);return[s.fused.conv2d({x:_("x",t,e,n),filter:_("filter",t,e,n),strides:[r[1],r[2]],pad:a,dataFormat:i,dilations:[o[1],o[2]],bias:u,activation:c,preluActivationWeights:l,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:a,dataFormat:i,dilations:o,biasArg:u,preluArg:l,activationFunc:c,leakyreluAlpha:d}=Y1(t,e,n);return[s.fused.depthwiseConv2d({x:_("x",t,e,n),filter:_("filter",t,e,n),strides:[r[1],r[2]],pad:a,dataFormat:i,dilations:[o[1],o[2]],bias:u,activation:c,preluActivationWeights:l,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=_("outputShape",t,e,n),a=_("strides",t,e,n),i=Dc(t,e,n);return[s.conv2dTranspose(_("x",t,e,n),_("filter",t,e,n),r,[a[1],a[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=_("strides",t,e,n),a=Dc(t,e,n),i=_("dilations",t,e,n),o=_("dataFormat",t,e,n).toUpperCase();return[s.depthwiseConv2d(_("input",t,e,n),_("filter",t,e,n),[r[1],r[2]],a,o,[i[1],i[2]])]}case"Conv3D":{const r=_("strides",t,e,n),a=_("pad",t,e,n),i=_("dataFormat",t,e,n).toUpperCase(),o=_("dilations",t,e,n);return[s.conv3d(_("x",t,e,n),_("filter",t,e,n),[r[1],r[2],r[3]],a,i,[o[1],o[2],o[3]])]}case"AvgPool":{const r=_("strides",t,e,n),a=_("pad",t,e,n),i=_("kernelSize",t,e,n);return[s.avgPool(_("x",t,e,n),[i[1],i[2]],[r[1],r[2]],a)]}case"MaxPool":{const r=_("strides",t,e,n),a=_("pad",t,e,n),i=_("kernelSize",t,e,n);return[s.maxPool(_("x",t,e,n),[i[1],i[2]],[r[1],r[2]],a)]}case"MaxPoolWithArgmax":{const r=_("strides",t,e,n),a=_("pad",t,e,n),i=_("kernelSize",t,e,n),o=_("includeBatchInIndex",t,e,n),{result:u,indexes:l}=s.maxPoolWithArgmax(_("x",t,e,n),[i[1],i[2]],[r[1],r[2]],a,o);return[u,l]}case"AvgPool3D":{const r=_("strides",t,e,n),a=_("pad",t,e,n),i=_("kernelSize",t,e,n);return[s.avgPool3d(_("x",t,e,n),[i[1],i[2],i[3]],[r[1],r[2],r[3]],a)]}case"MaxPool3D":{const r=_("strides",t,e,n),a=_("pad",t,e,n),i=_("kernelSize",t,e,n);return[s.maxPool3d(_("x",t,e,n),[i[1],i[2],i[3]],[r[1],r[2],r[3]],a)]}case"Dilation2D":{const r=_("strides",t,e,n),a=_("pad",t,e,n),i=_("dilations",t,e,n),o=r[1],u=r[2],l=i[1],c=i[2];return[s.dilation2d(_("x",t,e,n),_("filter",t,e,n),[o,u],a,[l,c],"NHWC")]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pj=(t,e,n,s=mn)=>{switch(t.op){case"Fill":{const r=_("shape",t,e,n),a=_("dtype",t,e,n),i=_("value",t,e,n);return[s.fill(r,i,a)]}case"LinSpace":{const r=_("start",t,e,n),a=_("stop",t,e,n),i=_("num",t,e,n);return[s.linspace(r,a,i)]}case"Multinomial":{const r=_("logits",t,e,n),a=_("numSamples",t,e,n),i=_("seed",t,e,n);return[s.multinomial(r,a,i)]}case"OneHot":{const r=_("indices",t,e,n),a=_("depth",t,e,n),i=_("onValue",t,e,n),o=_("offValue",t,e,n),u=_("dtype",t,e,n);return[s.oneHot(r,a,i,o,u)]}case"Ones":return[s.ones(_("shape",t,e,n),_("dtype",t,e,n))];case"OnesLike":return[s.onesLike(_("x",t,e,n))];case"RandomStandardNormal":return[s.randomStandardNormal(_("shape",t,e,n),_("dtype",t,e,n),_("seed",t,e,n))];case"RandomUniform":return[s.randomUniform(_("shape",t,e,n),_("minval",t,e,n),_("maxval",t,e,n),_("dtype",t,e,n))];case"RandomUniformInt":return[s.randomUniformInt(_("shape",t,e,n),_("minval",t,e,n),_("maxval",t,e,n),_("seed",t,e,n))];case"Range":{const r=_("start",t,e,n),a=_("stop",t,e,n),i=_("step",t,e,n);return[s.range(r,a,i,_("dtype",t,e,n))]}case"TruncatedNormal":{const r=_("shape",t,e,n),a=_("mean",t,e,n),i=_("stdDev",t,e,n),o=_("seed",t,e,n);return[s.truncatedNormal(r,a,i,_("dtype",t,e,n),o)]}case"Zeros":return[s.zeros(_("shape",t,e,n),_("dtype",t,e,n))];case"ZerosLike":return[s.zerosLike(_("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qp(t,e,n){const s=_("boxes",t,e,n),r=_("scores",t,e,n),a=_("maxOutputSize",t,e,n),i=_("iouThreshold",t,e,n),o=_("scoreThreshold",t,e,n),u=_("softNmsSigma",t,e,n);return{boxes:s,scores:r,maxOutputSize:a,iouThreshold:i,scoreThreshold:o,softNmsSigma:u}}const Bj=async(t,e,n,s,r=mn)=>{switch(t.op){case"NonMaxSuppressionV5":{const{boxes:a,scores:i,maxOutputSize:o,iouThreshold:u,scoreThreshold:l,softNmsSigma:c}=Qp(t,e,n),d=await r.image.nonMaxSuppressionWithScoreAsync(a,i,o,u,l,c);return[d.selectedIndices,d.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:a,scores:i,maxOutputSize:o,iouThreshold:u,scoreThreshold:l}=Qp(t,e,n),c=_("padToMaxOutputSize",t,e,n),d=await r.image.nonMaxSuppressionPaddedAsync(a,i,o,u,l,c);return[d.selectedIndices,d.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:a,scores:i,maxOutputSize:o,iouThreshold:u,scoreThreshold:l}=Qp(t,e,n);return[await r.image.nonMaxSuppressionAsync(a,i,o,u,l)]}case"Where":{const a=r.cast(_("condition",t,e,n),"bool"),i=[await r.whereAsync(a)];return a.dispose(),i}case"ListDiff":return r.setdiff1dAsync(_("x",t,e,n),_("y",t,e,n));default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mj=(t,e,n,s=mn)=>{switch(t.op){case"LowerBound":{const r=_("sortedSequence",t,e,n),a=_("values",t,e,n);return[s.lowerBound(r,a)]}case"TopKV2":{const r=_("x",t,e,n),a=_("k",t,e,n),i=_("sorted",t,e,n),o=s.topk(r,a,i);return[o.values,o.indices]}case"UpperBound":{const r=_("sortedSequence",t,e,n),a=_("values",t,e,n);return[s.upperBound(r,a)]}case"Unique":{const r=_("x",t,e,n),a=s.unique(r);return[a.values,a.indices]}case"UniqueV2":{const r=_("x",t,e,n),a=_("axis",t,e,n),i=s.unique(r,a);return[i.values,i.indices]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vj=(t,e,n,s=mn)=>{switch(t.op){case"Const":return e[t.name];case"PlaceholderWithDefault":const r=_("default",t,e,n);return[ln(t.name,e,n)||r];case"Placeholder":return[ln(t.name,e,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const c=_("x",t,e,n);return[_r(c)]}case"IdentityN":return _("x",t,e,n).map(c=>_r(c));case"Snapshot":const a=_("x",t,e,n);return[_r(a)];case"Shape":return[s.tensor1d(_("x",t,e,n).shape,"int32")];case"ShapeN":return _("x",t,e,n).map(c=>s.tensor1d(c.shape));case"Size":return[s.scalar(_("x",t,e,n).size,"int32")];case"Rank":return[s.scalar(_("x",t,e,n).rank,"int32")];case"NoOp":return[s.scalar(1)];case"Print":const i=_("x",t,e,n),o=_("data",t,e,n),u=_("message",t,e,n),l=_("summarize",t,e,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(u);for(let c=0;c<o.length;c++)console.log(Array.prototype.slice.call(o[c].dataSync()).slice(0,l));return[i];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wj{get id(){return this.handle.id}constructor(e,n){this.keyDType=e,this.valueDType=n,this.handle=Re(0),this.tensorMap=new Map,tn(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Re(this.size(),"int32")}async import(e,n){this.checkKeyAndValueTensor(e,n);const s=await e.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),ee(()=>{const r=Is(n),a=s.length,i=r.length;O(a===i,()=>`The number of elements doesn't match, keys has ${a} elements, the values has ${i} elements.`);for(let o=0;o<a;o++){const u=s[o],l=r[o];tn(l),this.tensorMap.set(u,l)}return this.handle})}async find(e,n){this.checkKeyAndValueTensor(e,n);const s=await e.data();return ee(()=>{const r=[];for(let a=0;a<s.length;a++){const i=s[a],o=this.findWithDefault(i,n);r.push(o)}return Kn(r)})}findWithDefault(e,n){const s=this.tensorMap.get(e);return s??n}checkKeyAndValueTensor(e,n){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(n.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${n.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uj=async(t,e,n,s)=>{switch(t.op){case"HashTable":case"HashTableV2":{const r=s.getHashTableHandleByName(t.name);if(r!=null)return[r];{const a=_("keyDType",t,e,n),i=_("valueDType",t,e,n),o=new Wj(a,i);return s.addHashTable(t.name,o),[o.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const r=_("tableHandle",t,e,n,s),a=_("keys",t,e,n),i=_("values",t,e,n);return[await s.getHashTableById(r.id).import(a,i)]}case"LookupTableFind":case"LookupTableFindV2":{const r=_("tableHandle",t,e,n,s),a=_("keys",t,e,n),i=_("defaultValue",t,e,n);return[await s.getHashTableById(r.id).find(a,i)]}case"LookupTableSize":case"LookupTableSizeV2":{const r=_("tableHandle",t,e,n,s);return[s.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gj=(t,e,n,s=mn)=>{switch(t.op){case"ResizeBilinear":{const r=_("images",t,e,n),a=_("size",t,e,n),i=_("alignCorners",t,e,n),o=_("halfPixelCenters",t,e,n);return[s.image.resizeBilinear(r,[a[0],a[1]],i,o)]}case"ResizeNearestNeighbor":{const r=_("images",t,e,n),a=_("size",t,e,n),i=_("alignCorners",t,e,n),o=_("halfPixelCenters",t,e,n);return[s.image.resizeNearestNeighbor(r,[a[0],a[1]],i,o)]}case"CropAndResize":{const r=_("image",t,e,n),a=_("boxes",t,e,n),i=_("boxInd",t,e,n),o=_("cropSize",t,e,n),u=_("method",t,e,n),l=_("extrapolationValue",t,e,n);return[s.image.cropAndResize(r,a,i,o,u,l)]}case"ImageProjectiveTransformV3":{const r=_("images",t,e,n),a=_("transforms",t,e,n),i=_("outputShape",t,e,n),o=_("fillValue",t,e,n),u=_("interpolation",t,e,n),l=_("fillMode",t,e,n);return[s.image.transform(r,a,u.toLowerCase(),l.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hj=(t,e,n,s=mn)=>{switch(t.op){case"Equal":return[s.equal(_("a",t,e,n),_("b",t,e,n))];case"NotEqual":return[s.notEqual(_("a",t,e,n),_("b",t,e,n))];case"Greater":return[s.greater(_("a",t,e,n),_("b",t,e,n))];case"GreaterEqual":return[s.greaterEqual(_("a",t,e,n),_("b",t,e,n))];case"Less":return[s.less(_("a",t,e,n),_("b",t,e,n))];case"LessEqual":return[s.lessEqual(_("a",t,e,n),_("b",t,e,n))];case"LogicalAnd":return[s.logicalAnd(_("a",t,e,n),_("b",t,e,n))];case"LogicalNot":return[s.logicalNot(_("a",t,e,n))];case"LogicalOr":return[s.logicalOr(_("a",t,e,n),_("b",t,e,n))];case"Select":case"SelectV2":return[s.where(_("condition",t,e,n),_("a",t,e,n),_("b",t,e,n))];case"BitwiseAnd":return[s.bitwiseAnd(_("a",t,e,n),_("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qj=(t,e,n,s=mn)=>{switch(t.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[s.matMul(_("a",t,e,n),_("b",t,e,n),_("transposeA",t,e,n),_("transposeB",t,e,n))];case"Einsum":return[s.einsum(_("equation",t,e,n),..._("tensors",t,e,n))];case"Transpose":return[s.transpose(_("x",t,e,n),_("perm",t,e,n))];case"_FusedMatMul":const[r,a]=_("fusedOps",t,e,n),i=r==="biasadd",o=a==="prelu",u=_("numArgs",t,e,n),l=_("leakyreluAlpha",t,e,n);if(i){if(o&&u!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&u!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,d]=_("args",t,e,n);return[s.fused.matMul({a:_("a",t,e,n),b:_("b",t,e,n),transposeA:_("transposeA",t,e,n),transposeB:_("transposeB",t,e,n),bias:c,activation:a,preluActivationWeights:d,leakyreluAlpha:l})];case"MatrixBandPart":return[s.linalg.bandPart(_("a",t,e,n),_("numLower",t,e,n),_("numUpper",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jj=(t,e,n,s=mn)=>{switch(t.op){case"EuclideanNorm":return[s.euclideanNorm(_("x",t,e,n),_("axis",t,e,n),_("keepDims",t,e,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[s.batchNorm(_("x",t,e,n),_("mean",t,e,n),_("variance",t,e,n),_("offset",t,e,n),_("scale",t,e,n),_("epsilon",t,e,n))];case"FusedBatchNormV3":return[s.batchNorm(_("x",t,e,n),_("mean",t,e,n),_("variance",t,e,n),_("offset",t,e,n),_("scale",t,e,n),_("epsilon",t,e,n))];case"LRN":return[s.localResponseNormalization(_("x",t,e,n),_("radius",t,e,n),_("bias",t,e,n),_("alpha",t,e,n),_("beta",t,e,n))];case"Softmax":return[s.softmax(_("x",t,e,n))];case"LogSoftmax":return[s.logSoftmax(_("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kj=(t,e,n,s=mn)=>{switch(t.op){case"RaggedGather":{const{outputNestedSplits:r,outputDenseValues:a}=s.raggedGather(_("paramsNestedSplits",t,e,n),_("paramsDenseValues",t,e,n),_("indices",t,e,n),_("outputRaggedRank",t,e,n));return r.concat(a)}case"RaggedRange":{const{rtNestedSplits:r,rtDenseValues:a}=s.raggedRange(_("starts",t,e,n),_("limits",t,e,n),_("splits",t,e,n));return[r,a]}case"RaggedTensorToTensor":return[s.raggedTensorToTensor(_("shape",t,e,n),_("values",t,e,n),_("defaultValue",t,e,n),_("rowPartitionTensors",t,e,n),_("rowPartitionTypes",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xj=(t,e,n,s=mn)=>{switch(t.op){case"Max":{const o=_("axis",t,e,n),u=_("keepDims",t,e,n);return[s.max(_("x",t,e,n),o,u)]}case"Mean":{const o=_("axis",t,e,n),u=_("keepDims",t,e,n);return[s.mean(_("x",t,e,n),o,u)]}case"Min":{const o=_("axis",t,e,n),u=_("keepDims",t,e,n);return[s.min(_("x",t,e,n),o,u)]}case"Sum":{const o=_("axis",t,e,n),u=_("keepDims",t,e,n);return[s.sum(_("x",t,e,n),o,u)]}case"All":{const o=_("axis",t,e,n),u=_("keepDims",t,e,n);return[s.all(_("x",t,e,n),o,u)]}case"Any":{const o=_("axis",t,e,n),u=_("keepDims",t,e,n);return[s.any(_("x",t,e,n),o,u)]}case"ArgMax":{const o=_("axis",t,e,n);return[s.argMax(_("x",t,e,n),o)]}case"ArgMin":{const o=_("axis",t,e,n);return[s.argMin(_("x",t,e,n),o)]}case"Prod":{const o=_("axis",t,e,n),u=_("keepDims",t,e,n);return[s.prod(_("x",t,e,n),o,u)]}case"Cumprod":{const o=_("axis",t,e,n),u=_("exclusive",t,e,n),l=_("reverse",t,e,n);return[s.cumprod(_("x",t,e,n),o,u,l)]}case"Cumsum":{const o=_("axis",t,e,n),u=_("exclusive",t,e,n),l=_("reverse",t,e,n);return[s.cumsum(_("x",t,e,n),o,u,l)]}case"Bincount":const r=_("x",t,e,n),a=_("weights",t,e,n),i=_("size",t,e,n);return[s.bincount(r,a,i)];case"DenseBincount":{const o=_("x",t,e,n),u=_("weights",t,e,n),l=_("size",t,e,n),c=_("binaryOutput",t,e,n);return[s.denseBincount(o,u,l,c)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yj=(t,e,n,s=mn)=>{switch(t.op){case"ConcatV2":case"Concat":{const r=_("n",t,e,n),a=_("axis",t,e,n);let i=_("tensors",t,e,n);return i=i.slice(0,r),[s.concat(i,a)]}case"Gather":{const r=_("x",t,e,n),a=_("indices",t,e,n);return[s.gather(r,s.cast(a,"int32"),0)]}case"GatherV2":{const r=_("axis",t,e,n),a=_("batchDims",t,e,n),i=_("x",t,e,n),o=_("indices",t,e,n);return[s.gather(i,s.cast(o,"int32"),r,a)]}case"Reverse":{const r=_("dims",t,e,n),a=[];for(let o=0;o<r.length;o++)r[o]&&a.push(o);const i=_("x",t,e,n);return[s.reverse(i,a)]}case"ReverseV2":{const r=_("axis",t,e,n),a=_("x",t,e,n);return[s.reverse(a,r)]}case"Slice":{const r=_("begin",t,e,n),a=_("size",t,e,n);return[s.slice(_("x",t,e,n),r,a)]}case"StridedSlice":{const r=_("begin",t,e,n),a=_("end",t,e,n),i=_("strides",t,e,n),o=_("beginMask",t,e,n),u=_("endMask",t,e,n),l=_("ellipsisMask",t,e,n),c=_("newAxisMask",t,e,n),d=_("shrinkAxisMask",t,e,n),h=_("x",t,e,n);return[s.stridedSlice(h,r,a,i,o,u,l,c,d)]}case"Pack":return ee(()=>{const r=_("axis",t,e,n),a=_("tensors",t,e,n),i=a[0].shape,o=s.squeeze(a[0]).shape,u=a.map(l=>{const c=tt(l.shape,i);if(!c&&!tt(s.squeeze(l).shape,o))throw new Error("the input tensors shape does not match");return c?l:s.reshape(l,i)});return[s.stack(u,r)]});case"Unpack":{const r=_("axis",t,e,n),a=_("tensor",t,e,n);return s.unstack(a,r)}case"Tile":{const r=_("reps",t,e,n);return[s.tile(_("x",t,e,n),r)]}case"Split":case"SplitV":{const r=_("axis",t,e,n),a=_("numOrSizeSplits",t,e,n),i=_("x",t,e,n);return s.split(i,a,r)}case"ScatterNd":{const r=_("indices",t,e,n),a=_("values",t,e,n),i=_("shape",t,e,n);return[s.scatterND(r,a,i)]}case"GatherNd":{const r=_("x",t,e,n),a=_("indices",t,e,n);return[s.gatherND(r,a)]}case"SparseToDense":{const r=_("sparseIndices",t,e,n),a=_("outputShape",t,e,n),i=_("sparseValues",t,e,n),o=_("defaultValue",t,e,n);return[s.sparseToDense(r,i,a,i.dtype===o.dtype?o:s.cast(o,i.dtype))]}case"TensorScatterUpdate":{const r=_("indices",t,e,n),a=_("values",t,e,n),i=_("tensor",t,e,n);return[s.tensorScatterUpdate(i,r,a)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zj=(t,e,n,s=mn)=>{switch(t.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:a,emptyRowIndicator:i,reverseIndexMap:o}=s.sparse.sparseFillEmptyRows(_("indices",t,e,n),_("values",t,e,n),_("denseShape",t,e,n),_("defaultValue",t,e,n));return[r,a,i,o]}case"SparseReshape":{const{outputIndices:r,outputShape:a}=s.sparse.sparseReshape(_("inputIndices",t,e,n),_("inputShape",t,e,n),_("newShape",t,e,n));return[r,a]}case"SparseSegmentMean":return[s.sparse.sparseSegmentMean(_("data",t,e,n),_("indices",t,e,n),_("segmentIds",t,e,n))];case"SparseSegmentSum":return[s.sparse.sparseSegmentSum(_("data",t,e,n),_("indices",t,e,n),_("segmentIds",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qj=(t,e,n,s=mn)=>{switch(t.op){case"FFT":return[s.fft(_("x",t,e,n))];case"IFFT":return[s.ifft(_("x",t,e,n))];case"RFFT":return[s.rfft(_("x",t,e,n))];case"IRFFT":return[s.irfft(_("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jj=(t,e,n,s=mn)=>{switch(t.op){case"StaticRegexReplace":return[s.string.staticRegexReplace(_("input",t,e,n),_("pattern",t,e,n),_("rewrite",t,e,n),_("replaceGlobal",t,e,n))];case"StringNGrams":{const{nGrams:r,nGramsSplits:a}=s.string.stringNGrams(_("data",t,e,n),_("dataSplits",t,e,n),_("separator",t,e,n),_("nGramWidths",t,e,n),_("leftPad",t,e,n),_("rightPad",t,e,n),_("padWidth",t,e,n),_("preserveShortSequences",t,e,n));return[r,a]}case"StringSplit":{const{indices:r,values:a,shape:i}=s.string.stringSplit(_("input",t,e,n),_("delimiter",t,e,n),_("skipEmpty",t,e,n));return[r,a,i]}case"StringToHashBucketFast":return[s.string.stringToHashBucketFast(_("input",t,e,n),_("numBuckets",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eK=(t,e,n,s=mn)=>{switch(t.op){case"Cast":return[s.cast(_("x",t,e,n),_("dtype",t,e,n))];case"ExpandDims":{const r=_("axis",t,e,n);return[s.expandDims(_("x",t,e,n),r)]}case"Squeeze":{const r=_("axis",t,e,n);return[s.squeeze(_("x",t,e,n),r)]}case"Reshape":return[s.reshape(_("x",t,e,n),_("shape",t,e,n))];case"EnsureShape":return[s.ensureShape(_("x",t,e,n),_("shape",t,e,n))];case"MirrorPad":return[s.mirrorPad(_("x",t,e,n),_("padding",t,e,n),_("mode",t,e,n))];case"PadV2":case"Pad":return[s.pad(_("x",t,e,n),_("padding",t,e,n),_("constantValue",t,e,n))];case"SpaceToBatchND":{const r=_("blockShape",t,e,n),a=_("paddings",t,e,n);return[s.spaceToBatchND(_("x",t,e,n),r,a)]}case"BatchToSpaceND":{const r=_("blockShape",t,e,n),a=_("crops",t,e,n);return[s.batchToSpaceND(_("x",t,e,n),r,a)]}case"DepthToSpace":{const r=_("blockSize",t,e,n),a=_("dataFormat",t,e,n).toUpperCase();return[s.depthToSpace(_("x",t,e,n),r,a)]}case"BroadcastTo":return[s.broadcastTo(_("x",t,e,n),_("shape",t,e,n))];case"BroadcastArgs":return[s.broadcastArgs(_("s0",t,e,n),_("s1",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z1(t,e,n,s,r=ee){const a=((i,o,u)=>{switch(i.category){case"arithmetic":return r(()=>Nj(i,o,u));case"basic_math":return r(()=>Ej(i,o,u));case"control":return zj(i,o,u);case"convolution":return r(()=>Lj(i,o,u));case"creation":return r(()=>Pj(i,o,u));case"dynamic":return Bj(i,o,u);case"evaluation":return r(()=>Mj(i,o,u));case"image":return r(()=>Gj(i,o,u));case"graph":return r(()=>Vj(i,o,u));case"logical":return r(()=>Hj(i,o,u));case"matrices":return r(()=>qj(i,o,u));case"normalization":return r(()=>jj(i,o,u));case"ragged":return r(()=>Kj(i,o,u));case"reduction":return r(()=>Xj(i,o,u));case"slice_join":return r(()=>Yj(i,o,u));case"sparse":return r(()=>Zj(i,o,u));case"spectral":return r(()=>Qj(i,o,u));case"string":return r(()=>Jj(i,o,u));case"transformation":return r(()=>eK(i,o,u));case"hash_table":return Uj(i,o,u,s);case"custom":const l=gN(i.op);if(l&&l.customExecutor)return l.customExecutor(new Tj(i,o,u));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(t,e,n);return Qa(a)?a.then(i=>[].concat(i)):[].concat(a)}class Q1{constructor(e={},n={},s={},r={},a){this.weightMap=e,this.tensorArrayMap=n,this.tensorListMap=s,this.functionMap=r,this.parseNodeNameCache=a,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,n){return{id:e,frameName:n,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let n=0;n<this.contexts.length-1;n++){const s=this.contexts.slice(0,this.contexts.length-n);e.push(this.contextIdforContexts(s))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(n=>n.id===0&&n.iterationId===0?"":`${n.frameName}-${n.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const n in this.tensorArrayMap)this.tensorArrayMap[n].clearAndClose(e);for(const n in this.tensorListMap)this.tensorListMap[n].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J1(t,e,n,s){const r=new Set,a=[];let i=null,o=null;const u=new Set,l=new Set(Object.keys(t).map(h=>Vn(h)[0]));s=s||[];const c=new Set(s.map(h=>Vn(h.name)[0])),d=[...e];for(;d.length>0;){const h=d.pop();if((Ma(h)||uK(h)||lK(h))&&i==null&&(i=h,o=i.children.map(p=>p.name).filter(p=>r.has(p))),r.add(h.name),n[h.name]==null&&!l.has(h.name)&&!c.has(h.name)){if(h.inputs.length===0){a.push(h.name);continue}h.inputs.forEach(p=>{u.has(p.name)||(u.add(p.name),d.push(p))})}}return{inputs:t,outputs:e,usedNodes:r,missingInputs:a,dynamicNode:i,syncInputs:o}}function tK(t,e){const{usedNodes:n,inputs:s}=e,r=Object.keys(s).map(g=>Vn(g)[0]).map(g=>t.nodes[g]),a=t.initNodes||[],i=g=>n.has(typeof g=="string"?g:g.name);function o(g){return[...new Map(g.map(y=>[y.name,y])).values()]}const u=o([...r,...t.weights,...a]).filter(i),l=o([...u,...Object.values(t.nodes)]).filter(i),c=new Map(l.map(g=>[g.name,g])),d={};for(const g of l){d[g.name]=d[g.name]||0;for(const y of g.children)i(y)||(d[y.name]=Number.POSITIVE_INFINITY),d[y.name]=(d[y.name]||0)+1}const h=Object.entries(d).filter(([,g])=>g===0).map(([g])=>g),p=[...h];for(;h.length>0;){const g=h.pop(),y=c.get(g);for(const b of y.children.filter(i))--d[b.name]===0&&(p.push(b.name),h.push(b.name))}const f=p.map(g=>c.get(g)),m=nK(f,u);return sK(m,u),m}function nK(t,e){const n=new Map(t.map(i=>[i.name,i])),s=e.map(i=>i.name),r=new Set(s);for(;s.length>0;){const i=s.pop(),o=n.get(i);for(const u of o.children)!n.has(u.name)||r.has(u.name)||(r.add(u.name),s.push(u.name))}return t.filter(i=>r.has(i.name))}class nc extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function sK(t,e){const n=new Map(t.map((o,u)=>[o.name,u])),s=new Set(e.map(o=>o.name)),r=o=>s.has(typeof o=="string"?o:o.name),a=new Set(t.map(o=>o.name)),i=o=>a.has(typeof o=="string"?o:o.name);for(const o of t){for(const u of o.children.filter(i)){if(!n.has(u.name))throw new nc(`Child ${u.name} of node ${o.name} is unreachable.`);if(n.get(o.name)>n.get(u.name))throw new nc(`Node ${o.name} is scheduled to run after its child ${u.name}.`)}if(!r(o))for(const u of o.inputs){if(!n.has(u.name))throw new nc(`Input ${u.name} of node ${o.name} is unreachable.`);if(n.get(u.name)>n.get(o.name))throw new nc(`Node ${o.name} is scheduled to run before its input ${u.name}.`)}}}function rK(t){const e=new Map(t.map((o,u)=>[o.name,u])),n=Number.MAX_SAFE_INTEGER,s=t.map((o,u)=>Ma(o)?n:u),r=o=>{const u=s[e.get(o.name)];return u??-1},a=t.map((o,u)=>o.children.map(r).reduce((l,c)=>Math.max(l,c),s[u])),i=new Map;for(let o=0;o<t.length;++o){const u=a[o];if(u===n)continue;const l=t[o],c=t[u];i.has(c.name)||i.set(c.name,[]),i.get(c.name).push(l)}return i}const aK=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),iK=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),oK=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Ma(t){return aK.has(t.op)}function uK(t){return iK.has(t.op)}function lK(t){return oK.has(t.op)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nd{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const n=Object.keys(e).map(s=>e[s].map(r=>r.id));this._weightIds=[].concat(...n),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const n=e.signatureKey||e.name;return e.defaultOutput?`${n}:${e.defaultOutput}`:n})}get functions(){return Object.keys(this._functions).reduce((e,n)=>(e[n]=this._functions[n].signature,e),{})}constructor(e,n){this.graph=e,this.parent=n,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(s=>{this._functionExecutorMap[s]=new nd(e.functions[s],this)})}getCompilationKey(e,n){const s=e.map(a=>a.name).sort(),r=n.map(a=>a.name).sort();return s.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(e,n){const s=J1(e,n,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:a,syncInputs:i}=s;if(a!=null)throw new Error(`This execution contains the node '${a.name}', which has the dynamic op '${a.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(r.length>0){const l=n.map(d=>d.name),c=Object.keys(e);throw new Error(`Cannot compute the outputs [${l}] from the provided inputs [${c}]. Missing the following inputs: [${r}]`)}const o=tK(this.graph,s),u=rK(o);return{orderedNodes:o,nodeLiveUntilMap:u}}cloneAndKeepTensor(e){if(e==null)return null;const n=e.clone();return tn(n),n}cloneTensorList(e){return e?e.map(s=>this.cloneAndKeepTensor(s)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([n,s])=>[n,this.cloneTensorList(s)]))}execute(e,n){this.disposeIntermediateTensors(),e=this.mapInputs(e);const s=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),n=this.mapOutputs(n),this.checkOutputs(n);const r=s.map(h=>this.graph.nodes[Vn(h)[0]]),a=n.map(h=>Vn(h)[0]),i=new Set(a);let o=a.map(h=>this.graph.nodes[h]);o.length===0&&(o=this._outputs);const u=this.getCompilationKey(r,o);let l=this.compiledMap.get(u);l==null&&(l=this.compile(e,o),this.compiledMap.set(u,l));try{this.keepIntermediateTensors=te().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(h){this.keepIntermediateTensors=!1,console.warn(h.message)}const c={},d={};return ee(()=>{const h=new Q1(this.weightMap,c,d,this.functionExecutorMap,this.parseNodeNameCache),p=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(y=>{const[b,$]=Vn(y,h),w=[];w[$]=e[y],p[b]=w,this.keepIntermediateTensors&&(this.clonedTensorsMap[b]=this.cloneTensorList(w))});const f=this.getFrozenTensorIds(p),{orderedNodes:m,nodeLiveUntilMap:g}=l;for(const y of m){if(p[y.name])continue;const b=Z1(y,p,h,this._resourceManager);if(Qa(b))throw new Error(`The execution of the op '${y.op}' returned a promise. Please use model.executeAsync() instead.`);p[y.name]=b,this.keepIntermediateTensors&&(this.clonedTensorsMap[y.name]=this.cloneTensorList(b)),this.checkTensorForDisposalWithNodeLiveUntilInfo(y,p,h,f,i,g.get(y.name))}return this.parent==null&&h.dispose(f),n.map(y=>ln(y,p,h))})}getFrozenTensorIds(e){const n=[].concat.apply([],Object.keys(e).map(s=>e[s]).map(s=>s.map(r=>r.id)));return new Set(n)}checkTensorForDisposal(e,n,s,r,a,i,o){if(!(Ma(n)||i.has(e))){for(const u of s[e])u!=null&&(o[u.id]=(o[u.id]||0)+n.children.length);for(const u of n.inputs){if(Ma(u))continue;const l=q1(u.name,s,r);if(l!=null)for(const c of l){if(!c||c.kept||a.has(c.id))continue;const d=o[c.id];d===1?(c.dispose(),delete o[c.id]):d!=null&&o[c.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,n,s,r,a,i){function o(u){return Ma(u)||a.has(u.name)}if(!(Ma(e)||i==null))for(const u of i){if(o(u))continue;const l=q1(u.name,n,s);for(const c of l)!c||c.kept||r.has(c.id)||c.dispose()}}async executeAsync(e,n){return this._executeAsync(e,n)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const n of e)n&&!n.isDisposed&&n.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,n,s=!1,r={},a={}){this.disposeIntermediateTensors(),s||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),n=this.mapOutputs(n),this.checkOutputs(n));try{this.keepIntermediateTensors=te().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(h){this.keepIntermediateTensors=!1,console.warn(h.message)}const i=new Q1(this.weightMap,r,a,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const o=await this.executeWithControlFlow(e,i,n,s),u=n.map(h=>ln(h,o,i)),l=u.map(h=>h.id),c=Object.keys(e).map(h=>e[h].id),d=new Set([...l,...c,...this.weightIds]);return Object.values(o).forEach(h=>{h.forEach(p=>{p&&!p.isDisposed&&!d.has(p.id)&&p.dispose()})}),this.parent==null&&i.dispose(d),u}async executeFunctionAsync(e,n,s){const r=e.reduce((a,i,o)=>(a[this.inputs[o].name]=i,a),{});return this._executeAsync(r,this.outputNodes,!0,n,s)}async executeWithControlFlow(e,n,s,r){const a=Object.keys(e),i=a.map(w=>this.graph.nodes[Vn(w)[0]]),o=s.map(w=>Vn(w)[0]),u=new Set(o);let l=o.map(w=>this.graph.nodes[w]);l.length===0&&(l=this._outputs);const{usedNodes:c,missingInputs:d,dynamicNode:h,syncInputs:p}=J1(e,l,this.weightMap,this._initNodes),f=[...i,...this.graph.weights,...this._initNodes||[]].map(w=>({node:w,contexts:n.currentContext})),m=Object.assign({},this.weightMap);Object.keys(e).forEach(w=>{const[v,k]=Vn(w),C=[];C[k]=e[w],m[v]=C});const g={},y=this.getFrozenTensorIds(m),b={};for(;f.length>0;){const w=this.processStack(i,f,n,m,b,y,u,g,c);await Promise.all(w)}h==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const $=l.filter(w=>!Ma(w)&&!ln(w.name,m,n)).map(w=>w.name);if($.length>0){let w="";throw h!=null&&(w=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${p}]`),new Error(`Cannot compute the outputs [${$}] from the provided inputs [${a}]. Consider providing the following inputs: [${d}]. ${w}`)}return m}processStack(e,n,s,r,a,i,o,u,l){const c=[];for(;n.length>0;){const d=n.pop();s.currentContext=d.contexts;let h="";if(d.node.op==="Enter"&&_("isConstant",d.node,r,s)&&([h]=Ir(d.node.name,s)),r[d.node.name]==null){const p=Z1(d.node,r,s,this._resourceManager);h||([h]=Ir(d.node.name,s));const f=s.currentContext;Qa(p)?c.push(p.then(m=>(r[h]=m,this.keepIntermediateTensors&&(this.clonedTensorsMap[h]=this.cloneTensorList(m)),s.currentContext=f,this.checkTensorForDisposal(h,d.node,r,s,i,o,u),this.processChildNodes(d.node,n,s,r,a,l),m))):(r[h]=p,this.keepIntermediateTensors&&(this.clonedTensorsMap[h]=this.cloneTensorList(p)),this.checkTensorForDisposal(h,d.node,r,s,i,o,u),this.processChildNodes(d.node,n,s,r,a,l))}else this.processChildNodes(d.node,n,s,r,a,l)}return c}processChildNodes(e,n,s,r,a,i){e.children.forEach(o=>{const[u]=Ir(o.name,s);a[u]||!i.has(o.name)||(o.op==="Merge"?o.inputNames.some(l=>!!ln(l,r,s))&&(a[u]=!0,n.push({contexts:s.currentContext,node:o})):o.inputNames.every(l=>!!ln(l,r,s))&&(a[u]=!0,n.push({contexts:s.currentContext,node:o})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(n=>n.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(n=>{const s=e[n],[r]=Vn(n),a=this.graph.nodes[r];if(a.attrParams.shape&&a.attrParams.shape.value){const i=a.attrParams.shape.value,o=i.length===s.shape.length&&s.shape.every((u,l)=>i[l]===-1||i[l]===u);O(o,()=>`The shape of dict['${a.name}'] provided in model.execute(dict) must be [${i}], but was [${s.shape}]`)}a.attrParams.dtype&&a.attrParams.dtype.value&&O(s.dtype===a.attrParams.dtype.value,()=>`The dtype of dict['${a.name}'] provided in model.execute(dict) must be ${a.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(e){var n,s;const r={};for(const a in e){const i=(s=(n=this._signature)===null||n===void 0?void 0:n.inputs)===null||s===void 0?void 0:s[a];i!=null?r[i.name]=e[a]:r[a]=e[a]}return r}checkInputs(e){const n=Object.keys(e).filter(s=>{const[r]=Vn(s);return this.graph.nodes[r]==null});if(n.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`)}mapOutputs(e){return e.map(n=>{var s,r;const a=(r=(s=this._signature)===null||s===void 0?void 0:s.outputs)===null||r===void 0?void 0:r[n];return a!=null?a.name:n},{})}checkOutputs(e){e.forEach(n=>{const[s]=Vn(n);if(!this.graph.nodes[s])throw new Error(`The output '${n}' is not found in the graph`)})}}class cK{constructor(e={},n={}){this.hashTableNameToHandle=e,this.hashTableMap=n}addHashTable(e,n){this.hashTableNameToHandle[e]=n.handle,this.hashTableMap[n.id]=n}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dK="?tfjs-format=file",hK="model.json";class pK{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,n={},s=bk){this.modelUrl=e,this.loadOptions=n,this.version="n/a",this.io=s,n==null&&(this.loadOptions={}),this.resourceManager=new cK}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const n=this.io.getLoadHandlers(e,this.loadOptions);if(n.length===0)n.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(n.length>1)throw new Error(`Found more than one (${n.length}) load handlers for URL '${[e]}'`);this.handler=n[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return Qa(e)?e.then(n=>n.getWeightStream==null?this.loadSync(n):this.loadStreaming(n)):this.loadSync(e)}loadSync(e){const n=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,n)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const n=await WI(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,n)}loadWithWeightMap(e,n){this.artifacts=e;const s=this.artifacts.modelTopology;let r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const a=this.artifacts.userDefinedMetadata;a.signature!=null&&(r=a.signature),a.structuredOutputKeys!=null&&(this.structuredOutputKeys=a.structuredOutputKeys)}if(this.signature=r,this.version=`${s.versions.producer}.${s.versions.minConsumer}`,this.executor=new nd(j1.Instance.transformGraph(s,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(n),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const a=j1.Instance.transformGraph(e.modelInitializer);this.initializer=new nd(a),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,n){if(typeof e=="string"){const s=this.io.getSaveHandlers(e);if(s.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${e}'`);e=s[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const n=e instanceof _t?[e]:e,s={};return n.forEach((r,a)=>s[this.structuredOutputKeys[a]]=r),s}return e}predict(e,n){const s=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(s)}async predictAsync(e,n){const s=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(s)}normalizeInputs(e){var n;if(!(e instanceof _t)&&!Array.isArray(e)){const a=(n=this.signature)===null||n===void 0?void 0:n.inputs;if(a!=null)for(const i in a){const o=a[i];o.resourceId!=null&&(e[i]=this.resourceIdToCapturedInput[o.resourceId])}return e}e=Array.isArray(e)?e:[e];const s=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+s!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-s} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((a,i)=>{var o,u,l;const c=(l=(u=(o=this.signature)===null||o===void 0?void 0:o.inputs)===null||u===void 0?void 0:u[i])===null||l===void 0?void 0:l.resourceId;return c!=null?a[i]=this.resourceIdToCapturedInput[c]:a[i]=e[r++],a},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const n=this.initializerSignature.outputs,s=Object.keys(n);for(let r=0;r<s.length;r++){const a=s[r],i=n[a];this.resourceIdToCapturedInput[i.resourceId]=e[r]}}}execute(e,n){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),n=this.normalizeOutputs(n);const s=this.executor.execute(e,n);return s.length>1?s:s[0]}async executeAsync(e,n){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),n=this.normalizeOutputs(n);const s=await this.executor.executeAsync(e,n);return s.length>1?s:s[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((n,s)=>(n[s]=[e[s]],n),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Ve(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function fK(t,e={},n=bk){if(t==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof t=="string"&&(t=mK(t));const s=new pK(t,e,n);return await s.load(),s}function mK(t){return t.endsWith("/")||(t=t+"/"),`${t}${hK}${dK}`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var e$;(function(t){t[t.FAIL=0]="FAIL",t[t.SHORTEST=1]="SHORTEST",t[t.LONGEST=2]="LONGEST"})(e$||(e$={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _e(t,e){Array.isArray(t)||(t=[t]),t.forEach(n=>{n!=null&&O(n.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gK=sb;class ip extends gg{nextDataId(){return ip.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new fI(this,ar())}write(e,n,s){this.firstUse&&(this.firstUse=!1,te().get("IS_NODE")&&ts(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:s,refCount:1}),r}makeTensorInfo(e,n,s){let r;if(n==="string"&&s!=null&&s.length>0&&wu(s[0])){const a=s.map(i=>ea(i));r=this.write(a,e,n)}else r=this.write(s,e,n);return{dataId:r,shape:e,dtype:n}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){const n=this.data.get(e);n.refCount++}decRef(e){if(this.data.has(e)){const n=this.data.get(e);n.refCount--}}move(e,n,s,r,a){this.data.set(e,{values:n,dtype:r,refCount:a})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:n,complexTensorInfos:s}=this.data.get(e);if(n==="complex64"){const r=this.readSync(s.real.dataId),a=this.readSync(s.imag.dataId);return Rr(r,a)}return bz(this.data.get(e).values,n)}bufferSync(e){const n=this.readSync(e.dataId);if(e.dtype==="string")try{const s=n.map(r=>sa(r));return qe(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return qe(e.shape,e.dtype,n)}makeOutput(e,n,s){return ar().makeTensorFromTensorInfo(this.makeTensorInfo(n,s,e),this)}disposeData(e,n=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!n&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);s!=null&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const n=Rn();return e(),{kernelMs:Rn()-n}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){_e([e],"where");const n=this.readSync(e.dataId);return gK(e.shape,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}ip.nextDataId=0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xN(t){const e=new Float32Array(t.length);for(let n=0;n<t.length;++n)e[n]=Math.abs(t[n]);return e}const yK=t=>{const{x:e}=t.inputs,n=t.backend;_e(e,"abs");let s=new Float32Array(se(e.shape));const r=n.data.get(e.dataId).values;return s=xN(r),n.makeOutput(s,e.shape,e.dtype)},bK={kernelName:wd,backendName:"cpu",kernelFunc:yK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mt(t){return(e,n,s,r,a)=>{const i=We(e,n),o=i.length,u=Ae(i),l=se(i),c=dn(a,l),d=e.length,h=n.length,p=Ae(e),f=Ae(n),m=Xi(e,i),g=Xi(n,i);if(m.length+g.length===0)for(let y=0;y<c.length;++y)c[y]=t(s[y%s.length],r[y%r.length]);else for(let y=0;y<c.length;++y){const b=uo(y,o,u),$=b.slice(-d);m.forEach(C=>$[C]=0);const w=cr($,d,p),v=b.slice(-h);g.forEach(C=>v[C]=0);const k=cr(v,h,f);c[y]=t(s[w],r[k])}return[c,i]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wn(t){const{inputs:e,backend:n}=t,{real:s,imag:r}=e,a=n.data.get(s.dataId).values,i=n.data.get(r.dataId).values,o=n.makeTensorInfo(s.shape,"complex64"),u=n.data.get(o.dataId);return u.complexTensorInfos={real:n.makeTensorInfo(s.shape,"float32",a),imag:n.makeTensorInfo(r.shape,"float32",i)},o}const xK={kernelName:kg,backendName:"cpu",kernelFunc:Wn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sd(t,e,n="float32"){if(n==="complex64"){const r=sd(t,e,"float32"),a=sd(t,e,"float32");return Wn({inputs:{real:r,imag:a},backend:t})}const s=xn(se(e),n);return t.makeTensorInfo(e,n,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yr(t){const{inputs:e,backend:n}=t,{x:s}=e;return n.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const wK={kernelName:Vu,backendName:"cpu",kernelFunc:yr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function li(t){const{inputs:e,backend:n}=t,{input:s}=e,r=n.data.get(s.dataId).complexTensorInfos.real,a=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,a)}const $K={kernelName:ry,backendName:"cpu",kernelFunc:li};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wN(t,e,n,s){if(s==="int32"){const r=Int32Array.from(t);return[e,"int32",r]}if(s==="bool"){const r=mi([0],n),[a,i]=Mt((o,u)=>o!==u?1:0)(e,[],t,r,"bool");return[i,"bool",a]}throw new Error(`Error in Cast: failed to cast ${n} to ${s}`)}function ha(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{dtype:a}=s;if(a==="complex64"){if(r.dtype==="complex64")return yr({inputs:{x:r},backend:n});const c=sd(n,r.shape,r.dtype),d=ha({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),h=Wn({inputs:{real:d,imag:c},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),h}if(r.dtype==="complex64"){const c=li({inputs:{input:r},backend:n}),d=ha({inputs:{x:c},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(c),d}if(!gI(r.dtype,a)){const c=yr({inputs:{x:r},backend:n});return{dataId:c.dataId,shape:c.shape,dtype:a}}const i=n.data.get(r.dataId).values,[o,u,l]=wN(i,r.shape,r.dtype,a);return n.makeTensorInfo(o,u,l)}const vK={kernelName:Tu,backendName:"cpu",kernelFunc:ha};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zt(t,e,n,s){return n==null?({inputs:r,backend:a})=>{const{a:i,b:o}=r,u=a;_e([i,o],t);const l=u.data.get(i.dataId).values,c=u.data.get(o.dataId).values,d=i.dtype==="string"?Dr(l):l,h=i.dtype==="string"?Dr(c):c,p=s||i.dtype,[f,m]=e(i.shape,o.shape,d,h,p);return u.makeTensorInfo(m,p,f)}:({inputs:r,backend:a})=>{const{a:i,b:o}=r,u=a;if(i.dtype==="complex64"||o.dtype==="complex64"){const l=ha({inputs:{x:i},backend:u,attrs:{dtype:"complex64"}}),c=u.data.get(l.dataId),d=c.complexTensorInfos.real,h=c.complexTensorInfos.imag,p=u.data.get(d.dataId).values,f=u.data.get(h.dataId).values,m=ha({inputs:{x:o},backend:u,attrs:{dtype:"complex64"}}),g=u.data.get(m.dataId),y=g.complexTensorInfos.real,b=g.complexTensorInfos.imag,$=u.data.get(y.dataId).values,w=u.data.get(b.dataId).values,[v,k,C]=n(i.shape,o.shape,p,f,$,w),N=u.makeTensorInfo(C,"float32",v),A=u.makeTensorInfo(C,"float32",k),I=Wn({inputs:{real:N,imag:A},backend:u});return u.disposeIntermediateTensorInfo(l),u.disposeIntermediateTensorInfo(m),u.disposeIntermediateTensorInfo(N),u.disposeIntermediateTensorInfo(A),I}else{const l=u.data.get(i.dataId).values,c=u.data.get(o.dataId).values,d=s||i.dtype,[h,p]=e(i.shape,o.shape,l,c,d);return u.makeTensorInfo(p,d,h)}}}function o0(t){return(e,n,s,r,a,i)=>{const o=We(e,n),u=se(o),l=o.length,c=Ae(o),d=dn("float32",u),h=dn("float32",u),p=Xi(e,o),f=Xi(n,o),m=Rr(s,r),g=Rr(a,i),y=e.length,b=Ae(e),$=n.length,w=Ae(n);if(p.length+f.length===0)for(let v=0;v<d.length;v++){const k=v%m.length,C=v%g.length,N=t(m[k*2],m[k*2+1],g[C*2],g[C*2+1]);d[v]=N.real,h[v]=N.imag}else for(let v=0;v<d.length;v++){const k=uo(v,l,c),C=k.slice(-y);p.forEach(z=>C[z]=0);const N=cr(C,y,b),A=k.slice(-$);f.forEach(z=>A[z]=0);const I=cr(A,$,w),E=t(m[N*2],m[N*2+1],g[I*2],g[I*2+1]);d[v]=E.real,h[v]=E.imag}return[d,h,o]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $N=Mt((t,e)=>t+e),SK=o0((t,e,n,s)=>({real:t+n,imag:e+s})),Ji=Zt(lo,$N,SK),IK={kernelName:lo,backendName:"cpu",kernelFunc:Ji};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u0(t,e,n,s,r){const a=se(s),i=xn(r,n);for(let o=0;o<t.length;o++){const u=t[o];if(u<0)throw new Error("Input x must be non-negative!");u>=r||(a>0?i[u]+=e[o]:i[u]+=1)}return i}function vN(t,e,n,s=!1){const r=t.shape[0],a=t.shape[1],i=qe([r,n],e.dtype);for(let o=0;o<r;o++)for(let u=0;u<a;u++){const l=t.get(o,u);if(l<0)throw new Error("Input x must be non-negative!");l>=n||(s?i.set(1,o,l):e.size>0?i.set(i.get(o,l)+e.get(o,u),o,l):i.set(i.get(o,l)+1,o,l))}return i}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SN=Mt((t,e)=>t&e),_K=Zt(Td,SN),kK={kernelName:Td,backendName:"cpu",kernelFunc:_K};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wr(t){return(e,n,s)=>{const r=zt(n,e.length);for(let a=0;a<e.length;++a)r[a]=t(e[a],s);return r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pt(t,e,n){const s=wr(e);return Ia(t,s,n)}function Ia(t,e,n){return({inputs:s,attrs:r,backend:a})=>{const{x:i}=s;_e(i,t);const o=a,u=o.data.get(i.dataId).values;let l;if(i.dtype==="string"){if(!Array.isArray(u))throw new Error("String tensor's value was not an instance of Array");l=Dr(u)}else l=u;const c=n||i.dtype,d=e(l,c,r);return o.makeTensorInfo(i.shape,c,d)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IN=wr(t=>Math.ceil(t)),CK=Ia(Nu,IN),TK={kernelName:Nu,backendName:"cpu",kernelFunc:CK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _N(t,e,n,s){const r=zt(n,se(e));if(s&&n!=="string"){let a=0;t.forEach(i=>{const o=se(i.shape);r.set(i.vals,a),a+=o})}else{let a=0;t.forEach(i=>{const o=n==="string"?Dr(i.vals):i.vals;let u=0;for(let l=0;l<i.shape[0];++l){const c=l*e[1]+a;for(let d=0;d<i.shape[1];++d)r[c+d]=o[u++]}a+=i.shape[1]})}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kN=Mt((t,e)=>t===e?1:0),CN=Zt(Ld,kN,null,"bool"),NK={kernelName:Ld,backendName:"cpu",kernelFunc:CN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TN=wr(t=>Math.exp(t)),NN=Ia(zu,TN,"float32"),EK={kernelName:zu,backendName:"cpu",kernelFunc:NN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EN=wr(t=>Math.expm1(t)),AK=Ia(Lu,EN),RK={kernelName:Lu,backendName:"cpu",kernelFunc:AK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AN=wr(t=>Math.floor(t)),DK=Ia(Pu,AN),OK={kernelName:Pu,backendName:"cpu",kernelFunc:DK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RN=Mt((t,e)=>Math.floor(t/e)),FK=Zt(Bu,RN,null,"int32"),zK={kernelName:Bu,backendName:"cpu",kernelFunc:FK};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DN(t,e,n,s,r,a,i,o,u){const l=qe([s,a],n);for(let c=0;c<s;c++){const d=[];let h=0;for(let p=0;p<r;p++){const f=t[c*r+p];h+=f*i[p],d.push(f)}if(h<0||h>=u/a)throw new Error(`Invalid indices: ${d} does not index into ${o}`);for(let p=0;p<a;p++)l.values[c*a+p]=e.get(...e.indexToLoc(h*a+p))}return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ON(t,e,n){const s=qe(n,t.dtype);for(let r=0;r<s.size;++r){const i=s.indexToLoc(r).slice(),o=i[0],u=i[2],l=e.locToIndex([o,u]);i[2]=e.values[l];const c=t.locToIndex(i);0<=c&&c<t.values.length&&(s.values[r]=t.values[c])}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FN=Mt((t,e)=>t>e?1:0),LK=Zt(Vd,FN,null,"bool"),PK={kernelName:Vd,backendName:"cpu",kernelFunc:LK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zN=Mt((t,e)=>t>=e?1:0),BK=Zt(Mu,zN,null,"bool"),MK={kernelName:Mu,backendName:"cpu",kernelFunc:BK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LN=Mt((t,e)=>t<e?1:0),VK=Zt(Ud,LN,null,"bool"),WK={kernelName:Ud,backendName:"cpu",kernelFunc:VK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PN=Mt((t,e)=>t<=e?1:0),UK=Zt(Gd,PN,null,"bool"),GK={kernelName:Gd,backendName:"cpu",kernelFunc:UK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BN(t,e,n){const s=(e-t)/(n-1),r=xn(n,"float32");r[0]=t;for(let a=1;a<r.length;a++)r[a]=r[a-1]+s;return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MN=wr(t=>Math.log(t)),HK=Ia(Hu,MN),qK={kernelName:Hu,backendName:"cpu",kernelFunc:HK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VN(t,e,n,s){const r=dn(s,se(n));for(let a=0;a<r.length;++a){const i=a*e;let o=t[i];for(let u=0;u<e;++u){const l=t[i+u];(Number.isNaN(l)||l>o)&&(o=l)}r[a]=o}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WN=Mt((t,e)=>Math.max(t,e)),jK=Zt(ju,WN),KK={kernelName:ju,backendName:"cpu",kernelFunc:jK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UN=Mt((t,e)=>Math.min(t,e)),XK=Zt(Ku,UN),YK={kernelName:Ku,backendName:"cpu",kernelFunc:XK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const l0=Mt((t,e)=>t*e),ZK=o0((t,e,n,s)=>({real:t*n-e*s,imag:t*s+e*n})),op=Zt(Yu,l0,ZK),QK={kernelName:Yu,backendName:"cpu",kernelFunc:op};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GN(t,e,n){const s=ma(-1,n);return l0([],e,s,t,n)}function JK(t){const{inputs:e,backend:n}=t,{x:s}=e;_e(s,"neg");const r=n.data.get(s.dataId).values,[a,i]=GN(r,s.shape,s.dtype);return n.makeTensorInfo(i,s.dtype,a)}const e8={kernelName:th,backendName:"cpu",kernelFunc:JK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HN=Mt((t,e)=>t!==e?1:0),t8=Zt(nh,HN,null,"bool"),n8={kernelName:nh,backendName:"cpu",kernelFunc:t8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c0(t,e,n,s,r){const a=e.length,i=se(e),o=Ae(e),u=Ae(r),l=dn(n,se(r));for(let c=0;c<i;++c){const d=uo(c,a,o),h=new Array(d.length);for(let f=0;f<h.length;f++)h[f]=d[s[f]];const p=cr(h,a,u);l[p]=t[c]}return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zn(t){const{inputs:e,attrs:n,backend:s}=t,{x:r}=e,{perm:a}=n;_e(r,"transpose");const i=r.shape.length,o=new Array(i);for(let d=0;d<o.length;d++)o[d]=r.shape[a[d]];const u=s.data.get(r.dataId).values,l=c0(u,r.shape,r.dtype,a,o);return{dataId:s.write(l,o,r.dtype),shape:o,dtype:r.dtype}}const s8={kernelName:Mi,backendName:"cpu",kernelFunc:zn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qN(t,e,n,s){const[r,a]=an(t,s),i=Hn(e,"int32"),o=xn(se(r),i),u=se(a);for(let l=0;l<o.length;++l){const c=l*u;let d=1;for(let h=0;h<u;++h)d*=n[c+h];o[l]=d}return{outVals:o,outShape:r,outDtype:i}}function r8(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:a,keepDims:i}=s;_e(r,"prod");const o=r.shape.length,u=Ye(a,r.shape),l=At(u,o);let c=u,d=r;const h=[];l!=null&&(d=zn({inputs:{x:r},backend:n,attrs:{perm:l}}),h.push(d),c=Pt(c.length,o));const p=n.data.get(d.dataId).values,{outVals:f,outShape:m,outDtype:g}=qN(d.shape,d.dtype,p,c);let y=m;return i&&(y=Lt(m,u)),h.forEach(b=>n.disposeIntermediateTensorInfo(b)),n.makeTensorInfo(y,g,f)}const a8={kernelName:uh,backendName:"cpu",kernelFunc:r8};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i8(t,e,n){t.forEach((s,r)=>{if(s<0||s>=n){const a=uo(r,e.length,Ae(e)).join(",");throw new Error(`indices[${a}] = ${s} is not in [0, ${n})`)}})}function o8(t,e){for(let n=0;n<t.length;++n){const s=t[n],r=n===t.length-1?e:t[n+1].length;if(s.length===0)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>r)throw new Error("Ragged splits must not point past values");for(let a=1;a<s.length;++a)if(s[a-1]>s[a])throw new Error("Ragged splits must be sorted in ascending order")}}function u8(t,e,n,s){const r=[];let a=0;const i=e.length-1+n.length,o=new Array(i).fill(null).map(()=>[0]);o8(n,s);let u=1;for(let l=0;l<e.length-1;++l){u*=e[l];const c=e[l+1];for(let d=1;d<u+1;++d)o[l].push(d*c)}for(let l=0;l<t.length;++l){let c=t[l],d=t[l]+1;for(let h=0;h<n.length;++h){const p=n[h],f=h+e.length-1;if(f>=0){const m=o[f],g=m[m.length-1]-p[c];for(let y=c;y<d;++y)o[f].push(p[y+1]+g)}c=p[c],d=p[d]}d!==c&&(r.push([c,d]),a+=d-c)}return{outSplits:o,valueSlices:r,numValues:a}}function l8(t){const e=[];for(let n=0;n<t.length;++n){const s=t[n].length,r=zt("int32",s);e.push(r),t[n].forEach((a,i)=>r[i]=a)}return e}function t$(t,e){const n=t.slice(0,e);for(;n.length<e;)n.push(1);for(let s=e;s<t.length;s++)n[e-1]*=t[s];return n}function c8(t,e,n,s,r,a){const i=t$(e,2)[1],o=t$(a,2)[1];let u=0;for(const l of n)for(let c=l[0];c<l[1];++c){for(let d=0;d<s;++d)r[u*o+d]=t[c*i+d];++u}}function d8(t,e,n,s,r){const a=e.slice();a[0]=r;const i=zt(n,se(a)),o=t.length,u=o===0?0:o/e[0];return c8(t,e,s,u,i,a),[i,a]}function jN(t,e,n,s,r,a,i,o){if(t.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const u=e[0][0]-1;if(i8(a,i,u),s.length===0)throw new Error("params.rank must be nonzero");const l=s[0],{outSplits:c,valueSlices:d,numValues:h}=u8(a,i,t,l),p=l8(c),f=d8(n,s,r,d,h);return[p,f[0],f[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n$=2147483647;function KN(t,e,n,s,r,a,i){if(e.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const o=e.length===0,u=r.length===0,l=i.length===0,c=[];o||c.push(e[0]),u||c.push(r[0]),l||c.push(i[0]);for(let g=1;g<c.length;++g)if(c[g]!==c[g-1])throw new Error("starts, limits, and deltas must have the same shape");const d=c.length===0?1:c[0],h=zt("int32",d+1);h[0]=0;for(let g=0;g<d;++g){const y=o?t[0]:t[g],b=u?s[0]:s[g],$=l?a[0]:a[g];if($===0)throw new Error("Requires delta != 0");let w;if($>0&&b<y||$<0&&b>y)w=0;else if(w=Math.ceil(Math.abs((b-y)/$)),w>n$)throw new Error(`Requires ((limit - start) / delta) <= ${n$}`);h[g+1]=h[g]+w}const p=h[d],f=zt(n,p);let m=0;for(let g=0;g<d;++g){const y=h[g+1]-h[g];let b=o?t[0]:t[g];const $=l?a[0]:a[g];for(let w=0;w<y;++w)f[m++]=b,b+=$}return[h,f]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var hs=Ws;class rd{constructor(e,n,s,r,a,i,o,u,l,c){this.shape=e,this.shapeShape=n,this.values=s,this.valuesShape=r,this.valuesDType=a,this.defaultValue=i,this.defaultValueShape=o,this.rowPartitionValues=u,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=Ek(c),this.raggedRank=Ak(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===hs.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===hs.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const n=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case hs.VALUE_ROWIDS:return rd.getMaxWidthValueRowID(n);case hs.ROW_SPLITS:return rd.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${hs[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const n=e.length;if(n===0||n===1)return 0;let s=0;for(let r=0;r<n-1;++r){const a=e[r+1]-e[r];a>s&&(s=a)}return s}static getMaxWidthValueRowID(e){const n=e.length;if(n===0)return 0;let s=0,r=e[0],a=0;for(let i=1;i<n;++i){const o=e[i];o!==r&&(r=o,a=Math.max(i-s,a),s=i)}return Math.max(n-s,a)}tensorShapeFromTensor(e,n,s=!0){if(n.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return r$(e,s)}calculateOutputSize(e){const n=this.valuesShape,s=this.defaultValueShape;Rk(s,n);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=Nk(this.raggedRank,r,n);i[0]<0&&(i[0]=e);for(let o=1;o<=this.raggedRank;++o)i[o]<0&&(i[o]=this.getMaxWidth(o));return i}calculateFirstParentOutputIndex(e,n,s){const r=Math.min(e,s),a=[];let i=0;for(let o=0;o<r;++o,i+=n)a.push(i);for(let o=r;o<e;++o)a.push(-1);return O(a.length===e,()=>"Final length of result must be equal to firstDimension."),a}calculateOutputIndexRowSplit(e,n,s,r){const a=e.length,i=[];for(let o=0;o<a-1;++o){const u=e[o+1]-e[o];let l=Math.min(r,u),c=n[o];c===-1&&(l=0);for(let d=0;d<l;++d)i.push(c),c+=s;for(let d=0;d<u-l;++d)i.push(-1)}if(a>0&&i.length!==e[a-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(e,n,s,r){const a=e.length,i=[];if(a===0)return[];let o=0,u=e[0];if(u>=n.length)throw new Error(`Got currentValueRowId=${u}, which is not less than ${n.length}`);let l=n[u];i.push(l);for(let c=1;c<a;++c){const d=e[c];if(d===u)l>=0&&(++o,o<r?l+=s:l=-1);else{if(o=0,u=d,d>=n.length)throw new Error(`Got nextValueRowId=${d} which is not less than ${n.length}`);l=n[d]}i.push(l)}if(i.length!==e.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(e,n,s,r){const a=this.getRowPartitionTensor(e),i=this.getRowPartitionTypeByDimension(e);switch(i){case hs.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,n,s,r);case hs.ROW_SPLITS:if(a.length-1>n.length)throw new Error(`Row partition size is greater than output size: ${a.length-1} > ${n.length}`);return this.calculateOutputIndexRowSplit(a,n,s,r);default:throw new Error(`Unsupported partition type: ${hs[i]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const n=this.rowPartitionTypes[0];switch(n){case hs.FIRST_DIM_SIZE:return e[0];case hs.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case hs.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${hs[n]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const n=this.getFirstDimensionSize(),s=this.calculateOutputSize(n),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let u=r.length-2;u>=0;--u)r[u]=r[u+1]*s[u+1];const a=r$(s,!1),i=zt(this.valuesDType,se(a));if(r[0]*s[0]>0){let u=this.calculateFirstParentOutputIndex(n,r[0],s[0]);for(let l=1;l<=this.raggedRank;++l)u=this.calculateOutputIndex(l-1,u,r[l],s[l]);this.setOutput(this.raggedRank,u,i,a)}return[a,i]}setOutput(e,n,s,r){if(s.length===0)return;const a=this.values,i=s;let o=r.slice();o=o.slice(e+1);const u=se(o),l=n.length;let c=this.defaultValue;if(c.length!==u&&c.length!==1){const f=this.defaultValueShape;ee(()=>{const m=K(c,f);c=Ui(m,o).dataSync()})}let d=0,h=0,p=0;for(let f=0;f<=l;++f){let m=f<l?n[f]:-1;if(m===p){++p;continue}if(h<p){const g=a.subarray(d*u),y=i.subarray(h*u),b=(p-h)*u;s$(y,g,b)}if(f>=l){const g=s.length;m=Math.floor(g/u)}if(m>p)if(this.defaultValue.length===1)i.subarray(p*u,m*u).fill(this.defaultValue[0]),p=m;else for(;m>p;){const g=i.slice(p*u);s$(g,c,u),++p}m<0?(d=f+1,h=p):(d=f,h=p,p=h+1)}}}function s$(t,e,n){for(let s=0;s<n;s++)t[s]=e[s]}function r$(t,e){const n=[];for(let s of t){if(s<0){if(!e)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}n.push(s)}return n}function XN(t,e,n,s,r,a,i,o,u,l){return new rd(t,e,n,s,r,a,i,o,u,l).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YN(t,e,n,s){const r=t===e,a=t<e&&n<0,i=e<t&&n>1;if(r||a||i)return xn(0,s);const o=Math.abs(Math.ceil((e-t)/n)),u=xn(o,s);e<t&&n===1&&(n=-1),u[0]=t;for(let l=1;l<u.length;l++)u[l]=u[l-1]+n;return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZN=wr(t=>1/Math.sqrt(t)),h8=Ia(nl,ZN),p8={kernelName:nl,backendName:"cpu",kernelFunc:h8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qa(t,e,n,s,r,a,i,o,u,l){const c=[s/r,r],d=t.values,h=e.values;if(s===0)return qe(n,e.dtype);const p=u instanceof jt?u:qe(c,e.dtype);typeof u=="string"||typeof u=="number"?p.values.fill(u):typeof u=="boolean"&&p.values.fill(+u);for(let f=0;f<a;f++){const m=[];let g=0;for(let y=0;y<i;y++){const b=d[f*i+y];m.push(b),g+=b*o[y]}if(g<0||g>=s/r)throw new Error(`Invalid indices: ${m} does not index into ${n}`);for(let y=0;y<r;y++)l?p.values[g*r+y]+=h[f*r+y]:p.values[g*r+y]=e.rank===0?h[0]:h[f*r+y]}return p}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f8=wr(t=>1/(1+Math.exp(-t))),QN=pt(ol,t=>1/(1+Math.exp(-t))),m8={kernelName:ol,backendName:"cpu",kernelFunc:QN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JN(t,e,n,s,r){const a=gb(s,e,n),i=se(n),o=Ae(s);if(a){const d=yb(e,o);return r==="string"?t.slice(d,d+i):t.subarray(d,d+i)}const u=r==="string"?Dr(t):t,l=qe(s,r,u),c=qe(n,r);for(let d=0;d<c.size;++d){const h=c.indexToLoc(d),p=h.map((f,m)=>f+e[m]);c.set(l.get(...p),...h)}return r==="string"?Qk(c.values):c.values}function ci(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{begin:a,size:i}=s;_e(r,"slice");const[o,u]=qh(r,a,i);fb(r,o,u);const l=n.data.get(r.dataId).values,c=JN(l,o,u,r.shape,r.dtype);return n.makeTensorInfo(u,r.dtype,c)}const g8={kernelName:fh,backendName:"cpu",kernelFunc:ci};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eE(t,e,n,s,r,a,i){const o=e[0],u=a[0],l=new Array(u),c=new Array(o),d=e[1];if(u===0){if(o!==0)throw new Error(Bk(o));const g=zt(n,0),y=zt(r,0);return[g,[0,d],y,l,c]}let h=!0,p=0;const f=new Array(u).fill(0);for(let g=0;g<o;++g){const y=t[g*d];if(y<0)throw new Error(Mk(g,y));if(y>=u)throw new Error(Vk(g,y,u));++f[y],h=h&&y>=p,p=y}let m=!0;for(let g=0;g<u;++g){const y=f[g]===0;l[g]=y,m=m&&!y,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&h){const g=t,y=s;for(let b=0;b<o;++b)c[b]=b;return[g,[o,d],y,l,c]}else{const g=f[u-1],y=zt(n,g*d),b=zt(r,g),$=new Array(u).fill(0);for(let w=0;w<o;++w){const v=t[w*d],k=$[v],C=(v===0?0:f[v-1])+k;$[v]++;for(let N=0;N<d;++N)y[C*d+N]=t[w*d+N];b[C]=s[w],c[w]=C}for(let w=0;w<u;++w)if($[w]===0){const k=w===0?0:f[w-1];y[k*d+0]=w;for(let C=1;C<d;++C)y[k*d+C]=0;b[k]=i}return[y,[g,d],b,l,c]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tE(t,e,n,s,r){const a=se(s),i=e[0],o=r.length,u=[];let l=1,c=-1;for(let g=0;g<o;++g){const y=r[g];if(y===-1){if(c!==-1)throw new Error(Wk(c,g));c=g,u.push(1)}else{if(y<0)throw new Error(Uk(g,y));l*=y,u.push(y)}}if(c!==-1){if(l<=0)throw new Error(Gk());const g=Math.trunc(a/l);if(l*g!==a)throw new Error(Hk(s,u));u[c]=g}if(se(u)!==a)throw new Error(qk(s,u));const h=s.length,p=[];if(h>0){p[h-1]=1;for(let g=h-2;g>=0;--g)p[g]=p[g+1]*s[g+1]}const f=[];if(o>0){f[o-1]=1;for(let g=o-2;g>=0;--g)f[g]=f[g+1]*u[g+1]}const m=zt(n,i*o);for(let g=0;g<i;++g){let y=0;for(let b=0;b<h;++b)y+=t[g*h+b]*p[b];for(let b=0;b<o;++b)m[g*o+b]=Math.trunc(y/f[b]),y%=f[b]}return[m,[i,o],u]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d0(t,e,n,s,r,a=!1,i=0){const o=s.length,u=[e[0],t.length/e[0]],l=u[1],d=o>0?r[o-1]+1:0;if(d<0)throw new Error(km());const h=e.slice();h[0]=d;const p=h.reduce(($,w)=>$*w,1),f=zt(n,p);if(o===0)return d>0&&f.fill(i),[f,h];if(d<=0)throw new Error(km());let m=0,g=1,y=0,b=r[m];for(;;){let $=0;if(g<o){if($=r[g],b===$){++g;continue}if(b>=$)throw new Error(jk())}if(b<0||b>=d)throw new Error(Kk(b,d));b>y&&f.fill(i,y*l,b*l);for(let w=m;w<g;++w){const v=s[w];if(v<0||v>=u[0])throw new Error(Xk(w,s[w],u[0]));for(let k=0;k<l;k++)f[b*l+k]+=t[v*l+k]}if(a)for(let w=0;w<l;w++)f[b*l+w]/=g-m;if(m=g,++g,y=b+1,b=$,g>o)break}return y<d&&f.fill(i,y*l,d*l),[f,h]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y8=wr(t=>Math.sqrt(t)),b8=pt(ll,t=>Math.sqrt(t)),x8={kernelName:ll,backendName:"cpu",kernelFunc:b8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nE=Mt((t,e)=>{const n=t-e;return n*n}),w8=Zt(cl,nE),$8={kernelName:cl,backendName:"cpu",kernelFunc:w8};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sE=wr((t,e)=>{const{pattern:n,replaceGlobal:s,rewrite:r}=e;return t.replace(new RegExp(n,s?"g":""),r)}),v8=Ia(xh,sE),S8={kernelName:xh,backendName:"cpu",kernelFunc:v8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rE(t,e,n,s){const r=qe(t,e.dtype);for(let a=0;a<r.size;a++){const i=r.indexToLoc(a),o=new Array(i.length);for(let u=0;u<o.length;u++)o[u]=i[u]*n[u]+s[u];r.set(e.get(...o),...i)}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class I8{constructor(e,n,s,r,a,i){this.separator=ea(e),this.nGramWidths=n,this.leftPad=ea(s),this.rightPad=ea(r),this.padWidth=a,this.preserveShort=i}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,n){const s=this.getPadWidth(n);return Math.max(0,e+2*s-n+1)}createNGrams(e,n,s,r,a,i){for(let o=0;o<a;++o){const u=this.getPadWidth(i),l=Math.max(0,u-o),c=Math.max(0,u-(a-(o+1))),d=i-(l+c),h=n+(l>0?0:o-u);let p=0;p+=l*this.leftPad.length;for(let b=0;b<d;++b)p+=e[h+b].length;p+=c*this.rightPad.length;const f=l+c+d-1;p+=f*this.separator.length,s[r+o]=new Uint8Array(p);const m=s[r+o];let g=0;const y=b=>b.forEach($=>m[g++]=$);for(let b=0;b<l;++b)y(this.leftPad),y(this.separator);for(let b=0;b<d-1;++b)y(e[h+b]),y(this.separator);if(d>0){y(e[h+d-1]);for(let b=0;b<c;++b)y(this.separator),y(this.rightPad)}else{for(let b=0;b<c-1;++b)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(e,n){const s=e.length,r=n.length;if(r>0){let u=n[0];if(u!==0)throw new Error(`First split value must be 0, got ${u}`);for(let l=1;l<r;++l){let c=n[l]>=u;if(c=c&&n[l]<=s,!c)throw new Error(`Invalid split value ${n[l]}, must be in [${u}, ${s}]`);u=n[l]}if(u!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${u}`)}const a=r-1,i=zt("int32",r);if(s===0||r===0){const u=new Array(s);for(let l=0;l<=a;++l)i[l]=0;return[u,i]}i[0]=0;for(let u=1;u<=a;++u){const l=n[u]-n[u-1];let c=0;this.nGramWidths.forEach(d=>{c+=this.getNumNGrams(l,d)}),this.preserveShort&&l>0&&c===0&&(c=1),i[u]=i[u-1]+c}const o=new Array(i[a]);for(let u=0;u<a;++u){const l=n[u];let c=i[u];if(this.nGramWidths.forEach(d=>{const h=n[u+1]-n[u],p=this.getNumNGrams(h,d);this.createNGrams(e,l,o,c,p,d),c+=p}),this.preserveShort&&c===i[u]){const d=n[u+1]-n[u];if(d===0)continue;const h=d+2*this.padWidth;this.createNGrams(e,l,o,c,1,h)}}return[o,i]}}function aE(t,e,n,s,r,a,i,o){return new I8(n,s,r,a,i,o).compute(t,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _8(t,e,n,s){if(!t.length)return;if(e.length===0){for(let a=0;a<t.length;++a)s.push(t.subarray(a,a+1));return}if(e.length===1){const a=e[0];let i=t.indexOf(a);for(;i!==-1;){const o=t.subarray(0,i);(!n||o.length!==0)&&s.push(o),t=t.subarray(i+1),i=t.indexOf(a)}(!n||t.length!==0)&&s.push(t);return}let r=0;for(let a=0;a<t.length+1;a++)if(a===t.length||e.indexOf(t[a])!==-1){const i=t.subarray(r,a);(!n||i.length!==0)&&s.push(i),r=a+1}}function iE(t,e,n){const s=t.length,r=[];let a=0,i=0;const o=new Array(s);for(let h=0;h<s;++h){const p=r.length;_8(t[h],e,n,r);const f=r.length-p;o[h]=f,a+=f,i=Math.max(i,f)}const u=zt("int32",a*2),l=new Array(a),c=[s,i];let d=0;for(let h=0;h<s;++h)for(let p=0;p<o[h];++p)u[d*2]=h,u[d*2+1]=p,l[d]=r[d],++d;return[u,l,c]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oE(t,e){const n=zt("int32",t.length);for(let s=0;s<t.length;++s)n[s]=Pz(t[s]).modulo(e).getLowBitsUnsigned();return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uE=Mt((t,e)=>t-e),k8=o0((t,e,n,s)=>({real:t-n,imag:e-s})),h0=Zt(dl,uE,k8),C8={kernelName:dl,backendName:"cpu",kernelFunc:h0};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lE(t,e){const n=new Array(t.rank);for(let r=0;r<n.length;r++)n[r]=t.shape[r]*e[r];const s=qe(n,t.dtype);for(let r=0;r<s.values.length;++r){const a=s.indexToLoc(r),i=new Array(t.rank);for(let u=0;u<i.length;u++)i[u]=a[u]%t.shape[u];const o=t.locToIndex(i);s.values[r]=t.values[o]}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jo=(t,e)=>{const n=e.value-t.value;return n===0?t.index-e.index:n};function cE(t,e,n=0,s=t.length-1){for(;s>n;){if(s-n>600){const o=s-n+1,u=e-n+1,l=Math.log(o),c=.5*Math.exp(2*l/3),d=.5*Math.sqrt(l*c*(o-c)/o)*Math.sign(u-o/2),h=Math.max(n,Math.floor(e-u*c/o+d)),p=Math.min(s,Math.floor(e+(o-u)*c/o+d));cE(t,e,h,p)}const r=t[e];let a=n,i=s;for(Di(t,n,e),jo(t[s],r)>0&&Di(t,n,s);a<i;){for(Di(t,a,i),a++,i--;jo(t[a],r)<0;)a=a+1;for(;jo(t[i],r)>0;)i=i-1}jo(t[n],r)===0?Di(t,n,i):(i=i+1,Di(t,i,s)),i<=e&&(n=i+1),e<=i&&(s=i-1)}}function dE(t,e,n,s,r){const a=e[e.length-1],[i,o]=[t.length/a,a],u=dn(n,i*s),l=dn("int32",i*s);for(let d=0;d<i;d++){const h=d*o,p=t.subarray(h,h+o);let f=new Array(p.length);p.forEach((b,$)=>f[$]={value:b,index:$}),s<f.length&&(cE(f,s),f=f.slice(0,s)),r&&f.sort(jo);const m=d*s,g=u.subarray(m,m+s),y=l.subarray(m,m+s);for(let b=0;b<s;b++)g[b]=f[b].value,y[b]=f[b].index}const c=e.slice();return c[c.length-1]=s,[qe(c,n,u),qe(c,"int32",l)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hE(t,e,n,s){const r=Ye(e,n)[0],a=[1,n[0],1];for(let f=0;f<r;f++)a[0]*=n[f];a[1]=n[r];for(let f=r+1;f<n.length;f++)a[2]*=n[f];const i=new Map,o=new Int32Array(n[r]),u=new jt(a,s,t),l=[],c=a[0]===1&&a[2]===1;for(let f=0;f<n[r];f++){let m;if(c)m=t[f].toString();else{const y=[];for(let b=0;b<a[0];b++)for(let $=0;$<a[2];$++)y.push(u.get(b,f,$));m=y.join(",")}const g=i.get(m);if(g!=null)o[f]=g;else{const y=i.size;i.set(m,y),o[f]=y,l.push(f)}}const d=a.slice();d[1]=i.size;const h=new jt(d,s);l.forEach((f,m)=>{for(let g=0;g<a[0];g++)for(let y=0;y<a[2];y++)h.set(u.get(g,f,y),g,m,y)});const p=n.slice();return p[r]=d[1],{outputValues:h.values,outputShape:p,indices:o}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T8=Object.freeze(Object.defineProperty({__proto__:null,addImpl:$N,bincountImpl:u0,bincountReduceImpl:vN,bitwiseAndImpl:SN,castImpl:wN,ceilImpl:IN,concatImpl:_N,equalImpl:kN,expImpl:TN,expm1Impl:EN,floorDivImpl:RN,floorImpl:AN,gatherNdImpl:DN,gatherV2Impl:ON,greaterEqualImpl:zN,greaterImpl:FN,lessEqualImpl:PN,lessImpl:LN,linSpaceImpl:BN,logImpl:MN,maxImpl:VN,maximumImpl:WN,minimumImpl:UN,multiplyImpl:l0,negImpl:GN,notEqualImpl:HN,prodImpl:qN,raggedGatherImpl:jN,raggedRangeImpl:KN,raggedTensorToTensorImpl:XN,rangeImpl:YN,rsqrtImpl:ZN,scatterImpl:qa,sigmoidImpl:f8,simpleAbsImpl:xN,sliceImpl:JN,sparseFillEmptyRowsImpl:eE,sparseReshapeImpl:tE,sparseSegmentReductionImpl:d0,sqrtImpl:y8,squaredDifferenceImpl:nE,staticRegexReplaceImpl:sE,stridedSliceImpl:rE,stringNGramsImpl:aE,stringSplitImpl:iE,stringToHashBucketFastImpl:oE,subImpl:uE,tileImpl:lE,topKImpl:dE,transposeImpl:c0,uniqueImpl:hE},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */PI("cpu",()=>new ip,1);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pE=pt(Ou,t=>t>=0?t:Math.exp(t)-1),N8={kernelName:Ou,backendName:"cpu",kernelFunc:pE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fE(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{alpha:a}=s;_e([r],"leakyRelu");const i=se(r.shape),o=n.data.get(r.dataId).values,u=dn("float32",i);for(let l=0;l<o.length;l++)u[l]=o[l]<0?a*o[l]:o[l];return n.makeTensorInfo(r.shape,"float32",u)}const E8={kernelName:Wd,backendName:"cpu",kernelFunc:fE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A8=Mt((t,e)=>t<0?e*t:t);function mE(t){const{inputs:e,backend:n}=t,{x:s,alpha:r}=e;_e([s,r],"prelu");const a=n.data.get(s.dataId).values,i=n.data.get(r.dataId).values,[o,u]=A8(s.shape,r.shape,a,i,"float32");return n.makeTensorInfo(u,"float32",o)}const R8={kernelName:oh,backendName:"cpu",kernelFunc:mE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gE=pt(Ju,t=>Math.max(0,t)),D8={kernelName:Ju,backendName:"cpu",kernelFunc:gE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yE=pt(el,t=>Math.min(Math.max(0,t),6)),O8={kernelName:el,backendName:"cpu",kernelFunc:yE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ad(t,e,n,s,r){if(n==="linear")return yr({inputs:{x:e},backend:t});if(n==="relu")return gE({inputs:{x:e},backend:t});if(n==="elu")return pE({inputs:{x:e},backend:t});if(n==="relu6")return yE({inputs:{x:e},backend:t});if(n==="prelu")return mE({inputs:{x:e,alpha:s},backend:t});if(n==="leakyrelu")return fE({inputs:{x:e},backend:t,attrs:{alpha:r}});if(n==="sigmoid")return QN({inputs:{x:e},backend:t});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function St(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{shape:a}=s,i=se(r.shape),o=mI(a,i),u=se(o);O(i===u,()=>`The new shape (${o}) has ${u} elements and the old shape (${r.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),n.incRef(r.dataId);const l=n.data.get(r.dataId);if(l.complexTensorInfos!=null){const c=l.complexTensorInfos.real,d=l.complexTensorInfos.imag;c.shape=o,d.shape=o}return{dataId:r.dataId,shape:o,dtype:r.dtype}}const F8={kernelName:lh,backendName:"cpu",kernelFunc:St};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bE(t){const{inputs:e,backend:n,attrs:s}=t,{a:r,b:a}=e,{transposeA:i,transposeB:o}=s;_e([r,a],"matMul");const u=r.shape.length,l=a.shape.length,c=i?r.shape[u-2]:r.shape[u-1],d=o?a.shape[l-1]:a.shape[l-2],h=i?r.shape[u-1]:r.shape[u-2],p=o?a.shape[l-2]:a.shape[l-1],f=r.shape.slice(0,-2),m=a.shape.slice(0,-2),g=se(f),y=se(m),$=We(r.shape.slice(0,-2),a.shape.slice(0,-2)).concat([h,p]);O(c===d,()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${r.shape} and ${a.shape} and transposeA=${i} and transposeB=${o} must match.`);const w=i?[g,c,h]:[g,h,c],v=o?[y,p,d]:[y,d,p],k=St({inputs:{x:r},backend:n,attrs:{shape:w}}),C=St({inputs:{x:a},backend:n,attrs:{shape:v}}),N=i?k.shape[1]:k.shape[2],A=i?k.shape[2]:k.shape[1],I=o?C.shape[1]:C.shape[2],E=Math.max(g,y),z=n.data.get(k.dataId).values,P=n.data.get(C.dataId).values,H=Ae(k.shape),G=Ae(C.shape),[W,L,B]=i?[H[0],1,H[1]]:[H[0],H[1],1],[Y,ne,M]=o?[1,G[1],G[0]]:[G[1],1,G[0]],Z=A*I,J=qe([E,A,I],k.dtype),oe=J.values,de=n.blockSize;for(let fe=0;fe<E;fe++){const xe=fe%g,Ne=fe%y;for(let $e=0;$e<A;$e+=de){const Ee=Math.min($e+de,A);for(let ze=0;ze<I;ze+=de){const Oe=Math.min(ze+de,I);for(let Fe=0;Fe<N;Fe+=de){const Je=Math.min(Fe+de,N);for(let ct=$e;ct<Ee;ct++)for(let Ke=ze;Ke<Oe;Ke++){let Le=0;for(let ft=Fe;ft<Je;ft++){const us=z[xe*W+ct*L+ft*B],Ft=P[ft*Y+Ke*ne+Ne*M];Le+=us*Ft}oe[fe*Z+(ct*I+Ke)]+=Le}}}}}return n.disposeIntermediateTensorInfo(k),n.disposeIntermediateTensorInfo(C),n.makeTensorInfo($,J.dtype,J.values)}const z8={kernelName:kd,backendName:"cpu",kernelFunc:bE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L8(t){const{inputs:e,backend:n,attrs:s}=t,{a:r,b:a,bias:i,preluActivationWeights:o}=e,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:d}=s;let h,p,f;const m=[];h=bE({inputs:{a:r,b:a},attrs:{transposeA:u,transposeB:l},backend:n}),i&&(p=Ji({inputs:{a:h,b:i},backend:n}),m.push(h),h=p),c&&(f=ad(n,h,c,o,d),m.push(h),h=f);for(const y of m)n.disposeIntermediateTensorInfo(y);return h}const P8={kernelName:Pc,backendName:"cpu",kernelFunc:L8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B8=pt($u,t=>Math.acos(t)),M8={kernelName:$u,backendName:"cpu",kernelFunc:B8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V8=pt(vu,t=>Math.acosh(t)),W8={kernelName:vu,backendName:"cpu",kernelFunc:V8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U8(t){const{inputs:e,backend:n}=t,s=e;_e(e,"addN");const r=s.map(o=>n.data.get(o.dataId).values),a=qe(s[0].shape,s[0].dtype),i=a.values;for(let o=0;o<s.length;o++){const u=r[o];for(let l=0;l<i.length;l++)i[l]+=u[l]}return n.makeTensorInfo(a.shape,a.dtype,a.values)}const G8={kernelName:$d,backendName:"cpu",kernelFunc:U8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H8(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:a,keepDims:i}=s;_e(r,"all");const o=Ye(a,r.shape);let u=o;const l=At(u,r.shape.length);let c=r;l!=null&&(c=zn({inputs:{x:r},backend:n,attrs:{perm:l}}),u=Pt(u.length,r.shape.length)),fn("all",u,c.shape.length);const[d,h]=an(c.shape,u),p=se(h),f=xn(se(d),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const b=y*p;let $=m[b];for(let w=0;w<p;++w){const v=m[b+w];$=$&&v}f[y]=$}l!=null&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,f);if(i){const y=Lt(d,o),b=St({inputs:{x:g},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(g),b}return g}const q8={kernelName:wg,backendName:"cpu",kernelFunc:H8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j8(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:a,keepDims:i}=s;_e(r,"any");const o=Ye(a,r.shape);let u=o;const l=At(u,r.shape.length);let c=r;l!=null&&(c=zn({inputs:{x:r},backend:n,attrs:{perm:l}}),u=Pt(u.length,r.shape.length)),fn("any",u,c.shape.length);const[d,h]=an(c.shape,u),p=se(h),f=xn(se(d),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const b=y*p;let $=m[b];for(let w=0;w<p;++w){const v=m[b+w];$=$||v}f[y]=$}l!=null&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,f);if(i){const y=Lt(d,o),b=St({inputs:{x:g},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(g),b}return g}const K8={kernelName:$g,backendName:"cpu",kernelFunc:j8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X8(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:a}=s;_e(r,"argMax");let i=Ye(a,r.shape);const o=At(i,r.shape.length);let u=r;const l=[];o!=null&&(u=zn({inputs:{x:r},backend:n,attrs:{perm:o}}),l.push(u),i=Pt(i.length,u.shape.length)),i=[i[0]],fn("argMax",i,u.shape.length);const[c,d]=an(u.shape,i),h=se(c),p=xn(h,"int32"),f=se(d),m=n.data.get(u.dataId).values;for(let g=0;g<p.length;++g){const y=g*f;let b=m[y],$=0;for(let w=0;w<f;++w){const v=m[y+w];v>b&&(b=v,$=w)}p[g]=$}return l.forEach(g=>n.disposeIntermediateTensorInfo(g)),n.makeTensorInfo(c,"int32",p)}const Y8={kernelName:vd,backendName:"cpu",kernelFunc:X8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z8(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:a}=s;_e(r,"argMin");let i=Ye(a,r.shape);const o=At(i,r.shape.length);let u=r;const l=[];o!=null&&(u=zn({inputs:{x:r},backend:n,attrs:{perm:o}}),l.push(u),i=Pt(i.length,u.shape.length)),i=[i[0]],fn("argMin",i,u.shape.length);const[c,d]=an(u.shape,i),h=se(c),p=xn(h,"int32"),f=se(d),m=n.data.get(u.dataId).values;for(let g=0;g<p.length;++g){const y=g*f;let b=m[y],$=0;for(let w=0;w<f;++w){const v=m[y+w];v<b&&(b=v,$=w)}p[g]=$}return l.forEach(g=>n.disposeIntermediateTensorInfo(g)),n.makeTensorInfo(c,"int32",p)}const Q8={kernelName:Sd,backendName:"cpu",kernelFunc:Z8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J8=pt(Su,t=>Math.asin(t)),e5={kernelName:Su,backendName:"cpu",kernelFunc:J8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t5=pt(Iu,t=>Math.asinh(t)),n5={kernelName:Iu,backendName:"cpu",kernelFunc:t5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s5=pt(_u,t=>Math.atan(t)),r5={kernelName:_u,backendName:"cpu",kernelFunc:s5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a5=Mt((t,e)=>Math.atan2(t,e)),i5=Zt(Cu,a5),o5={kernelName:Cu,backendName:"cpu",kernelFunc:i5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u5=pt(ku,t=>Math.atanh(t)),l5={kernelName:ku,backendName:"cpu",kernelFunc:u5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p0(t,e,n,s,r,a){const i=r.strideHeight,o=r.strideWidth,u=r.dilationHeight,l=r.dilationWidth,c=r.effectiveFilterHeight,d=r.effectiveFilterWidth,h=r.padInfo.top,p=r.padInfo.left,f=a==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=qe(r.outShape,n),g=m.values,y=r.outShape[1]*r.outShape[2]*r.outShape[3],b=r.outShape[2]*r.outShape[3],$=r.outShape[3];for(let w=0;w<r.batchSize;++w){const v=w*y,k=w*s[0];for(let C=0;C<r.inChannels;++C)for(let N=0;N<r.outHeight;++N){const A=N*i-h,I=Math.max(0,A),E=Math.min(r.inHeight,c+A),z=v+N*b;for(let P=0;P<r.outWidth;++P){const H=P*o-p,G=Math.max(0,H),W=Math.min(r.inWidth,d+H);let L=f,B=0,Y=0;for(let M=I;M<E;M+=u){const Z=k+M*s[1];for(let J=G;J<W;J+=l){const oe=Z+J*s[2],de=t[oe+C];a==="max"&&de>L?L=de:a==="avg"&&(B+=de,Y++)}if(isNaN(L))break}const ne=z+P*$+C;g[ne]=a==="avg"?B/Y:L}}}return m}function xE(t,e,n,s,r=!1,a=!1){const i=qe(s.outShape,"int32"),o=s.strideHeight,u=s.strideWidth,l=s.dilationHeight,c=s.dilationWidth,d=s.effectiveFilterHeight,h=s.effectiveFilterWidth,p=s.padInfo.top,f=s.padInfo.left,m=qe(e,n,t);for(let g=0;g<s.batchSize;++g)for(let y=0;y<s.inChannels;++y)for(let b=0;b<s.outHeight;++b){const $=b*o-p;let w=$;for(;w<0;)w+=l;const v=Math.min(s.inHeight,d+$);for(let k=0;k<s.outWidth;++k){const C=k*u-f;let N=C;for(;N<0;)N+=c;const A=Math.min(s.inWidth,h+C);let I=Number.NEGATIVE_INFINITY,E=-1;for(let z=w;z<v;z+=l){const P=z-$;for(let H=N;H<A;H+=c){const G=H-C,W=m.get(g,z,H,y);W>I&&(I=W,r?E=a?((g*s.inHeight+z)*s.inWidth+H)*s.inChannels+y:(z*s.inWidth+H)*s.inChannels+y:E=P*h+G)}}i.set(E,g,b,k,y)}}return i}function wE(t,e,n,s,r,a){const i=r.strideDepth,o=r.strideHeight,u=r.strideWidth,l=r.dilationDepth,c=r.dilationHeight,d=r.dilationWidth,h=r.effectiveFilterDepth,p=r.effectiveFilterHeight,f=r.effectiveFilterWidth,m=r.padInfo.front,g=r.padInfo.top,y=r.padInfo.left,b=a==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,$=qe(r.outShape,n),w=$.values,v=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],k=r.outShape[2]*r.outShape[3]*r.outShape[4],C=r.outShape[3]*r.outShape[4],N=r.outShape[4];for(let A=0;A<r.batchSize;++A){const I=A*v,E=A*s[0];for(let z=0;z<r.inChannels;++z)for(let P=0;P<r.outDepth;++P){const H=P*i-m;let G=H;for(;G<0;)G+=l;const W=Math.min(r.inDepth,h+H),L=I+P*k;for(let B=0;B<r.outHeight;++B){const Y=B*o-g;let ne=Y;for(;ne<0;)ne+=c;const M=Math.min(r.inHeight,p+Y),Z=L+B*C;for(let J=0;J<r.outWidth;++J){const oe=J*u-y;let de=oe;for(;de<0;)de+=d;const fe=Math.min(r.inWidth,f+oe),xe=Z+J*N;let Ne=b,$e=0,Ee=0;for(let Oe=G;Oe<W;Oe+=l){const Fe=E+Oe*s[1];for(let Je=ne;Je<M;Je+=c){const ct=Fe+Je*s[2];for(let Ke=de;Ke<fe;Ke+=d){const Le=ct+Ke*s[3],ft=t[Le+z];if(a==="max"&&ft>Ne?Ne=ft:a==="avg"&&($e+=ft,Ee++),isNaN(Ne))break}if(isNaN(Ne))break}if(isNaN(Ne))break}const ze=xe+z;w[ze]=a==="avg"?$e/Math.max(Ee,1):Ne}}}}return $}function c5(t,e){const n=qe(e.outShape,"int32"),s=e.strideDepth,r=e.strideHeight,a=e.strideWidth,i=e.dilationDepth,o=e.dilationHeight,u=e.dilationWidth,l=e.effectiveFilterDepth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=e.padInfo.front,p=e.padInfo.top,f=e.padInfo.left;for(let m=0;m<e.batchSize;++m)for(let g=0;g<e.inChannels;++g)for(let y=0;y<e.outDepth;++y){const b=y*s-h;let $=b;for(;$<0;)$+=i;const w=Math.min(e.inDepth,l+b);for(let v=0;v<e.outHeight;++v){const k=v*r-p;let C=k;for(;C<0;)C+=o;const N=Math.min(e.inHeight,c+k);for(let A=0;A<e.outWidth;++A){const I=A*a-f;let E=I;for(;E<0;)E+=u;const z=Math.min(e.inWidth,d+I);let P=Number.NEGATIVE_INFINITY,H=-1;for(let G=$;G<w;G+=i){const W=G-b;for(let L=C;L<N;L+=o){const B=L-k;for(let Y=E;Y<z;Y+=u){const ne=Y-I,M=t.get(m,G,L,Y,g);M>=P&&(P=M,H=W*c*d+B*c+ne)}}}n.set(H,m,y,v,A,g)}}}return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d5(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e;_e(r,"avgPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=s,l=1;O(pn(i,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);const c=_s(r.shape,a,i,l,o,u);let d;if(c.filterWidth===1&&c.filterHeight===1&&tt(c.inShape,c.outShape))d=yr({inputs:{x:r},backend:n});else{const h=n.data.get(r.dataId).values,p=Ae(r.shape),f=p0(h,r.shape,r.dtype,p,c,"avg");d=n.makeTensorInfo(c.outShape,r.dtype,f.values)}return d}const h5={kernelName:Id,backendName:"cpu",kernelFunc:d5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p5(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{filterSize:a,strides:i,pad:o,dimRoundingMode:u,dataFormat:l}=s;_e(r,"avgPool3d");const c=Or(r.shape,a,i,1,o,u,l),d=n.data.get(r.dataId).values,h=wE(d,r.shape,r.dtype,Ae(r.shape),c,"avg");return n.makeTensorInfo(h.shape,"float32",h.values)}const f5={kernelName:_d,backendName:"cpu",kernelFunc:p5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m5(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:a}=e,{filterSize:i,strides:o,pad:u,dimRoundingMode:l}=s;_e([r,a],"avgPool3DGrad");const c=Or(a.shape,i,o,1,u,l),d=c.strideDepth,h=c.strideHeight,p=c.strideWidth,f=c.filterDepth,m=c.filterHeight,g=c.filterWidth,y=c.dilationDepth,b=c.dilationHeight,$=c.dilationWidth,w=c.effectiveFilterDepth,v=c.effectiveFilterHeight,k=c.effectiveFilterWidth,C=w-1-c.padInfo.front,N=k-1-c.padInfo.left,A=v-1-c.padInfo.top,I=qe(a.shape,"float32"),E=1/(f*m*g),z=n.bufferSync(r);for(let P=0;P<c.batchSize;++P)for(let H=0;H<c.inChannels;++H)for(let G=0;G<c.inDepth;++G)for(let W=0;W<c.inHeight;++W)for(let L=0;L<c.inWidth;++L){const B=G-C,Y=W-A,ne=L-N;let M=0;for(let Z=0;Z<w;Z+=y){const J=(B+Z)/d;if(!(J<0||J>=c.outDepth||Math.floor(J)!==J))for(let oe=0;oe<v;oe+=b){const de=(Y+oe)/h;if(!(de<0||de>=c.outHeight||Math.floor(de)!==de))for(let fe=0;fe<k;fe+=$){const xe=(ne+fe)/p;if(xe<0||xe>=c.outWidth||Math.floor(xe)!==xe)continue;const Ne=z.get(P,J,de,xe,H);M+=Ne}}}I.set(M*E,P,G,W,L,H)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}const g5={kernelName:Sg,backendName:"cpu",kernelFunc:m5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y5(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:a}=e,i=a;_e([r,a],"avgPoolGrad");const{filterSize:o,strides:u,pad:l}=s,c=_s(i.shape,o,u,1,l),d=c.strideHeight,h=c.strideWidth,p=c.filterHeight,f=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,y=c.effectiveFilterHeight,b=c.effectiveFilterWidth,$=b-1-c.padInfo.left,w=y-1-c.padInfo.top,v=qe(i.shape,"float32"),k=1/(p*f),C=n.data.get(r.dataId).values,N=qe(r.shape,"float32",C);for(let A=0;A<c.batchSize;++A)for(let I=0;I<c.inChannels;++I)for(let E=0;E<c.inHeight;++E)for(let z=0;z<c.inWidth;++z){const P=E-w,H=z-$;let G=0;for(let W=0;W<y;W+=m){const L=(P+W)/d;if(!(L<0||L>=c.outHeight||Math.floor(L)!==L))for(let B=0;B<b;B+=g){const Y=(H+B)/h;if(Y<0||Y>=c.outWidth||Math.floor(Y)!==Y)continue;const ne=N.get(A,L,Y,I);G+=ne}}v.set(G*k,A,E,z,I)}return n.makeTensorInfo(v.shape,v.dtype,v.values)}const b5={kernelName:vg,backendName:"cpu",kernelFunc:y5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x5(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,scale:a,offset:i,mean:o,variance:u}=e;O(o.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),O(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),O(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),_e([r,o,u,a,i],"batchNorm");let{varianceEpsilon:l}=s;l==null&&(l=.001);const c=n.data.get(r.dataId).values,d=n.data.get(o.dataId).values,h=n.data.get(u.dataId).values,p=a?n.data.get(a.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=f.length,y=p.length,b=h.length,$=d.length;let w=0,v=0,k=0,C=0;for(let N=0;N<c.length;++N)m[N]=f[w++]+(c[N]-d[v++])*p[k++]/Math.sqrt(h[C++]+l),w>=g&&(w=0),v>=$&&(v=0),k>=y&&(k=0),C>=b&&(C=0);return n.makeTensorInfo(r.shape,r.dtype,m)}const w5={kernelName:Bd,backendName:"cpu",kernelFunc:x5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $5(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockShape:a,crops:i}=s;_e([r],"batchToSpaceND");const o=a.reduce((y,b)=>y*b),u=Il(r.shape,a,o),l=_l(u.length,a.length),c=kl(r.shape,a,o),d=vb(i,a.length),h=Sb(c,i,a.length),p=St({inputs:{x:r},backend:n,attrs:{shape:u}}),f=zn({inputs:{x:p},backend:n,attrs:{perm:l}}),m=St({inputs:{x:f},backend:n,attrs:{shape:c}}),g=ci({inputs:{x:m},backend:n,attrs:{begin:d,size:h}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const v5={kernelName:Cd,backendName:"cpu",kernelFunc:$5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S5(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,weights:a}=e,{size:i}=s,o=n.data.get(r.dataId).values,u=n.data.get(a.dataId).values,l=u0(o,u,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,l)}const I5={kernelName:Ig,backendName:"cpu",kernelFunc:S5};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _5(t){const{inputs:e,backend:n}=t,{s0:s,s1:r}=e,a=n.data.get(s.dataId).values,i=n.data.get(r.dataId).values,o=We(Array.from(a),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const k5={kernelName:_g,backendName:"cpu",kernelFunc:_5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C5=pt(Eu,(t,e)=>{const n=e;return t>n.clipValueMax?n.clipValueMax:t<n.clipValueMin?n.clipValueMin:t}),T5={kernelName:Eu,backendName:"cpu",kernelFunc:C5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N5=t=>{const{x:e}=t.inputs,n=t.backend,s=new Float32Array(se(e.shape)),r=n.data.get(e.dataId),a=r.complexTensorInfos.real,i=r.complexTensorInfos.imag,o=n.data.get(a.dataId).values,u=n.data.get(i.dataId).values;for(let l=0;l<o.length;l++){const c=o[l],d=u[l];s[l]=Math.hypot(c,d)}return n.makeOutput(s,e.shape,"float32")},E5={kernelName:Nd,backendName:"cpu",kernelFunc:N5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eo(t){const{inputs:e,backend:n}=t,{input:s}=e,r=n.data.get(s.dataId).complexTensorInfos.imag,a=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,a)}const A5={kernelName:Gg,backendName:"cpu",kernelFunc:eo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function to(t){const{inputs:e,backend:n,attrs:s}=t,{axis:r}=s,a=Ye(r,e[0].shape)[0],i=e.map(m=>m.shape);xb(i,a);let o=hr(e.map(m=>m.shape),a);if(se(o)===0)return n.makeTensorInfo(o,e[0].dtype,[]);const u=e.filter(m=>se(m.shape)>0);if(u.length===1)return yr({inputs:{x:u[0]},backend:n});if(u[0].dtype==="complex64"){const m=u.map(w=>li({inputs:{input:w},backend:n})),g=u.map(w=>eo({inputs:{input:w},backend:n})),y=to({inputs:m,backend:n,attrs:{axis:a}}),b=to({inputs:g,backend:n,attrs:{axis:a}}),$=Wn({inputs:{real:y,imag:b},backend:n});return m.forEach(w=>n.disposeIntermediateTensorInfo(w)),g.forEach(w=>n.disposeIntermediateTensorInfo(w)),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(b),$}const l=u.map(m=>{const y=[-1,se(m.shape.slice(a))];return St({inputs:{x:m},backend:n,attrs:{shape:y}})}),c=l.map(m=>({vals:n.data.get(m.dataId).values,shape:m.shape}));o=hr(l.map(m=>m.shape),1);const d=l[0].shape[0]===1,h=_N(c,o,e[0].dtype,d),p=hr(u.map(m=>m.shape),a),f=n.makeTensorInfo(p,e[0].dtype,h);return l.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}const R5={kernelName:Ed,backendName:"cpu",kernelFunc:to};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $E(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:a}=e,{strides:i,pad:o,dataFormat:u,dilations:l,dimRoundingMode:c}=s;_e([r,a],"conv2d");const d=Fr(u),h=rn(r.shape,a.shape,i,l,o,c,!1,d),p=h.filterHeight,f=h.filterWidth,m=h.dilationHeight,g=h.dilationWidth,y=h.padInfo.left,b=h.padInfo.top,$=h.dataFormat==="channelsLast",w=new jt(h.outShape,r.dtype),v=Ae(r.shape),k=Ae(a.shape),C=v[0],N=$?v[1]:v[2],A=$?v[2]:1,I=$?1:v[1],E=w.strides[0],z=$?w.strides[1]:w.strides[2],P=$?w.strides[2]:1,H=$?1:w.strides[1],G=n.data.get(r.dataId).values,W=n.data.get(a.dataId).values,L=w.values;for(let B=0;B<h.batchSize;++B){const Y=B*C,ne=B*E;for(let M=0;M<h.outHeight;++M){const Z=ne+M*z,J=M*h.strideHeight-b;for(let oe=0;oe<p;++oe){const de=J+oe*m;if(de<0||de>=h.inHeight)continue;const fe=oe*k[0],xe=Y+de*N;for(let Ne=0;Ne<h.outWidth;++Ne){const $e=Z+Ne*P,Ee=Ne*h.strideWidth-y;for(let ze=0;ze<f;++ze){const Oe=Ee+ze*g;if(Oe<0||Oe>=h.inWidth)continue;const Fe=fe+ze*k[1],Je=xe+Oe*A;let ct=Fe;for(let Ke=0;Ke<h.inChannels;++Ke){const Le=G[Je+Ke*I];for(let ft=0;ft<h.outChannels;++ft)L[$e+ft*H]+=Le*W[ct+ft];ct+=h.outChannels}}}}}}return n.makeTensorInfo(w.shape,w.dtype,L)}const D5={kernelName:Ad,backendName:"cpu",kernelFunc:$E};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O5(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:a}=e,{strides:i,pad:o,dataFormat:u,dimRoundingMode:l,filterShape:c}=s;_e([r,a],"conv2dBackpropFilter");const d=Fr(u),h=rn(r.shape,c,i,1,o,l,!1,d),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=h,y=h.dataFormat==="channelsLast",b=new jt(h.filterShape,"float32"),$=h.padInfo.left,w=h.padInfo.top,v=n.data.get(r.dataId).values,k=n.data.get(a.dataId).values,C=new jt(r.shape,r.dtype,v),N=new jt(a.shape,a.dtype,k);for(let A=0;A<m;++A){const I=Math.max(0,Math.ceil((w-A)/p)),E=Math.min(h.outHeight,(h.inHeight+w-A)/p);for(let z=0;z<g;++z){const P=Math.max(0,Math.ceil(($-z)/f)),H=Math.min(h.outWidth,(h.inWidth+$-z)/f);for(let G=0;G<h.inChannels;++G)for(let W=0;W<h.outChannels;++W){let L=0;for(let B=0;B<h.batchSize;++B)for(let Y=I;Y<E;++Y){const ne=A+Y*p-w;for(let M=P;M<H;++M){const Z=z+M*f-$;y?L+=C.get(B,ne,Z,G)*N.get(B,Y,M,W):L+=C.get(B,G,ne,Z)*N.get(B,W,Y,M)}}b.set(L,A,z,G,W)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}const F5={kernelName:Cg,backendName:"cpu",kernelFunc:O5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z5(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:a}=e,{inputShape:i,strides:o,pad:u,dataFormat:l,dimRoundingMode:c}=s;_e([r,a],"conv2dBackpropInput");const d=Ae(a.shape),h=Ae(r.shape);let p=Fr(l);const f=rn(i,a.shape,o,1,u,c,!1,p),m=new jt(f.inShape,"float32"),g=m.values,y=n.data.get(r.dataId).values,b=n.data.get(a.dataId).values,[$,w,v]=d,{batchSize:k,filterHeight:C,filterWidth:N,inChannels:A,inHeight:I,inWidth:E,outChannels:z,outHeight:P,outWidth:H,strideHeight:G,strideWidth:W}=f;p=f.dataFormat;const L=C-1-f.padInfo.top,B=N-1-f.padInfo.left,Y=p==="channelsLast",ne=m.strides[0],M=Y?m.strides[1]:m.strides[2],Z=Y?m.strides[2]:1,J=Y?1:m.strides[1],oe=h[0],de=Y?h[1]:h[2],fe=Y?h[2]:1,xe=Y?1:h[1];for(let Ne=0;Ne<k;++Ne)for(let $e=0;$e<A;++$e)for(let Ee=0;Ee<I;++Ee){const ze=Ee-L,Oe=Math.max(0,Math.ceil(ze/G)),Fe=Math.min(P,(C+ze)/G);for(let Je=0;Je<E;++Je){const ct=Je-B,Ke=Math.max(0,Math.ceil(ct/W)),Le=Math.min(H,(N+ct)/W);let ft=0;for(let Ft=Oe;Ft<Fe;++Ft){const yn=Ft*G-ze;for(let Qt=Ke;Qt<Le;++Qt){const er=Qt*W-ct,Jt=oe*Ne+de*Ft+fe*Qt,ls=$*(C-1-yn)+w*(N-1-er)+v*$e;for(let Ns=0;Ns<z;++Ns){const Es=y[Jt+xe*Ns],As=b[ls+Ns];ft+=Es*As}}}const us=ne*Ne+M*Ee+Z*Je+J*$e;g[us]=ft}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}const L5={kernelName:Rd,backendName:"cpu",kernelFunc:z5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P5(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:a}=e,{strides:i,pad:o,dilations:u}=s;_e([r,a],"conv3d");const l=ba(r.shape,a.shape,i,u,o),{filterDepth:c,filterHeight:d,filterWidth:h,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=l,y=g.front,b=g.left,$=g.top,w=new jt(l.outShape,r.dtype),v=n.data.get(r.dataId).values,k=n.data.get(a.dataId).values,C=w.values,N=Ae(r.shape),A=Ae(a.shape);for(let I=0;I<l.batchSize;++I){const E=I*N[0],z=I*w.strides[0];for(let P=0;P<l.outDepth;++P){const H=z+P*w.strides[1],G=P*l.strideDepth-y;for(let W=0;W<c;++W){const L=G+W*p;if(L<0||L>=l.inDepth)continue;const B=W*A[0],Y=E+L*N[1];for(let ne=0;ne<l.outHeight;++ne){const M=H+ne*w.strides[2],Z=ne*l.strideHeight-$;for(let J=0;J<d;++J){const oe=Z+J*f;if(oe<0||oe>=l.inHeight)continue;const de=B+J*A[1],fe=Y+oe*N[2];for(let xe=0;xe<l.outWidth;++xe){const Ne=M+xe*l.outChannels,$e=xe*l.strideWidth-b;for(let Ee=0;Ee<h;++Ee){const ze=$e+Ee*m;if(ze<0||ze>=l.inWidth)continue;const Oe=de+Ee*A[2],Fe=fe+ze*l.inChannels;let Je=Oe;for(let ct=0;ct<l.inChannels;++ct){const Ke=v[Fe+ct];for(let Le=0;Le<l.outChannels;++Le)C[Ne+Le]+=Ke*k[Je+Le];Je+=l.outChannels}}}}}}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}const B5={kernelName:Dd,backendName:"cpu",kernelFunc:P5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M5(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:a}=e,{strides:i,pad:o,filterShape:u}=s;_e([r,a],"conv3dBackpropFilterV2");const l=Ae(r.shape),c=Ae(a.shape),d=ba(r.shape,u,i,1,o),h=d.strideDepth,p=d.strideHeight,f=d.strideWidth,m=d.filterDepth,g=d.filterHeight,y=d.filterWidth,b=new jt(d.filterShape,"float32"),$=b.values,[w,v,k,C]=b.strides,N=n.data.get(a.dataId).values,[A,I,E,z]=c,P=n.data.get(r.dataId).values,[H,G,W,L]=l,B=d.padInfo.front,Y=d.padInfo.left,ne=d.padInfo.top;for(let M=0;M<m;++M){const Z=Math.max(0,Math.ceil((B-M)/h)),J=Math.min(d.outDepth,(d.inDepth+B-M)/h),oe=M*w;for(let de=0;de<g;++de){const fe=Math.max(0,Math.ceil((ne-de)/p)),xe=Math.min(d.outHeight,(d.inHeight+ne-de)/p),Ne=de*v+oe;for(let $e=0;$e<y;++$e){const Ee=Math.max(0,Math.ceil((Y-$e)/f)),ze=Math.min(d.outWidth,(d.inWidth+Y-$e)/f),Oe=$e*k+Ne;for(let Fe=0;Fe<d.inChannels;++Fe){const Je=Fe*C+Oe;for(let ct=0;ct<d.outChannels;++ct){let Ke=0;for(let Le=0;Le<d.batchSize;++Le){const ft=Le*H,us=Le*A;for(let Ft=Z;Ft<J;++Ft){const Qt=(M+Ft*h-B)*G+ft,er=Ft*I+us;for(let Jt=fe;Jt<xe;++Jt){const Ns=(de+Jt*p-ne)*W+Qt,Es=Jt*E+er;for(let As=Ee;As<ze;++As){const Mr=($e+As*f-Y)*L+Ns,Vr=As*z+Es;Ke+=P[Mr+Fe]*N[Vr+ct]}}}}$[Je+ct]=Ke}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}const V5={kernelName:Tg,backendName:"cpu",kernelFunc:M5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W5(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:a}=e,{pad:i,strides:o,inputShape:u}=s;_e([r],"conv3dBackpropInputV2");const l=Ae(r.shape),c=Ae(a.shape),d=ba(u,a.shape,o,1,i),h=new jt(d.inShape,"float32"),p=h.values,[f,m,g,y]=h.strides,b=n.data.get(r.dataId).values,[$,w,v,k]=l,C=n.data.get(a.dataId).values,[N,A,I,E]=c,{batchSize:z,filterDepth:P,filterHeight:H,filterWidth:G,inChannels:W,inDepth:L,inHeight:B,inWidth:Y,outChannels:ne,outDepth:M,outHeight:Z,outWidth:J,strideDepth:oe,strideHeight:de,strideWidth:fe}=d,xe=P-1-d.padInfo.front,Ne=H-1-d.padInfo.top,$e=G-1-d.padInfo.left;for(let Ee=0;Ee<z;++Ee)for(let ze=0;ze<W;++ze)for(let Oe=0;Oe<L;++Oe){const Fe=Oe-xe,Je=Math.max(0,Math.ceil(Fe/oe)),ct=Math.min(M,(P+Fe)/oe);for(let Ke=0;Ke<B;++Ke){const Le=Ke-Ne,ft=Math.max(0,Math.ceil(Le/de)),us=Math.min(Z,(H+Le)/de);for(let Ft=0;Ft<Y;++Ft){const yn=Ft-$e,Qt=Math.max(0,Math.ceil(yn/fe)),er=Math.min(J,(G+yn)/fe);let Jt=0;for(let ls=Je;ls<ct;++ls){const Ns=ls*oe-Fe;for(let Es=ft;Es<us;++Es){const As=Es*de-Le;for(let Ca=Qt;Ca<er;++Ca){const Mr=Ca*fe-yn,Vr=$*Ee+w*ls+v*Es+k*Ca,fp=N*(P-1-Ns)+A*(H-1-As)+I*(G-1-Mr)+E*ze;for(let Rs=0;Rs<ne;++Rs){const mp=b[Vr+Rs],Vl=C[fp+Rs];Jt+=mp*Vl}}}}p[f*Ee+m*Oe+g*Ke+y*Ft+ze]=Jt}}}return n.makeTensorInfo(h.shape,h.dtype,h.values)}const U5={kernelName:Ng,backendName:"cpu",kernelFunc:W5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G5=pt(Au,t=>Math.cos(t)),H5={kernelName:Au,backendName:"cpu",kernelFunc:G5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q5=pt(Ru,t=>Math.cosh(t)),j5={kernelName:Ru,backendName:"cpu",kernelFunc:q5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K5(t){const{inputs:e,backend:n,attrs:s}=t,{image:r,boxes:a,boxInd:i}=e,{cropSize:o,method:u,extrapolationValue:l}=s,[c,d,h,p]=r.shape,f=a.shape[0],[m,g]=o,y=qe([f,m,g,p],"float32"),b=n.data.get(a.dataId).values,$=n.data.get(i.dataId).values,w=n.data.get(r.dataId).values,v=Ae(r.shape),k=Ae(y.shape);for(let C=0;C<f;C++){const N=C*4,A=b[N],I=b[N+1],E=b[N+2],z=b[N+3],P=$[C];if(P>=c)continue;const H=m>1?(E-A)*(d-1)/(m-1):0,G=g>1?(z-I)*(h-1)/(g-1):0;for(let W=0;W<m;W++){const L=m>1?A*(d-1)+W*H:.5*(A+E)*(d-1);if(L<0||L>d-1){for(let B=0;B<g;B++)for(let Y=0;Y<p;Y++){const ne=Y+B*k[2]+W*k[1]+C*k[0];y.values[ne]=l}continue}if(u==="bilinear"){const B=Math.floor(L),Y=Math.ceil(L),ne=L-B;for(let M=0;M<g;M++){const Z=g>1?I*(h-1)+M*G:.5*(I+z)*(h-1);if(Z<0||Z>h-1){for(let fe=0;fe<p;fe++){const xe=fe+M*k[2]+W*k[1]+C*k[0];y.values[xe]=l}continue}const J=Math.floor(Z),oe=Math.ceil(Z),de=Z-J;for(let fe=0;fe<p;fe++){let xe=fe+J*v[2]+B*v[1]+P*v[0];const Ne=w[xe];xe=fe+oe*v[2]+B*v[1]+P*v[0];const $e=w[xe];xe=fe+J*v[2]+Y*v[1]+P*v[0];const Ee=w[xe];xe=fe+oe*v[2]+Y*v[1]+P*v[0];const ze=w[xe],Oe=Ne+($e-Ne)*de,Fe=Ee+(ze-Ee)*de;xe=fe+M*k[2]+W*k[1]+C*k[0],y.values[xe]=Oe+(Fe-Oe)*ne}}}else for(let B=0;B<g;++B){const Y=g>1?I*(h-1)+B*G:.5*(I+z)*(h-1);if(Y<0||Y>h-1){for(let Z=0;Z<p;Z++){const J=Z+B*k[2]+W*k[1]+C*k[0];y.values[J]=l}continue}const ne=Math.round(Y),M=Math.round(L);for(let Z=0;Z<p;Z++){const J=Z+ne*v[2]+M*v[1]+P*v[0],oe=Z+B*k[2]+W*k[1]+C*k[0];y.values[oe]=w[J]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}const X5={kernelName:Ag,backendName:"cpu",kernelFunc:K5};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y5(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:a,exclusive:i,reverse:o}=s;_e(r,"cumprod");const u=At([a],r.shape.length);let l=r;u!=null&&(l=zn({inputs:{x:r},backend:n,attrs:{perm:u}}));const c=Pt(1,r.shape.length)[0];if(c!==l.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${c}`);const d=Hn(l.dtype,"int32"),h=bg(se(l.shape),d),p=n.data.get(l.dataId).values,f=l.shape[l.shape.length-1],m=o?(y,b)=>y+f-b-1:(y,b)=>y+b;for(let y=0;y<p.length;y+=f)for(let b=0;b<f;b++){const $=m(y,b);if(b===0)h[$]=i?1:p[$];else{const w=m(y,b-1);h[$]=i?p[w]*h[w]:p[$]*h[w]}}const g=n.makeTensorInfo(l.shape,d,h);if(u!=null){const y=xa(u),b=zn({inputs:{x:g},backend:n,attrs:{perm:y}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(l),b}return g}const Z5={kernelName:Eg,backendName:"cpu",kernelFunc:Y5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q5(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:a,exclusive:i,reverse:o}=s;_e(r,"cumsum");const u=At([a],r.shape.length);let l=r;u!=null&&(l=zn({inputs:{x:r},backend:n,attrs:{perm:u}}));const c=Pt(1,r.shape.length)[0];if(c!==l.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${c}`);const d=Hn(l.dtype,"int32"),h=xn(se(l.shape),d),p=n.data.get(l.dataId).values,f=l.shape[l.shape.length-1],m=o?(y,b)=>y+f-b-1:(y,b)=>y+b;for(let y=0;y<p.length;y+=f)for(let b=0;b<f;b++){const $=m(y,b);if(b===0)h[$]=i?0:p[$];else{const w=m(y,b-1);h[$]=i?p[w]+h[w]:p[$]+h[w]}}const g=n.makeTensorInfo(l.shape,d,h);if(u!=null){const y=xa(u),b=zn({inputs:{x:g},backend:n,attrs:{perm:y}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(l),b}return g}const J5={kernelName:Od,backendName:"cpu",kernelFunc:Q5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eX(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,weights:a}=e,{size:i,binaryOutput:o}=s;if(r.shape.length===1){const u=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,c=u0(u,l,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,c)}else if(r.shape.length===2){const u=n.bufferSync(r),l=n.bufferSync(a),c=vN(u,l,i,o);return n.makeTensorInfo(c.shape,a.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const tX={kernelName:Rg,backendName:"cpu",kernelFunc:eX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nX(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockSize:a,dataFormat:i}=s;O(i==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);const o=r.shape[0],u=r.shape[1],l=r.shape[2],c=r.shape[3],d=u*a,h=l*a,p=c/(a*a),f=n.data.get(r.dataId).values,m=new Float32Array(o*d*h*p);let g=0;for(let y=0;y<o;++y)for(let b=0;b<d;++b){const $=Math.floor(b/a),w=b%a;for(let v=0;v<h;++v){const k=Math.floor(v/a),C=v%a,N=(w*a+C)*p;for(let A=0;A<p;++A){const E=A+N+c*(k+l*($+u*y));m[g++]=f[E]}}}return n.makeTensorInfo([o,d,h,p],r.dtype,m)}const sX={kernelName:Dg,backendName:"cpu",kernelFunc:nX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vE(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:a}=e,{strides:i,pad:o,dilations:u,dimRoundingMode:l}=s;_e([r,a],"depthwiseConv2DNative");const c=Ae(r.shape),d=Ae(a.shape);let h=u;h==null&&(h=[1,1]),O(pn(i,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`);const p=rn(r.shape,a.shape,i,h,o,l,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=p,$=b.left,w=b.top,v=p.outChannels/p.inChannels,k=new jt(p.outShape,r.dtype),C=n.data.get(r.dataId).values,N=n.data.get(a.dataId).values,A=k.values;for(let I=0;I<p.batchSize;++I){const E=I*c[0],z=I*k.strides[0];for(let P=0;P<p.outHeight;++P){const H=z+P*k.strides[1],G=P*p.strideHeight-w;for(let W=0;W<f;++W){const L=G+W*g;if(L<0||L>=p.inHeight)continue;const B=W*d[0],Y=E+L*c[1];for(let ne=0;ne<p.outWidth;++ne){const M=H+ne*k.strides[2],Z=ne*p.strideWidth-$;for(let J=0;J<m;++J){const oe=Z+J*y;if(oe<0||oe>=p.inWidth)continue;const de=B+J*d[1],fe=Y+oe*p.inChannels;let xe=M,Ne=de;for(let $e=0;$e<p.inChannels;++$e){const Ee=C[fe+$e];for(let ze=0;ze<v;++ze)A[xe+ze]+=Ee*N[Ne+ze];xe+=v,Ne+=v}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const rX={kernelName:Fd,backendName:"cpu",kernelFunc:vE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aX(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:a}=e,{strides:i,dilations:o,pad:u,dimRoundingMode:l,filterShape:c}=s;_e([r,a],"depthwiseConv2dNativeBackpropFilter");const d=rn(r.shape,c,i,o,u,l,!0),{strideHeight:h,strideWidth:p,filterHeight:f,filterWidth:m}=d,g=new jt(d.filterShape,"float32"),y=d.padInfo.left,b=d.padInfo.top,$=d.outChannels/d.inChannels,w=n.data.get(r.dataId).values,v=new jt(r.shape,r.dtype,w),k=n.data.get(a.dataId).values,C=new jt(a.shape,a.dtype,k);for(let N=0;N<f;++N){const A=Math.max(0,Math.ceil((b-N)/h)),I=Math.min(d.outHeight,(d.inHeight+b-N)/h);for(let E=0;E<m;++E){const z=Math.max(0,Math.ceil((y-E)/p)),P=Math.min(d.outWidth,(d.inWidth+y-E)/p);for(let H=0;H<d.outChannels;++H){const G=Math.trunc(H/$),W=H%$;let L=0;for(let B=0;B<d.batchSize;++B)for(let Y=A;Y<I;++Y){const ne=N+Y*h-b;for(let M=z;M<P;++M){const Z=E+M*p-y;L+=v.get(B,ne,Z,G)*C.get(B,Y,M,H)}}g.set(L,N,E,G,W)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}const iX={kernelName:Og,backendName:"cpu",kernelFunc:aX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oX(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:a}=e,{strides:i,dilations:o,pad:u,dimRoundingMode:l,inputShape:c}=s;_e([r,a],"depthwiseConv2DNativeBackpropInput");const d=Ae(r.shape),h=Ae(a.shape),p=rn(c,a.shape,i,o,u,l,!0),f=new jt(p.inShape,"float32"),m=f.values,[g,y,b]=f.strides,$=n.data.get(r.dataId).values,[w,v,k]=d,C=n.data.get(a.dataId).values,[N,A,I]=h,{batchSize:E,filterHeight:z,filterWidth:P,inChannels:H,inHeight:G,inWidth:W,outChannels:L,outHeight:B,outWidth:Y,strideHeight:ne,strideWidth:M}=p,Z=z-1-p.padInfo.top,J=P-1-p.padInfo.left,oe=L/H;for(let de=0;de<E;++de)for(let fe=0;fe<H;++fe)for(let xe=0;xe<G;++xe){const Ne=xe-Z,$e=Math.max(0,Math.ceil(Ne/ne)),Ee=Math.min(B,(z+Ne)/ne);for(let ze=0;ze<W;++ze){const Oe=ze-J,Fe=Math.max(0,Math.ceil(Oe/M)),Je=Math.min(Y,(P+Oe)/M);let ct=0;for(let Ke=$e;Ke<Ee;++Ke){const Le=Ke*ne-Ne;for(let ft=Fe;ft<Je;++ft){const us=ft*M-Oe,Ft=w*de+v*Ke+k*ft,yn=N*(z-1-Le)+A*(P-1-us)+I*fe;for(let Qt=0;Qt<oe;++Qt){const er=fe*oe+Qt,Jt=$[Ft+er],ls=C[yn+Qt];ct+=Jt*ls}}}m[g*de+y*xe+b*ze+fe]=ct}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}const uX={kernelName:Fg,backendName:"cpu",kernelFunc:oX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lX(t){const{inputs:e,backend:n}=t,{x:s}=e,r=se(s.shape),a=n.data.get(s.dataId).values,i=qe([r,r],s.dtype),o=i.values;for(let l=0;l<a.length;l++)o[l*r+l]=a[l];const u=[...s.shape,...s.shape];return n.makeTensorInfo(u,i.dtype,i.values)}const cX={kernelName:zg,backendName:"cpu",kernelFunc:lX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dX={kernelName:zd,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:s,filter:r}=t,{strides:a,pad:i,dilations:o}=n,u=e,l=u.data.get(s.dataId).values,c=s.shape.length,d=u.data.get(r.dataId).values,h=r.shape.length,{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:$,strideHeight:w,strideWidth:v,filterHeight:k,filterWidth:C,dilationHeight:N,dilationWidth:A,outShape:I}=yl(s.shape,r.shape,a,i,"NHWC",o),E=se(I),z=I.length,P=zt(s.dtype,E);for(let G=0;G<p;++G)for(let W=0;W<y;++W){const L=W*w-$.top;for(let B=0;B<b;++B){const Y=B*v-$.left;for(let ne=0;ne<g;++ne){let M=Number.MIN_SAFE_INTEGER;for(let J=0;J<k;++J){const oe=L+J*N;if(oe>=0&&oe<f)for(let de=0;de<C;++de){const fe=Y+de*A;if(fe>=0&&fe<m){const xe=cr([G,oe,fe,ne],c,Ae(s.shape)),Ne=cr([J,de,ne],h,Ae(r.shape)),$e=l[xe]+d[Ne];$e>M&&(M=$e)}}}const Z=cr([G,W,B,ne],z,Ae(I));P[Z]=M}}}return{dataId:u.write(mi(P,s.dtype),I,s.dtype),shape:I,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hX={kernelName:om,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:s,filter:r,dy:a}=t,{strides:i,pad:o,dilations:u}=n,l=e,c=ws(s.shape,l.data.get(s.dataId).values),d=ws(r.shape,l.data.get(r.dataId).values),{batchSize:h,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:$,strideWidth:w,filterHeight:v,filterWidth:k,dilationHeight:C,dilationWidth:N,outShape:A}=yl(s.shape,r.shape,i,o,"NHWC",u);O(a.rank===A.length,()=>`Error in ${om}, dy must have the same rank as output ${A.length}, but got ${a.rank}`);const I=ws(A,l.data.get(a.dataId).values),E=bI(r.shape,r.dtype);for(let P=0;P<h;++P)for(let H=0;H<g;++H){const G=H*$-b.top;for(let W=0;W<y;++W){const L=W*w-b.left;for(let B=0;B<m;++B){let Y=Number.MIN_SAFE_INTEGER,ne=0,M=0;for(let Z=0;Z<v;++Z){const J=G+Z*C;if(J>=0&&J<p)for(let oe=0;oe<k;++oe){const de=L+oe*N;if(de>=0&&de<f){const fe=c[P][J][de][B]+d[Z][oe][B];fe>Y&&(Y=fe,ne=Z,M=oe)}}}E[ne][M][B]+=I[P][H][W][B]}}}return{dataId:l.write(mi(E,s.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pX={kernelName:im,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:s,filter:r,dy:a}=t,{strides:i,pad:o,dilations:u}=n,l=e,c=ws(s.shape,l.data.get(s.dataId).values),d=ws(r.shape,l.data.get(r.dataId).values),{batchSize:h,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:$,strideWidth:w,filterHeight:v,filterWidth:k,dilationHeight:C,dilationWidth:N,outShape:A}=yl(s.shape,r.shape,i,o,"NHWC",u);O(a.rank===A.length,()=>`Error in ${im}, dy must have the same rank as output ${A.length}, but got ${a.rank}`);const I=ws(A,l.data.get(a.dataId).values),E=bI(s.shape,s.dtype);for(let P=0;P<h;++P)for(let H=0;H<g;++H){const G=H*$-b.top;for(let W=0;W<y;++W){const L=W*w-b.left;for(let B=0;B<m;++B){let Y=Number.MIN_SAFE_INTEGER,ne=G<0?0:G,M=L<0?0:L;for(let Z=0;Z<v;++Z){const J=G+Z*C;if(J>=0&&J<p)for(let oe=0;oe<k;++oe){const de=L+oe*N;if(de>=0&&de<f){const fe=c[P][J][de][B]+d[Z][oe][B];fe>Y&&(Y=fe,ne=J,M=de)}}}E[P][ne][M][B]+=I[P][H][W][B]}}}return{dataId:l.write(mi(E,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fX(t){const{inputs:e,backend:n,attrs:s}=t,{image:r}=e,{canvas:a,options:i}=s,{contextOptions:o,imageOptions:u}=i||{},l=(u==null?void 0:u.alpha)||1,c=(o==null?void 0:o.contextType)||"2d";if(c!=="2d")throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);const d=a.getContext(c,(o==null?void 0:o.contextAttributes)||{});if(d==null)throw new Error(`Could not get the context with ${c} type.`);const[h,p]=r.shape.slice(0,2),f=r.shape.length===2?1:r.shape[2],m=n.data.get(r.dataId).values,g=r.dtype==="float32"?255:1,y=new Uint8ClampedArray(p*h*4);for(let $=0;$<h*p;++$){const w=[0,0,0,255*l];for(let k=0;k<f;k++){const C=m[$*f+k];if(r.dtype==="float32"){if(C<0||C>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${C}.`)}else if(r.dtype==="int32"&&(C<0||C>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${C}.`);f===1?(w[0]=C*g,w[1]=C*g,w[2]=C*g):w[k]=C*g}const v=$*4;y[v+0]=Math.round(w[0]),y[v+1]=Math.round(w[1]),y[v+2]=Math.round(w[2]),y[v+3]=Math.round(w[3])}a.width=p,a.height=h;const b=new ImageData(y,p,h);return d.putImageData(b,0,0),r}const mX={kernelName:kz,backendName:"cpu",kernelFunc:fX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fl(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:a,keepDims:i}=s;_e(r,"sum");let o;r.dtype==="bool"?o=ha({inputs:{x:r},backend:n,attrs:{dtype:"int32"}}):o=yr({inputs:{x:r},backend:n});const u=o.shape.length,l=Ye(a,o.shape),c=At(l,u);let d=l,h=o;c!=null&&(h=zn({inputs:{x:o},backend:n,attrs:{perm:c}}),d=Pt(d.length,u)),fn("sum",d,h.shape.length);const[p,f]=an(h.shape,d),m=Hn(h.dtype,"int32");let g=sd(n,p,m);const y=se(f),b=n.data.get(g.dataId).values,$=n.data.get(h.dataId).values;for(let w=0;w<b.length;++w){const v=w*y;let k=0;for(let C=0;C<y;++C)k+=$[v+C];b[w]=k}if(i){const w=Lt(g.shape,l),v=g;g=St({inputs:{x:g},backend:n,attrs:{shape:w}}),n.disposeIntermediateTensorInfo(v)}return n.disposeIntermediateTensorInfo(o),c!=null&&n.disposeIntermediateTensorInfo(h),g}const gX={kernelName:mh,backendName:"cpu",kernelFunc:Fl};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yX(t){const{inputs:e,backend:n,attrs:s}=t,{equation:r}=s,a=e,{allDims:i,summedDims:o,idDims:u}=Ab(r,a.length);Db(i.length,u,a);const{path:l,steps:c}=Ob(o,u),d=c.length;let h=null,p=i.length;const f=[];for(let m=0;m<d;++m){for(const g of c[m]){const{permutationIndices:y,expandDims:b}=Rb(p,u[g]);let $;Fb(y)?$=a[g]:($=zn({inputs:{x:a[g]},backend:n,attrs:{perm:y}}),f.push($));const w=$.shape.slice();for(let v=0;v<b.length;++v)w.splice(b[v],0,1);tt($.shape,w)||($=St({inputs:{x:$},backend:n,attrs:{shape:w}}),f.push($)),h===null?h=$:(h=op({inputs:{a:$,b:h},backend:n}),f.push(h))}m<d-1&&(l[m]>=0&&(h=Fl({inputs:{x:h},backend:n,attrs:{axis:l[m]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(const m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}const bX={kernelName:Lg,backendName:"cpu",kernelFunc:yX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xX(t){const{inputs:e,backend:n}=t,{dy:s,y:r}=e;_e([s,r],"eluGrad");const a=new Float32Array(se(r.shape)),i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values;for(let u=0;u<i.length;++u){const l=i[u];l>=0?a[u]=o[u]:a[u]=o[u]*(l+1)}return n.makeTensorInfo(r.shape,"float32",a)}const wX={kernelName:Pg,backendName:"cpu",kernelFunc:xX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $X=Ib,vX=_b,SX=kb,IX=Cb,_X=Tb,kX=Nb,CX=pt(Fu,t=>{const e=Math.sign(t),n=Math.abs(t),s=1/(1+$X*n);return e*(1-((((kX*s+_X)*s+IX)*s+SX)*s+vX)*s*Math.exp(-n*n))}),TX={kernelName:Fu,backendName:"cpu",kernelFunc:CX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function id(t){const{inputs:e,backend:n,attrs:s}=t,{input:r}=e,{dim:a}=s,i=r.shape.length,o=r.shape.slice();let u=a;return a<0&&(O(-(i+1)<=a,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+a+1),o.splice(u,0,1),St({inputs:{x:r},backend:n,attrs:{shape:o}})}const NX={kernelName:Pd,backendName:"cpu",kernelFunc:id};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EX=Mt((t,e)=>t/e),f0=Zt(Du,EX),Km={kernelName:Du,backendName:"cpu",kernelFunc:f0};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SE(t,e,n){const s=t.shape,r=s[0],a=s[1],i=n.data.get(t.dataId),o=i.complexTensorInfos.real,u=i.complexTensorInfos.imag,l=[r,a],c=se(l),d=dn("float32",c),h=dn("float32",c);for(let g=0;g<r;g++){const y=ci({inputs:{x:o},backend:n,attrs:{begin:[g,0],size:[1,a]}}),b=ci({inputs:{x:u},backend:n,attrs:{begin:[g,0],size:[1,a]}}),$=Wn({inputs:{real:y,imag:b},backend:n}),{real:w,imag:v}=AX($,e,n),k=Rr(w,v);for(let C=0;C<a;C++){const N=Eb(k,C);d[g*a+C]=N.real,h[g*a+C]=N.imag}n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo($)}const p=n.makeTensorInfo(l,"float32",d),f=n.makeTensorInfo(l,"float32",h),m=Wn({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function AX(t,e,n){const s=se(t.shape),r=n.data.get(t.dataId),a=n.data.get(r.complexTensorInfos.real.dataId).values,i=n.data.get(r.complexTensorInfos.imag.dataId).values;if(RX(s)){const o=Xm(a,i,s,e,n),u=[t.shape[0],t.shape[1]];if(e){const l=n.makeTensorInfo(u,"float32",o.real),c=n.makeTensorInfo(u,"float32",o.imag),d=n.makeTensorInfo([],"float32",ma(s,"float32")),h=yr({inputs:{x:d},backend:n}),p=Km.kernelFunc({inputs:{a:l,b:d},backend:n}),f=Km.kernelFunc({inputs:{a:c,b:h},backend:n}),m=n.data.get(p.dataId).values,g=n.data.get(f.dataId).values;return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),{real:m,imag:g}}return o}else{const o=Rr(a,i),u=DX(o,s,e);return Dk(u)}}function RX(t){return(t&t-1)===0}function Xm(t,e,n,s,r){if(n===1)return{real:t,imag:e};const a=Rr(t,e),i=n/2,o=Ok(a),u=o.real,l=o.imag,c=[u.length],d=r.makeTensorInfo(c,"float32",u),h=r.makeTensorInfo(c,"float32",l),p=Wn({inputs:{real:d,imag:h},backend:r}),f=Fk(a),m=f.real,g=f.imag,y=[m.length],b=r.makeTensorInfo(y,"float32",m),$=r.makeTensorInfo(y,"float32",g),w=Wn({inputs:{real:b,imag:$},backend:r}),v=Xm(u,l,i,s,r),k=v.real,C=v.imag,N=[k.length],A=r.makeTensorInfo(N,"float32",k),I=r.makeTensorInfo(N,"float32",C),E=Wn({inputs:{real:A,imag:I},backend:r}),z=Xm(m,g,i,s,r),P=z.real,H=z.imag,G=[P.length],W=r.makeTensorInfo(G,"float32",P),L=r.makeTensorInfo(G,"float32",H),B=Wn({inputs:{real:W,imag:L},backend:r}),Y=Lk(n,s),ne=[Y.real.length],M=r.makeTensorInfo(ne,"float32",Y.real),Z=r.makeTensorInfo(ne,"float32",Y.imag),J=Wn({inputs:{real:M,imag:Z},backend:r}),oe=op({inputs:{a:J,b:B},backend:r}),de=Ji({inputs:{a:E,b:oe},backend:r}),fe=h0({inputs:{a:E,b:oe},backend:r}),xe=li({inputs:{input:de},backend:r}),Ne=li({inputs:{input:fe},backend:r}),$e=eo({inputs:{input:de},backend:r}),Ee=eo({inputs:{input:fe},backend:r}),ze=to({inputs:[xe,Ne],backend:r,attrs:{axis:0}}),Oe=to({inputs:[$e,Ee],backend:r,attrs:{axis:0}}),Fe=r.data.get(ze.dataId).values,Je=r.data.get(Oe.dataId).values;return r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(b),r.disposeIntermediateTensorInfo($),r.disposeIntermediateTensorInfo(w),r.disposeIntermediateTensorInfo(A),r.disposeIntermediateTensorInfo(I),r.disposeIntermediateTensorInfo(E),r.disposeIntermediateTensorInfo(W),r.disposeIntermediateTensorInfo(L),r.disposeIntermediateTensorInfo(B),r.disposeIntermediateTensorInfo(M),r.disposeIntermediateTensorInfo(Z),r.disposeIntermediateTensorInfo(J),r.disposeIntermediateTensorInfo(oe),r.disposeIntermediateTensorInfo(de),r.disposeIntermediateTensorInfo(fe),r.disposeIntermediateTensorInfo(xe),r.disposeIntermediateTensorInfo($e),r.disposeIntermediateTensorInfo(Ne),r.disposeIntermediateTensorInfo(Ee),r.disposeIntermediateTensorInfo(ze),r.disposeIntermediateTensorInfo(Oe),{real:Fe,imag:Je}}function DX(t,e,n){const s=new Float32Array(e*2);for(let r=0;r<e;r++){let a=0,i=0;for(let o=0;o<e;o++){const u=Pk(r*o,e,n),l=Eb(t,o);a+=l.real*u.real-l.imag*u.imag,i+=l.real*u.imag+l.imag*u.real}n&&(a/=e,i/=e),zk(s,a,i,r)}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OX(t){const{inputs:e,backend:n}=t,{input:s}=e,r=se(s.shape),a=s.shape[s.shape.length-1],i=r/a,o=St({inputs:{x:s},backend:n,attrs:{shape:[i,a]}}),u=SE(o,!1,n),l=St({inputs:{x:u},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),l}const FX={kernelName:Bg,backendName:"cpu",kernelFunc:OX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m0(t){const{backend:e,attrs:n}=t,{shape:s,value:r,dtype:a}=n,i=a||oo(r),o=zt(i,se(s));return LX(o,r,i),e.makeTensorInfo(s,i,o)}const zX={kernelName:Mg,backendName:"cpu",kernelFunc:m0};function LX(t,e,n){t.fill(e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PX={kernelName:Vg,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:s}=t,r=n,a=dn(s.dtype,se(s.shape)),[i,o,u,l]=s.shape,c=r.data.get(s.dataId).values;for(let h=0;h<i;h++){const p=h*u*o*l;for(let f=0;f<o;f++){const m=f*(u*l);for(let g=0;g<u;g++){const y=g*l;for(let b=0;b<l;b++){const $=Math.round(u-g-1),w=p+m+y+b;let v=c[w];if($>=0&&$<u){const k=$*l,C=p+m+k+b;v=c[C]}a[w]=v}}}}return{dataId:r.write(a,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BX(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:a,bias:i,preluActivationWeights:o}=e,{strides:u,pad:l,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=s;let m=$E({inputs:{x:r,filter:a},backend:n,attrs:{strides:u,pad:l,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){const g=m;if(c==="NCHW"&&i.shape.length===1&&i.shape[0]!==1){const y=St({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=Ji({inputs:{a:m,b:y},backend:n}),n.disposeIntermediateTensorInfo(y)}else m=Ji({inputs:{a:m,b:i},backend:n});n.disposeIntermediateTensorInfo(g)}if(p){const g=m;if(c==="NCHW"&&p==="prelu"&&o.shape.length===1&&o.shape[0]!==1){const y=St({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=ad(n,m,p,y,f),n.disposeIntermediateTensorInfo(y)}else m=ad(n,m,p,o,f);n.disposeIntermediateTensorInfo(g)}return m}const MX={kernelName:Bc,backendName:"cpu",kernelFunc:BX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VX(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:a,bias:i,preluActivationWeights:o}=e,{strides:u,pad:l,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=s;let m=vE({inputs:{x:r,filter:a},backend:n,attrs:{strides:u,pad:l,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){const g=m;m=Ji({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(g)}if(p){const g=m;m=ad(n,m,p,o,f),n.disposeIntermediateTensorInfo(g)}return m}const WX={kernelName:Mc,backendName:"cpu",kernelFunc:VX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UX(t){const{inputs:e,backend:n}=t,{params:s,indices:r}=e,a=se(s.shape),i=r.shape,o=i[i.length-1],[u,l,c,d]=pb(s,r);if(l===0)return n.makeTensorInfo(u,s.dtype,[]);const h=n.data.get(r.dataId).values,p=n.bufferSync(s),f=DN(h,p,s.dtype,l,o,c,d,s.shape,a);return n.makeTensorInfo(u,s.dtype,f.values)}const GX={kernelName:Wg,backendName:"cpu",kernelFunc:UX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HX(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,indices:a}=e,{axis:i,batchDims:o}=s;_e([r,a],"gatherV2");const u=Ye(i,r.shape)[0],l=n.data.get(a.dataId).values,c=r.shape[u];for(let w=0;w<l.length;++w){const v=l[w];O(v<=c-1&&v>=0,()=>`GatherV2: the index value ${v} is not in [0, ${c-1}]`)}let d=o;o==null&&(d=0);const h=se(a.shape),p=Lb(r,a,u,d),f=St({inputs:{x:r},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=St({inputs:{x:a},backend:n,attrs:{shape:[p.batchSize,h/p.batchSize]}}),g=[p.batchSize,p.outerSize,h/p.batchSize,p.sliceSize],y=n.bufferSync(m),b=n.bufferSync(f),$=ON(b,y,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,$.dtype,$.values)}const qX={kernelName:Md,backendName:"cpu",kernelFunc:HX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jX(t){const{inputs:e,backend:n}=t,{input:s}=e,r=se(s.shape),a=s.shape[s.shape.length-1],i=r/a,o=St({inputs:{x:s},backend:n,attrs:{shape:[i,a]}}),u=SE(o,!0,n),l=St({inputs:{x:u},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),l}const KX={kernelName:Ug,backendName:"cpu",kernelFunc:jX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XX=pt(Wu,t=>Number.isFinite(t)?1:0,"bool"),YX={kernelName:Wu,backendName:"cpu",kernelFunc:XX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZX=pt(Uu,t=>Math.abs(t)===1/0?1:0,"bool"),QX={kernelName:Uu,backendName:"cpu",kernelFunc:ZX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JX=pt(Gu,t=>Number.isNaN(t)?1:0,"bool"),e9={kernelName:Gu,backendName:"cpu",kernelFunc:JX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t9(t){const{backend:e,attrs:n}=t,{start:s,stop:r,num:a}=n,i=BN(s,r,a);return e.makeTensorInfo([i.length],"float32",i)}const n9={kernelName:Hg,backendName:"cpu",kernelFunc:t9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s9=pt(qu,t=>Math.log1p(t)),r9={kernelName:qu,backendName:"cpu",kernelFunc:s9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a9=Mt((t,e)=>t&&e),i9=Zt(Hd,a9,null,"bool"),o9={kernelName:Hd,backendName:"cpu",kernelFunc:i9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u9=pt(qd,t=>t?0:1,"bool"),l9={kernelName:qd,backendName:"cpu",kernelFunc:u9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c9=Mt((t,e)=>t||e),d9=Zt(jd,c9,null,"bool"),h9={kernelName:jd,backendName:"cpu",kernelFunc:d9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p9(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{depthRadius:a,bias:i,alpha:o,beta:u}=s;_e(r,"LRN");const l=r.shape[3],c=l-1,d=n.data.get(r.dataId).values,h=se(r.shape),p=new Float32Array(h);function f(m){const g=m%l;let y=m-g+Math.max(0,g-a);const b=m-g+Math.min(g+a,c);let $=0;for(;y<=b;y++){const w=d[y];$+=w*w}return $}for(let m=0;m<h;m++){const g=f(m),y=d[m]*Math.pow(i+o*g,-u);p[m]=y}return n.makeTensorInfo(r.shape,r.dtype,p)}const f9={kernelName:Kd,backendName:"cpu",kernelFunc:p9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m9(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,y:a,dy:i}=e,{depthRadius:o,bias:u,alpha:l,beta:c}=s;_e(i,"LRNGrad");const d=se(i.shape),h=i.shape[3],p=n.data.get(i.dataId).values,f=n.data.get(r.dataId).values,m=n.data.get(a.dataId).values,g=new Float32Array(d),y=d;for(let b=0;b<y;b++){const $=b%h,w=b-$+Math.max(0,$-o),v=b-$+Math.min(h,$+o+1);let k=0;for(let C=w;C<v;C++)k+=Math.pow(f[C],2);k=l*k+u;for(let C=w;C<v;C++){let N=-2*l*c*f[C]*m[b]/k;b===C&&(N+=Math.pow(k,-c)),N*=p[b],g[C]+=N}}return n.makeTensorInfo(i.shape,r.dtype,g)}const g9={kernelName:qg,backendName:"cpu",kernelFunc:m9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IE(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{reductionIndices:a,keepDims:i}=s,o=n;let u=r.shape;const l=u.length,c=Ye(a,u);let d=c;const h=At(d,l);let p=o.data.get(r.dataId).values;if(h!=null){const w=new Array(l);for(let v=0;v<w.length;v++)w[v]=u[h[v]];p=c0(p,u,r.dtype,h,w),d=Pt(d.length,l),u=w}_e(r,"max"),fn("max",d,l);const[f,m]=an(u,d),g=se(m),y=VN(p,g,f,r.dtype),b=o.write(y,f,r.dtype);let $=f;return i&&($=Lt(f,c)),{dataId:b,shape:$,dtype:r.dtype}}const y9={kernelName:Xd,backendName:"cpu",kernelFunc:IE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b9(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e;_e(r,"maxPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=s,l=1;O(pn(i,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);const c=_s(r.shape,a,i,l,o,u);let d;if(c.filterWidth===1&&c.filterHeight===1&&tt(c.inShape,c.outShape))d=yr({inputs:{x:r},backend:n});else{const h=n.data.get(r.dataId).values,p=Ae(r.shape),f=p0(h,r.shape,r.dtype,p,c,"max");d=n.makeTensorInfo(c.outShape,r.dtype,f.values)}return d}const x9={kernelName:Yd,backendName:"cpu",kernelFunc:b9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w9(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{filterSize:a,strides:i,pad:o,dimRoundingMode:u,dataFormat:l}=s;_e(r,"maxPool3d");const c=Or(r.shape,a,i,1,o,u,l),d=n.data.get(r.dataId).values,h=wE(d,r.shape,r.dtype,Ae(r.shape),c,"max");return n.makeTensorInfo(h.shape,"float32",h.values)}const $9={kernelName:Zd,backendName:"cpu",kernelFunc:w9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v9(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:a}=e,{filterSize:i,strides:o,pad:u,dimRoundingMode:l}=s;_e([r,a],"maxPool3DGrad");const c=Or(a.shape,i,o,1,u,l),d=n.bufferSync(a),h=c5(d,c),p=c.strideDepth,f=c.strideHeight,m=c.strideWidth,g=c.dilationDepth,y=c.dilationHeight,b=c.dilationWidth,$=c.effectiveFilterDepth,w=c.effectiveFilterHeight,v=c.effectiveFilterWidth,k=$-1-c.padInfo.front,C=v-1-c.padInfo.left,N=w-1-c.padInfo.top,A=qe(a.shape,"float32"),I=n.bufferSync(r);for(let E=0;E<c.batchSize;++E)for(let z=0;z<c.inChannels;++z)for(let P=0;P<c.inDepth;++P)for(let H=0;H<c.inHeight;++H)for(let G=0;G<c.inWidth;++G){const W=P-k,L=H-N,B=G-C;let Y=0;for(let ne=0;ne<$;ne+=g){const M=(W+ne)/p;if(!(M<0||M>=c.outDepth||Math.floor(M)!==M))for(let Z=0;Z<w;Z+=y){const J=(L+Z)/f;if(!(J<0||J>=c.outHeight||Math.floor(J)!==J))for(let oe=0;oe<v;oe+=b){const de=(B+oe)/m;if(de<0||de>=c.outWidth||Math.floor(de)!==de)continue;const fe=$*w*v-1-h.get(E,M,J,de,z),xe=ne*w*v+Z*v+oe,Ne=fe===xe?1:0;if(Ne===0)continue;const $e=I.get(E,M,J,de,z);Y+=$e*Ne}}}A.set(Y,E,P,H,G,z)}return n.makeTensorInfo(A.shape,A.dtype,A.values)}const S9={kernelName:Kg,backendName:"cpu",kernelFunc:v9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I9(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:a,output:i}=e,o=a;_e([a,i],"maxPoolGrad");const{filterSize:u,strides:l,pad:c,dimRoundingMode:d}=s,h=_s(o.shape,u,l,1,c,d),p=n.data.get(o.dataId).values,f=qe(h.outShape,o.dtype,xE(p,o.shape,o.dtype,h).values),m=h.strideHeight,g=h.strideWidth,y=h.dilationHeight,b=h.dilationWidth,$=h.effectiveFilterHeight,w=h.effectiveFilterWidth,v=w-1-h.padInfo.left,k=$-1-h.padInfo.top,C=qe(o.shape,"float32"),N=n.data.get(r.dataId).values,A=qe(r.shape,"float32",N);for(let I=0;I<h.batchSize;++I)for(let E=0;E<h.inChannels;++E)for(let z=0;z<h.inHeight;++z)for(let P=0;P<h.inWidth;++P){const H=z-k,G=P-v;let W=0;for(let L=0;L<$;L+=y){const B=(H+L)/m;if(!(B<0||B>=h.outHeight||Math.floor(B)!==B))for(let Y=0;Y<w;Y+=b){const ne=(G+Y)/g;if(ne<0||ne>=h.outWidth||Math.floor(ne)!==ne)continue;const M=$*w-1-f.get(I,B,ne,E),Z=L*w+Y,J=M===Z?1:0;if(J===0)continue;const oe=A.get(I,B,ne,E);W+=oe*J}}C.set(W,I,z,P,E)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}const _9={kernelName:jg,backendName:"cpu",kernelFunc:I9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k9(t,e,n,s,r){const a=Ae(e),i=p0(t,e,n,a,r,"max"),o=xE(t,e,n,r,!0,s);return[i.values,o.values]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C9={kernelName:Xg,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:s}=t,{filterSize:r,strides:a,pad:i,includeBatchInIndex:o}=e,u=n;_e(s,"MaxPoolWithArgmax");const l=u.data.get(s.dataId).values,c=_s(s.shape,r,a,[1,1],i),[d,h]=k9(l,s.shape,s.dtype,o,c),p=u.write(d,c.outShape,s.dtype),f=u.write(h,c.outShape,s.dtype);return[{dataId:p,shape:c.outShape,dtype:s.dtype},{dataId:f,shape:c.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T9(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:a,keepDims:i}=s,o=Ye(a,r.shape),l=an(r.shape,o)[1],c=se(l),d=[],h=n.makeTensorInfo([],"float32",new Float32Array([c]));d.push(h);const p=ha({inputs:{x:r},backend:n,attrs:{dtype:"float32"}});d.push(p);const f=f0({inputs:{a:p,b:h},backend:n});d.push(f);const m=Fl({inputs:{x:f},backend:n,attrs:{axis:a,keepDims:i}});return d.forEach(g=>n.disposeIntermediateTensorInfo(g)),m}const N9={kernelName:Qd,backendName:"cpu",kernelFunc:T9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E9(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:a,keepDims:i}=s;_e(r,"min");const o=Ye(a,r.shape);let u=o;const l=At(u,r.shape.length);let c=r;l!=null&&(c=zn({inputs:{x:r},backend:n,attrs:{perm:l}}),u=Pt(u.length,r.shape.length)),fn("min",u,c.shape.length);const[d,h]=an(c.shape,u),p=se(h),f=xn(se(d),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const b=y*p;let $=m[b];for(let w=0;w<p;++w){const v=m[b+w];(Number.isNaN(v)||v<$)&&($=v)}f[y]=$}l!=null&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,f);if(i){const y=Lt(d,o),b=St({inputs:{x:g},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(g),b}return g}const A9={kernelName:Jd,backendName:"cpu",kernelFunc:E9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R9(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{paddings:a,mode:i}=s;_e(r,"mirrorPad");const o=a.map(($,w)=>$[0]+r.shape[w]+$[1]),u=a.map($=>$[0]),l=a.map(($,w)=>$[0]+r.shape[w]),c=i==="reflect"?0:1,d=n.data.get(r.dataId).values,h=r.shape.length,p=Ae(r.shape),f=se(o),m=o.length,g=Ae(o),y=dn(r.dtype,f);for(let $=0;$<f;$++){let w=uo($,m,g);for(let k=0;k<m;k++)w[k]<u[k]?w[k]=u[k]*2-w[k]-c:w[k]>=l[k]&&(w[k]=(l[k]-1)*2-w[k]+c);w=w.map((k,C)=>k-u[C]);const v=cr(w,h,p);y[$]=d[v]}return{dataId:n.write(y,o,r.dtype),shape:o,dtype:r.dtype}}const D9={kernelName:eh,backendName:"cpu",kernelFunc:R9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O9=Mt((t,e)=>{const n=t%e;return t<0&&e<0||t>=0&&e>=0?n:(n+e)%e}),F9=Zt(Xu,O9),z9={kernelName:Xu,backendName:"cpu",kernelFunc:F9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _E(t){const{inputs:e,backend:n,attrs:s}=t,{logits:r}=e,{dim:a}=s,i=r.shape.length;let o=a;if(o===-1&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);const u=Ye([o],r.shape),l=IE({inputs:{x:r},backend:n,attrs:{reductionIndices:u,keepDims:!1}}),c=Lt(l.shape,u),d=St({inputs:{x:l},backend:n,attrs:{shape:c}}),h=h0({inputs:{a:r,b:d},backend:n}),p=NN({inputs:{x:h},backend:n}),f=Fl({inputs:{x:p},backend:n,attrs:{axis:u,keepDims:!1}}),m=St({inputs:{x:f},backend:n,attrs:{shape:c}}),g=f0({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const L9={kernelName:bh,backendName:"cpu",kernelFunc:_E};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P9(t){const{inputs:e,backend:n,attrs:s}=t,{logits:r}=e,{numSamples:a,seed:i,normalized:o}=s;_e(r,"multinomial");const u=o?r:_E({inputs:{logits:r},backend:n,attrs:{dim:-1}}),l=u.shape[0],c=u.shape[1],d=n.data.get(u.dataId).values,h=[l,a],p=xn(se(h),"int32");for(let f=0;f<l;++f){const m=f*c,g=new Float32Array(c-1);g[0]=d[m];for(let $=1;$<g.length;++$)g[$]=g[$-1]+d[m+$];const y=zh.alea(i.toString()),b=f*a;for(let $=0;$<a;++$){const w=y();p[b+$]=g.length;for(let v=0;v<g.length;v++)if(w<g[v]){p[b+$]=v;break}}}return o||n.disposeIntermediateTensorInfo(u),n.makeTensorInfo(h,"int32",p)}const B9={kernelName:Yg,backendName:"cpu",kernelFunc:P9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M9=ib;function V9(t){const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:a}=e,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u}=s;_e(r,"NonMaxSuppression");const l=n.data.get(r.dataId).values,c=n.data.get(a.dataId).values,{selectedIndices:d}=M9(l,c,i,o,u);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}const W9={kernelName:Zg,backendName:"cpu",kernelFunc:V9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U9=ob;function G9(t){const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:a}=e,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,padToMaxOutputSize:l}=s;_e(r,"NonMaxSuppressionPadded");const c=n.data.get(r.dataId).values,d=n.data.get(a.dataId).values,{selectedIndices:h,validOutputs:p}=U9(c,d,i,o,u,l);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}const H9={kernelName:Qg,backendName:"cpu",kernelFunc:G9};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q9=ub;function j9(t){const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:a}=e,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,softNmsSigma:l}=s;_e(r,"NonMaxSuppressionWithScore");const c=n.data.get(r.dataId).values,d=n.data.get(a.dataId).values,h=i,p=o,f=u,m=l,{selectedIndices:g,selectedScores:y}=q9(c,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}const K9={kernelName:Jg,backendName:"cpu",kernelFunc:j9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X9(t){const{inputs:e,backend:n,attrs:s}=t,{indices:r}=e,{dtype:a,depth:i,onValue:o,offValue:u}=s;_e(r,"oneHot");const l=se(r.shape),c=new Float32Array(l*i);c.fill(u);const d=n.data.get(r.dataId).values;for(let h=0;h<l;++h)d[h]>=0&&d[h]<i&&(c[h*i+d[h]]=o);return n.makeTensorInfo([...r.shape,i],a,c)}const Y9={kernelName:rh,backendName:"cpu",kernelFunc:X9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function od(t){const{inputs:e,backend:n}=t,{x:s}=e;if(s.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(s.dtype==="complex64"){const r=li({inputs:{input:s},backend:n}),a=od({inputs:{x:r},backend:n}),i=eo({inputs:{input:s},backend:n}),o=od({inputs:{x:i},backend:n}),u=Wn({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),u}else return m0({backend:n,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const Z9={kernelName:vh,backendName:"cpu",kernelFunc:od};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kE(t){const{inputs:e,backend:n}=t,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(s.dtype==="complex64"){const r=li({inputs:{input:s},backend:n}),a=kE({inputs:{x:r},backend:n}),i=eo({inputs:{input:s},backend:n}),o=od({inputs:{x:i},backend:n}),u=Wn({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),u}else return m0({backend:n,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}const Q9={kernelName:sh,backendName:"cpu",kernelFunc:kE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CE(t){const{inputs:e,backend:n,attrs:s}=t,{axis:r}=s;if(e.length===1)return id({inputs:{input:e[0]},backend:n,attrs:{dim:r}});const a=e[0].shape,i=e[0].dtype;e.forEach(c=>{Zn(a,c.shape,"All tensors passed to stack must have matching shapes"),O(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],u=e.map(c=>{const d=id({inputs:{input:c},backend:n,attrs:{dim:r}});return o.push(d),d}),l=to({inputs:u,backend:n,attrs:{axis:r}});return o.forEach(c=>n.disposeIntermediateTensorInfo(c)),l}const J9={kernelName:ah,backendName:"cpu",kernelFunc:CE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e7(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{paddings:a,constantValue:i}=s;_e(r,"pad");const o=a.map((b,$)=>b[0]+r.shape[$]+b[1]),u=a.map(b=>b[0]),l=n.data.get(r.dataId).values,c=se(r.shape),d=r.shape.length,h=Ae(r.shape),p=se(o),f=o.length,m=Ae(o),g=dn(r.dtype,p);i!==0&&g.fill(i);for(let b=0;b<c;b++){const w=uo(b,d,h).map((k,C)=>k+u[C]),v=cr(w,f,m);g[v]=l[b]}return{dataId:n.write(g,o,r.dtype),shape:o,dtype:r.dtype}}const TE={kernelName:ih,backendName:"cpu",kernelFunc:e7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t7=Mt((t,e)=>Math.pow(t,e)),n7=Zt(Zu,t7),s7={kernelName:Zu,backendName:"cpu",kernelFunc:n7};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r7(t){const{inputs:e,backend:n,attrs:s}=t,{paramsNestedSplits:r,paramsDenseValues:a,indices:i}=e,{outputRaggedRank:o}=s,u=r.map(y=>n.data.get(y.dataId).values),l=r.map(y=>y.shape),c=n.data.get(a.dataId).values,d=n.data.get(i.dataId).values,[h,p,f]=jN(u,l,c,a.shape,a.dtype,d,i.shape),m=h.map(y=>n.makeTensorInfo([y.length],"int32",y)),g=n.makeTensorInfo(f,a.dtype,p);return m.concat([g])}const a7={kernelName:ey,backendName:"cpu",kernelFunc:r7};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i7(t){const{inputs:e,backend:n}=t,{starts:s,limits:r,deltas:a}=e,i=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values,u=n.data.get(a.dataId).values,[l,c]=KN(i,s.shape,s.dtype,o,r.shape,u,a.shape),d=n.makeTensorInfo([l.length],"int32",l),h=n.makeTensorInfo([c.length],s.dtype,c);return[d,h]}const o7={kernelName:ty,backendName:"cpu",kernelFunc:i7};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u7(t){const{inputs:e,backend:n,attrs:s}=t,{shape:r,values:a,defaultValue:i,rowPartitionTensors:o}=e,{rowPartitionTypes:u}=s,l=n.data.get(r.dataId).values,c=n.data.get(a.dataId).values,d=n.data.get(i.dataId).values,h=o.map(g=>n.data.get(g.dataId).values),p=o.map(g=>g.shape),[f,m]=XN(l,r.shape,c,a.shape,a.dtype,d,i.shape,h,p,u);return n.makeTensorInfo(f,a.dtype,m)}const l7={kernelName:ny,backendName:"cpu",kernelFunc:u7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c7(t){const{backend:e,attrs:n}=t,{start:s,stop:r,dtype:a,step:i}=n,o=YN(s,r,i,a);return e.makeTensorInfo([o.length],a,o)}const d7={kernelName:sy,backendName:"cpu",kernelFunc:c7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h7=pt(Qu,t=>1/t),p7={kernelName:Qu,backendName:"cpu",kernelFunc:h7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f7(t){const{inputs:e,backend:n,attrs:s}=t,{images:r}=e,{alignCorners:a,halfPixelCenters:i,size:o}=s;_e(r,"resizeBilinear");const u=Ae(r.shape),[l,c]=o,[d,h,p,f]=r.shape,m=n.data.get(r.dataId).values,g=new Float32Array(se([d,l,c,f])),y=[a&&l>1?h-1:h,a&&c>1?p-1:p],b=[a&&l>1?l-1:l,a&&c>1?c-1:c];let $=0;const w=y[0]/b[0],v=y[1]/b[1];for(let k=0;k<d;k++)for(let C=0;C<l;C++){let N;i?N=w*(C+.5)-.5:N=w*C;const A=Math.max(0,Math.floor(N)),I=N-A,E=Math.min(h-1,Math.ceil(N)),z=k*u[0]+A*u[1],P=k*u[0]+E*u[1];for(let H=0;H<c;H++){let G;i?G=v*(H+.5)-.5:G=v*H;const W=Math.max(0,Math.floor(G)),L=G-W,B=Math.min(p-1,Math.ceil(G)),Y=z+W*u[2],ne=P+W*u[2],M=z+B*u[2],Z=P+B*u[2];for(let J=0;J<f;J++){const oe=m[Y+J],de=m[ne+J],fe=m[M+J],xe=m[Z+J],Ne=oe+(fe-oe)*L,$e=de+(xe-de)*L,Ee=Ne+($e-Ne)*I;g[$++]=Ee}}}return n.makeTensorInfo([d,l,c,f],"float32",g)}const m7={kernelName:dh,backendName:"cpu",kernelFunc:f7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g7(t){const{inputs:e,backend:n,attrs:s}=t,{images:r,dy:a}=e,{alignCorners:i}=s;_e([a,r],"resizeBilinearGrad");const o=Ae(r.shape),[u,l,c,d]=r.shape,[,h,p]=a.shape,f=new Float32Array(u*l*c*d),m=[i&&h>1?l-1:l,i&&p>1?c-1:c],g=[i&&h>1?h-1:h,i&&p>1?p-1:p],y=m[0]/g[0],b=m[1]/g[1],$=n.data.get(a.dataId).values;let w=0;for(let v=0;v<u;v++){const k=v*o[0];for(let C=0;C<h;C++){const N=C*y,A=Math.floor(N),I=Math.min(Math.ceil(N),l-1),E=k+A*o[1],z=k+I*o[1],P=N-A,H=1-P;for(let G=0;G<p;G++){const W=G*b,L=Math.floor(W),B=Math.min(Math.ceil(W),c-1),Y=W-L,ne=1-Y,M=E+L*o[2],Z=E+B*o[2],J=z+L*o[2],oe=z+B*o[2],de=H*ne,fe=H*Y,xe=P*ne,Ne=P*Y;for(let $e=0;$e<d;$e++){const Ee=$[w++];f[M+$e]+=Ee*de,f[Z+$e]+=Ee*fe,f[J+$e]+=Ee*xe,f[oe+$e]+=Ee*Ne}}}}return n.makeTensorInfo([u,c,l,d],"float32",f)}const y7={kernelName:iy,backendName:"cpu",kernelFunc:g7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b7(t){const{inputs:e,backend:n,attrs:s}=t,{images:r}=e,{alignCorners:a,halfPixelCenters:i,size:o}=s;_e(r,"resizeNearestNeighbor");const u=Ae(r.shape),[l,c]=o,[d,h,p,f]=r.shape,m=n.data.get(r.dataId).values,g=new Float32Array(d*l*c*f),y=[a&&l>1?h-1:h,a&&c>1?p-1:p],b=[a&&l>1?l-1:l,a&&c>1?c-1:c],$=y[0]/b[0],w=y[1]/b[1];let v=0;for(let k=0;k<d;k++){const C=k*u[0];for(let N=0;N<l;N++){const A=i?$*(N+.5):$*N;let I=Math.min(h-1,a?Math.round(A):Math.floor(A));i&&(I=Math.max(0,I));const E=C+I*u[1];for(let z=0;z<c;z++){const P=i?w*(z+.5):w*z;let H=Math.min(p-1,a?Math.round(P):Math.floor(P));i&&(H=Math.max(0,H));const G=E+H*u[2];for(let W=0;W<f;W++){const L=m[G+W];g[v++]=L}}}}return n.makeTensorInfo([d,l,c,f],r.dtype,g)}const x7={kernelName:ch,backendName:"cpu",kernelFunc:b7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w7(t){const{inputs:e,backend:n,attrs:s}=t,{images:r,dy:a}=e,{alignCorners:i}=s;_e([a,r],"resizeNearestNeighborGrad");const o=Ae(r.shape),u=Ae(a.shape),[l,c,d,h]=r.shape,[,p,f]=a.shape,m=new Float32Array(l*c*d*h),g=n.data.get(a.dataId).values,y=[i&&p>1?c-1:c,i&&f>1?d-1:d],b=[i&&p>1?p-1:p,i&&f>1?f-1:f],$=y[0]/b[0],w=y[1]/b[1],v=1/$,k=1/w,C=Math.ceil(v)*2+2,N=Math.ceil(k)*2+2;for(let A=0;A<l;A++){const I=A*o[0];for(let E=0;E<c;E++){const z=I+E*o[1],P=Math.floor(E*v),H=Math.floor(P-C/2);for(let G=0;G<d;G++){const W=z+G*o[2],L=Math.floor(G*k),B=Math.floor(L-N/2);for(let Y=0;Y<h;Y++){let ne=0;for(let M=0;M<C;M++){const Z=M+H;if(Z<0||Z>=p)continue;const J=I+Z*u[1],oe=Z*$,de=Math.min(c-1,i?Math.round(oe):Math.floor(oe));if(E===de)for(let fe=0;fe<N;fe++){const xe=fe+B;if(xe<0||xe>=f)continue;const Ne=J+xe*u[2],$e=xe*w,Ee=Math.min(d-1,i?Math.round($e):Math.floor($e));G===Ee&&(ne+=g[Ne+Y])}}m[W+Y]=ne}}}}return n.makeTensorInfo(r.shape,r.dtype,m)}const $7={kernelName:ay,backendName:"cpu",kernelFunc:w7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v7(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{dims:a}=s;_e(r,"reverse");const i=r.shape.length,o=Ye(a,r.shape);if(i===0)return yr({inputs:{x:r},backend:n});const u=new jt(r.shape,r.dtype),l=n.bufferSync(r);for(let c=0;c<u.size;c++){const d=u.indexToLoc(c),h=d.slice();o.forEach(p=>h[p]=r.shape[p]-1-h[p]),u.set(l.get(...h),...d)}return n.makeTensorInfo(u.shape,u.dtype,u.values)}const S7={kernelName:hh,backendName:"cpu",kernelFunc:v7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I7={kernelName:Sy,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:s}=t,{radians:r,fillValue:a,center:i}=e,o=n,u=dn(s.dtype,se(s.shape)),[l,c,d,h]=s.shape,[p,f]=$b(i,c,d),m=255,g=Math.sin(r),y=Math.cos(r),b=o.data.get(s.dataId).values;for(let w=0;w<l;w++){const v=w*d*c*h;for(let k=0;k<c;k++){const C=k*(d*h);for(let N=0;N<d;N++){const A=N*h;for(let I=0;I<h;I++){const E=[l,k,N,I],z=E[2],P=E[1];let H=(z-p)*y-(P-f)*g,G=(z-p)*g+(P-f)*y;H=Math.round(H+p),G=Math.round(G+f);let W=a;if(typeof a!="number"&&(I===3?W=m:W=a[I]),H>=0&&H<d&&G>=0&&G<c){const B=G*(d*h),Y=H*h,ne=v+B+Y+I;W=b[ne]}const L=v+C+A+I;u[L]=W}}}}return{dataId:o.write(u,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _7=pt(tl,t=>{const e=Math.floor(t);return t-e<.5?Math.floor(t):t-e>.5?Math.ceil(t):e%2===0?e:e+1}),k7={kernelName:tl,backendName:"cpu",kernelFunc:_7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C7(t){const{inputs:e,backend:n,attrs:s}=t,{indices:r,updates:a}=e,{shape:i}=s,{sliceRank:o,numUpdates:u,sliceSize:l,strides:c,outputSize:d}=xi(a,r,i),h=!0,p=n.bufferSync(r),f=n.bufferSync(a),m=qa(p,f,i,d,l,u,o,c,0,h);return n.makeTensorInfo(i,m.dtype,m.values)}const T7={kernelName:oy,backendName:"cpu",kernelFunc:C7};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N7(t,e){let n=0,s=t.length,r=0;for(;n<s;)r=Math.floor((n+s)/2),t[r]<e?n=r+1:s=r;return s}function E7(t,e){let n=0,s=t.length,r=0;for(;n<s;)r=Math.floor((n+s)/2),t[r]<=e?n=r+1:s=r;return s}function A7(t,e,n,s,r,a){const i=zt("int32",n*r);for(let o=0;o<n;++o){const u=t.slice(o*s,(o+1)*s),l=o*r;for(let c=0;c<r;++c)i[l+c]=a==="left"?N7(u,e[c+l]):E7(u,e[c+l])}return i}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R7(t){const{inputs:e,backend:n,attrs:s}=t,{sortedSequence:r,values:a}=e,{side:i}=s,o=n.data.get(r.dataId).values,u=n.data.get(a.dataId).values,l=A7(o,u,r.shape[0],r.shape[1],a.shape[1],i);return n.makeTensorInfo(a.shape,"int32",l)}const D7={kernelName:ly,backendName:"cpu",kernelFunc:R7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O7(t){const{inputs:e,backend:n}=t,{condition:s,t:r,e:a}=e;_e([s,r,a],"select");const i=s.shape.length,o=n.data.get(s.dataId).values,u=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,c=Hn(r.dtype,a.dtype),d=xn(se(r.shape),c);let h=0;const p=i===0||i>1||r.shape.length===1?1:se(r.shape.slice(1));for(let f=0;f<o.length;f++)for(let m=0;m<p;m++)o[f]===1?d[h++]=u[f]:d[h++]=l[f];return n.makeTensorInfo(r.shape,c,d)}const F7={kernelName:ph,backendName:"cpu",kernelFunc:O7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z7=Kh,L7=Xh,P7=pt(sl,t=>t>=0?L7*t:z7*(Math.exp(t)-1)),B7={kernelName:sl,backendName:"cpu",kernelFunc:P7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M7=pt(il,t=>t<0?-1:t>0?1:0),V7={kernelName:il,backendName:"cpu",kernelFunc:M7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W7=pt(rl,t=>Math.sin(t)),U7={kernelName:rl,backendName:"cpu",kernelFunc:W7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G7=pt(al,t=>Math.sinh(t)),H7={kernelName:al,backendName:"cpu",kernelFunc:G7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q7=11920928955078125e-23,a$=Math.log(q7)+2,j7=pt(ul,t=>{const e=t>-a$,n=t<a$,s=Math.exp(t);let r;return n?r=s:e?r=t:r=Math.log(1+s),r}),K7={kernelName:ul,backendName:"cpu",kernelFunc:j7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X7(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockShape:a,paddings:i}=s;_e([r],"spaceToBatchND");const o=se(a),u=[[0,0]];u.push(...i);for(let k=1+a.length;k<r.shape.length;++k)u.push([0,0]);const l=TE.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:u,constantValue:0}}),c=Il(l.shape,a,o,!1),d=_l(c.length,a.length,!1),h=kl(l.shape,a,o,!1),m=St({inputs:{x:l},backend:n,attrs:{shape:c}}),b=zn({inputs:{x:m},backend:n,attrs:{perm:d}}),v=St({inputs:{x:b},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(b),v}const Y7={kernelName:gh,backendName:"cpu",kernelFunc:X7};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z7(t){const{inputs:e,backend:n}=t,{indices:s,values:r,denseShape:a,defaultValue:i}=e;if(a.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${a.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${r.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);const o=n.data.get(s.dataId).values,u=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,c=n.data.get(i.dataId).values[0],[d,h,p,f,m]=eE(o,s.shape,s.dtype,u,r.dtype,l,c);return[n.makeTensorInfo(h,s.dtype,d),n.makeTensorInfo([h[0]],r.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),n.makeTensorInfo([m.length],s.dtype,new Int32Array(m))]}const Q7={kernelName:cy,backendName:"cpu",kernelFunc:Z7};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J7(t){const{inputs:e,backend:n}=t,{inputIndices:s,inputShape:r,newShape:a}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(n.data.get(r.dataId).values),o=n.data.get(s.dataId).values,u=Array.from(n.data.get(a.dataId).values),[l,c,d]=tE(o,s.shape,s.dtype,i,u);return[n.makeTensorInfo(c,s.dtype,l),n.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}const eY={kernelName:dy,backendName:"cpu",kernelFunc:J7};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tY(t){const{inputs:e,backend:n}=t,{data:s,indices:r,segmentIds:a}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${r.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${a.shape}`);if(r.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values,u=n.data.get(a.dataId).values,[l,c]=d0(i,s.shape,s.dtype,o,u,!0);return n.makeTensorInfo(c,s.dtype,l)}const nY={kernelName:hy,backendName:"cpu",kernelFunc:tY};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sY(t){const{inputs:e,backend:n}=t,{data:s,indices:r,segmentIds:a}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${r.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${a.shape}`);if(r.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values,u=n.data.get(a.dataId).values,[l,c]=d0(i,s.shape,s.dtype,o,u);return n.makeTensorInfo(c,s.dtype,l)}const rY={kernelName:py,backendName:"cpu",kernelFunc:sY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aY(t){const{inputs:e,backend:n,attrs:s}=t,{sparseIndices:r,sparseValues:a,defaultValue:i}=e,{outputShape:o}=s,{sliceRank:u,numUpdates:l,sliceSize:c,strides:d,outputSize:h}=xi(a,r,o),p=!1,f=n.bufferSync(r);let m;switch(a.dtype){case"bool":{const g=n.bufferSync(a),y=!!n.data.get(i.dataId).values[0];m=qa(f,g,o,h,c,l,u,d,y,p);break}case"float32":{const g=n.bufferSync(a),y=n.data.get(i.dataId).values[0];m=qa(f,g,o,h,c,l,u,d,y,p);break}case"int32":{const g=n.bufferSync(a),y=n.data.get(i.dataId).values[0];m=qa(f,g,o,h,c,l,u,d,y,p);break}case"string":{const g=n.bufferSync(a),y=sa(n.data.get(i.dataId).values[0]);m=qa(f,g,o,h,c,l,u,d,y,p);break}default:throw new Error(`Unsupported type ${a.dtype}`)}return n.makeTensorInfo(o,m.dtype,m.values)}const iY={kernelName:fy,backendName:"cpu",kernelFunc:aY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oY(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{numOrSizeSplits:a,axis:i}=s,o=Ye(i,r.shape)[0],u=zb(r,a,o),l=new Array(r.shape.length).fill(0),c=r.shape.slice();return u.map(d=>{const h=[...c];h[o]=d;const p=ci({inputs:{x:r},backend:n,attrs:{begin:l,size:h}});return l[o]+=d,p})}const uY={kernelName:yh,backendName:"cpu",kernelFunc:oY};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lY={kernelName:my,backendName:"cpu",kernelFunc:({inputs:t,backend:e})=>{const{x:n}=t,s=e;_e(n,"square");const r=s.data.get(n.dataId).values,a=new Float32Array(r.length);for(let o=0;o<r.length;++o){const u=r[o];a[o]=u*u}return{dataId:s.write(a,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cY=pt(ml,(t,e)=>{const n=e;return isNaN(t)?NaN:t>0?1:n.alpha}),dY={kernelName:ml,backendName:"cpu",kernelFunc:cY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hY(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{begin:a,end:i,strides:o,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=s;_e(r,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:$,strides:w}=bb(r.shape,a,i,o,u,l,c,d,h);let v;if(m)v=St({inputs:{x:r},backend:n,attrs:{shape:f}});else if(g||y){O(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const k=mb(b,$,w),C=ci({inputs:{x:r},backend:n,attrs:{begin:b,size:k}});v=St({inputs:{x:C},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(C)}else{const k=n.bufferSync(r),C=rE(p,k,w,b);v=n.makeTensorInfo(f,C.dtype,C.values)}return v}const pY={kernelName:gy,backendName:"cpu",kernelFunc:hY};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fY(t){const{inputs:e,backend:n,attrs:s}=t,{separator:r,nGramWidths:a,leftPad:i,rightPad:o,padWidth:u,preserveShortSequences:l}=s,{data:c,dataSplits:d}=e,h=n.data.get(c.dataId).values,p=n.data.get(d.dataId).values,[f,m]=aE(h,p,r,a,i,o,u,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}const mY={kernelName:yy,backendName:"cpu",kernelFunc:fY};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gY(t){const{inputs:e,backend:n,attrs:s}=t,{skipEmpty:r}=s,{input:a,delimiter:i}=e;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(a.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.data.get(a.dataId).values,u=n.data.get(i.dataId).values[0],[l,c,d]=iE(o,u,r),h=c.length;return[n.makeTensorInfo([h,2],"int32",l),n.makeTensorInfo([h],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}const yY={kernelName:by,backendName:"cpu",kernelFunc:gY};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bY(t){const{inputs:e,backend:n,attrs:s}=t,{numBuckets:r}=s,{input:a}=e;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const i=n.data.get(a.dataId).values,o=oE(i,r);return n.makeTensorInfo(a.shape,"int32",o)}const xY={kernelName:xy,backendName:"cpu",kernelFunc:bY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wY=pt(hl,t=>Math.tan(t)),$Y={kernelName:hl,backendName:"cpu",kernelFunc:wY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vY=pt(pl,t=>Math.tanh(t)),SY={kernelName:pl,backendName:"cpu",kernelFunc:vY};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IY(t){const{inputs:e,backend:n}=t,{tensor:s,indices:r,updates:a}=e,{sliceRank:i,numUpdates:o,sliceSize:u,strides:l,outputSize:c}=xi(a,r,s.shape),d=!1,h=n.bufferSync(r),p=n.bufferSync(a),f=n.bufferSync(s),m=qa(h,p,s.shape,c,u,o,i,l,f,d);return n.makeTensorInfo(s.shape,m.dtype,m.values)}const _Y={kernelName:uy,backendName:"cpu",kernelFunc:IY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kY(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{reps:a}=s;_e(r,"tile");const i=lE(n.bufferSync(r),a);return n.makeTensorInfo(i.shape,i.dtype,i.values)}const CY={kernelName:fl,backendName:"cpu",kernelFunc:kY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TY(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{k:a,sorted:i}=s;_e(r,"topk");const o=n.data.get(r.dataId).values,[u,l]=dE(o,r.shape,r.dtype,a,i);return[n.makeTensorInfo(u.shape,u.dtype,u.values),n.makeTensorInfo(l.shape,l.dtype,l.values)]}const NY={kernelName:wy,backendName:"cpu",kernelFunc:TY};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EY(t){const{inputs:e,attrs:n,backend:s}=t,{image:r,transforms:a}=e,{interpolation:i,fillMode:o,fillValue:u,outputShape:l}=n,[c,d,h,p]=r.shape,[f,m]=l??[d,h],g=[c,f,m,p],y=Ae(r.shape),b=y[0],$=y[1],w=y[2],v=Ae(g),k=v[0],C=v[1],N=v[2],A=dn(r.dtype,se(g));A.fill(u);const I=s.data.get(r.dataId).values,E=s.data.get(a.dataId).values;for(let P=0;P<c;++P){const H=a.shape[0]===1?E:E.subarray(P*8,P*8+8);for(let G=0;G<f;++G)for(let W=0;W<m;++W)for(let L=0;L<p;++L){let B;const Y=H[6]*W+H[7]*G+1;if(Y===0)continue;const ne=(H[0]*W+H[1]*G+H[2])/Y,M=(H[3]*W+H[4]*G+H[5])/Y,Z=i$(ne,h,o),J=i$(M,d,o);switch(i){case"nearest":B=zY(I,d,h,b,$,w,P,J,Z,L,u);break;case"bilinear":B=LY(I,d,h,b,$,w,P,J,Z,L,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}const oe=P*k+G*C+W*N+L;A[oe]=B}return s.makeTensorInfo(g,r.dtype,A)}return{dataId:s.write(A,g,r.dtype),shape:r.shape,dtype:r.dtype}}const AY={kernelName:$y,backendName:"cpu",kernelFunc:EY};function i$(t,e,n){switch(n){case"reflect":return RY(t,e);case"wrap":return DY(t,e);case"nearest":return FY(t,e);case"constant":default:return OY(t)}}function RY(t,e){let n=t;if(n<0)if(e<=1)n=0;else{const s=2*e;n<s&&(n=s*Math.trunc(-n/s)+n),n=n<-e?n+s:-n-1}else if(n>e-1)if(e<=1)n=0;else{const s=2*e;n-=s*Math.trunc(n/s),n>=e&&(n=s-n-1)}return Za(0,n,e-1)}function DY(t,e){let n=t;if(n<0)if(e<=1)n=0;else{const s=e-1;n+=e*(Math.trunc(-n/s)+1)}else if(n>e-1)if(e<=1)n=0;else{const s=e-1;n-=e*Math.trunc(n/s)}return Za(0,n,e-1)}function OY(t,e){return t}function FY(t,e){return Za(0,t,e-1)}function Ko(t,e,n,s,r,a,i,o,u,l,c){const d=i*s+o*r+u*a+l;return 0<=o&&o<e&&0<=u&&u<n?t[d]:c}function zY(t,e,n,s,r,a,i,o,u,l,c){const d=Math.round(o),h=Math.round(u);return Ko(t,e,n,s,r,a,i,d,h,l,c)}function LY(t,e,n,s,r,a,i,o,u,l,c){const d=Math.floor(o),h=Math.floor(u),p=d+1,f=h+1,m=(f-u)*Ko(t,e,n,s,r,a,i,d,h,l,c)+(u-h)*Ko(t,e,n,s,r,a,i,d,f,l,c),g=(f-u)*Ko(t,e,n,s,r,a,i,p,h,l,c)+(u-h)*Ko(t,e,n,s,r,a,i,p,f,l,c);return(p-o)*m+(o-d)*g}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PY(t){const{inputs:e,attrs:n,backend:s}=t,{axis:r}=n,{x:a}=e;_e(a,"unique");const i=s.data.get(a.dataId).values,{outputValues:o,outputShape:u,indices:l}=hE(i,r,a.shape,a.dtype);return[s.makeTensorInfo(u,a.dtype,o),s.makeTensorInfo([l.length],"int32",l)]}const BY={kernelName:vy,backendName:"cpu",kernelFunc:PY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MY(t){const{inputs:e,backend:n,attrs:s}=t,{value:r}=e;let{axis:a}=s;a<0&&(a+=r.shape.length);const i=r.shape.length,o=r.shape[a],u=new Array(i-1);let l=0;for(let p=0;p<i;p++)p!==a&&(u[l++]=r.shape[p]);const c=new Array(i).fill(0),d=r.shape.slice();d[a]=1;const h=new Array(o);for(let p=0;p<h.length;p++){c[a]=p;const f=ci({inputs:{x:r},backend:n,attrs:{begin:c,size:d}});h[p]=St({inputs:{x:f},backend:n,attrs:{shape:u}}),n.disposeIntermediateTensorInfo(f)}return h}const VY={kernelName:wh,backendName:"cpu",kernelFunc:MY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WY(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,segmentIds:a}=e,{numSegments:i}=s;_e(r,"unsortedSegmentSum");const o=r.shape.length,u=a.shape.length,l=[],c=[],d=o-u;let h=a;for(let f=0;f<d;++f){const m=id({inputs:{input:h},backend:n,attrs:{dim:f+1}});h=m,c.push(m)}for(let f=0;f<i;++f){const m=ma(f,"int32"),g=n.makeTensorInfo([],"int32",m),y=CN({inputs:{a:g,b:h},backend:n}),b=ha({inputs:{x:y},backend:n,attrs:{dtype:"float32"}}),$=op({inputs:{a:b,b:r},backend:n}),w=Fl({inputs:{x:$},backend:n,attrs:{axis:0,keepDims:!1}});l.push(w),c.push(g),c.push(y),c.push(b),c.push($),c.push(w)}const p=CE({inputs:l,backend:n,attrs:{axis:0}});return c.forEach(f=>n.disposeIntermediateTensorInfo(f)),p}const UY={kernelName:$h,backendName:"cpu",kernelFunc:WY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GY=[P8,bK,M8,W8,IK,G8,q8,K8,Y8,Q8,e5,n5,r5,o5,l5,h5,f5,g5,b5,z8,w5,v5,I5,kK,k5,vK,TK,T5,xK,E5,R5,D5,F5,L5,B5,V5,U5,H5,j5,X5,Z5,J5,tX,sX,rX,iX,uX,cX,dX,hX,pX,mX,bX,N8,wX,NK,TX,EK,NX,RK,FX,zX,PX,OK,zK,MX,WX,GX,qX,PK,MK,wK,KX,A5,YX,QX,e9,E8,WK,GK,n9,qK,r9,o9,l9,h9,f9,g9,y9,KK,x9,$9,S9,_9,C9,N9,A9,YK,D9,z9,B9,QK,e8,W9,H9,K9,n8,Y9,Q9,J9,TE,s7,R8,a8,a7,o7,l7,d7,$K,Km,p7,D8,O8,F8,m7,y7,x7,$7,S7,I7,k7,p8,T7,D7,F7,B7,m8,V7,U7,H7,g8,L9,K7,Y7,Q7,eY,nY,rY,iY,uY,x8,lY,$8,S8,dY,pY,mY,yY,xY,C8,gX,$Y,SY,_Y,CY,NY,AY,s8,BY,VY,UY,Z9];for(const t of GY)$I(t);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Va={},sc={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function HY(t,e){Va[t]=e}function Zs(t,e){if(!(t in Va)||e!=null){const s=jY(t,e);if(s!==null)Va[t]=s;else return console.log("Could not get context for WebGL version",t),null}const n=Va[t];return n==null||n.isContextLost()?(delete Va[t],Zs(t)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),Va[t])}function qY(t){if(!te().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&t===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function jY(t,e){if(t!==1&&t!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=e??qY(t);return n.addEventListener("webglcontextlost",s=>{s.preventDefault(),delete Va[t]},!1),te().getBool("SOFTWARE_WEBGL_ENABLED")&&(sc.failIfMajorPerformanceCaveat=!1),t===1?n.getContext("webgl",sc)||n.getContext("experimental-webgl",sc):n.getContext("webgl2",sc)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var fu;(function(t){t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH"})(fu||(fu={}));var ns;(function(t){t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD"})(ns||(ns={}));var cn;(function(t){t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(cn||(cn={}));function zl(t,e){return[e,t]}function KY(t,e){return t*e}function rc(t){const e=se(t),n=Math.ceil(e/4);return nm(n)}function yo(t,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(t/2))]}function XY(t,e){const[n,s]=yo(t,e);return n*s*4}function g0(t,e){const n=t;let s,r,a,i,o,u,l,c,d,h;return te().getNumber("WEBGL_VERSION")===2?(s=n.R32F,r=n.R16F,a=n.RGBA16F,i=n.RGBA32F,o=n.RED,l=4,c=1,d=n.HALF_FLOAT,h=n.FLOAT,u=n.RGBA8):(s=t.RGBA,r=t.RGBA,a=t.RGBA,i=n.RGBA,o=t.RGBA,l=4,c=4,d=e!=null?e.HALF_FLOAT_OES:null,h=t.FLOAT,u=t.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:u,downloadUnpackNumChannels:l,defaultNumChannels:c,textureTypeHalfFloat:d,textureTypeFloat:h}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function be(t,e){const n=e();return te().getBool("DEBUG")&&YY(t),n}function YY(t){const e=t.getError();if(e!==t.NO_ERROR)throw new Error("WebGL Error: "+eZ(t,e))}const ZY=596e-10,QY=65504;function JY(t){return!!(te().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||t===0||ZY<Math.abs(t)&&Math.abs(t)<QY)}function eZ(t,e){switch(e){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function ac(t,e){return Pr(t,()=>t.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function tZ(t,e){const n=Pr(t,()=>t.createShader(t.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(be(t,()=>t.shaderSource(n,e)),be(t,()=>t.compileShader(n)),t.getShaderParameter(n,t.COMPILE_STATUS)===!1)throw console.log(t.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function nZ(t,e){const n=Pr(t,()=>t.createShader(t.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(be(t,()=>t.shaderSource(n,e)),be(t,()=>t.compileShader(n)),te().get("ENGINE_COMPILE_ONLY"))return n;if(t.getShaderParameter(n,t.COMPILE_STATUS)===!1)throw NE(e,t.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}const sZ=/ERROR: [0-9]+:([0-9]+):/g;function NE(t,e){const n=sZ.exec(e);if(n==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(t);return}const s=+n[1],r=t.split(`
`),a=r.length.toString().length+2,i=r.map((d,h)=>Bi((h+1).toString(),a)+d);let o=0;for(let d=0;d<i.length;d++)o=Math.max(i[d].length,o);const u=i.slice(0,s-1),l=i.slice(s-1,s),c=i.slice(s);console.log(u.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${Bi(l[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function rZ(t){return Pr(t,()=>t.createProgram(),"Unable to create WebGLProgram.")}function aZ(t,e){if(be(t,()=>t.linkProgram(e)),!te().get("ENGINE_COMPILE_ONLY")&&t.getProgramParameter(e,t.LINK_STATUS)===!1)throw console.log(t.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function Jp(t,e){if(be(t,()=>t.validateProgram(e)),t.getProgramParameter(e,t.VALIDATE_STATUS)===!1)throw console.log(t.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function iZ(t,e){const n=Pr(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return be(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),be(t,()=>t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW)),n}function oZ(t,e){const n=Pr(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return be(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,n)),be(t,()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,e,t.STATIC_DRAW)),n}function uZ(t){return Pr(t,()=>t.createTexture(),"Unable to create WebGLTexture.")}function lZ(t,e){const n=te().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||e<=0){const s=`[${t}x${e}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(t>n||e>n){const s=`[${t}x${e}]`,r=`[${n}x${n}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+r+".")}}function cZ(t){return Pr(t,()=>t.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function o$(t,e,n,s,r,a,i){const o=t.getAttribLocation(e,n);return o===-1?!1:(be(t,()=>t.bindBuffer(t.ARRAY_BUFFER,s)),be(t,()=>t.vertexAttribPointer(o,r,t.FLOAT,!1,a,i)),be(t,()=>t.enableVertexAttribArray(o)),!0)}function dZ(t,e,n){gZ(t,n),be(t,()=>t.activeTexture(t.TEXTURE0+n)),be(t,()=>t.bindTexture(t.TEXTURE_2D,e))}function hZ(t,e,n){return Pr(t,()=>t.getUniformLocation(e,n),'uniform "'+n+'" not present in program.')}function pZ(t,e,n){return t.getUniformLocation(e,n)}function fZ(t,e,n,s){be(t,()=>dZ(t,e,s)),be(t,()=>t.uniform1i(n,s))}function ef(t,e,n){be(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,n)),be(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0))}function u$(t,e){be(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,e)),be(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0))}function ic(t){const e=t.checkFramebufferStatus(t.FRAMEBUFFER);if(e!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+mZ(t,e))}function mZ(t,e){switch(e){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function Pr(t,e,n){const s=be(t,()=>e());if(s==null)throw new Error(n);return s}function gZ(t,e){const n=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=e+t.TEXTURE0;if(s<t.TEXTURE0||s>n){const r=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${r}.`)}}function no(t,e=2){return se(t.slice(0,t.length-e))}function so(t){if(t.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function oc(t){let e=[1,1,1];return t.length===0||t.length===1&&t[0]===1||(e=[no(t),...so(t)]),e}function yZ(t,e=!1){let n=te().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=te().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");s===1/0&&te().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=n/2),e&&(n=n*2,s=s*2,t=t.map((o,u)=>u>=t.length-2?yg(t[u]):t[u]),t.length===1&&(t=[2,t[0]])),t.length!==2&&(t=fa(t).newShape);let r=se(t),a=null;t.length<=1&&r<=n?a=[1,r]:t.length===2&&t[0]<=n&&t[1]<=n?a=t:t.length===3&&t[0]*t[1]<=n&&t[2]<=n?a=[t[0]*t[1],t[2]]:t.length===3&&t[0]<=n&&t[1]*t[2]<=n?a=[t[0],t[1]*t[2]]:t.length===4&&t[0]*t[1]*t[2]<=n&&t[3]<=n?a=[t[0]*t[1]*t[2],t[3]]:t.length===4&&t[0]<=n&&t[1]*t[2]*t[3]<=n&&(a=[t[0],t[1]*t[2]*t[3]]);const i=a!=null&&Math.max(...a)>s&&Math.min(...a)<=(e?2:1)&&Math.min(...a)>0;if(a==null||i)if(e){const o=no(t);let u=2,l=2;t.length&&([u,l]=so(t)),r=o*(u/2)*(l/2),a=nm(r).map(c=>c*2)}else a=nm(r);return a}function uc(t){return t%2===0}function ud(t,e){if(t=t.slice(-2),e=e.slice(-2),tt(t,e)||!t.length||!e.length||t[0]===0||t[1]===0||e[0]===0||e[1]===0)return!0;if(t.length!==e.length){const n=t[t.length-1],s=e[e.length-1];if(n===s||uc(n)&&uc(s)&&(t[0]===1||e[0]===1))return!0}return t[1]===e[1]&&uc(t[0])&&uc(e[0])}let tf,nf;function bZ(t){if(tf==null){const e=Zs(t);tf=e.getParameter(e.MAX_TEXTURE_SIZE)}return tf}function xZ(t){if(nf==null){const e=Zs(t);nf=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,nf)}function wZ(t){if(t===0)return 0;let e;const n=Zs(t);return xs(n,"EXT_disjoint_timer_query_webgl2")&&t===2?e=2:xs(n,"EXT_disjoint_timer_query")?e=1:e=0,e}function xs(t,e){return t.getExtension(e)!=null}function l$(t){try{if(Zs(t)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function $Z(t){if(t===0)return!1;const e=Zs(t);if(t===1){if(!xs(e,"OES_texture_float"))return!1}else if(!xs(e,"EXT_color_buffer_float"))return!1;return Ym(e)}function vZ(t){if(t===0)return!1;const e=Zs(t);if(t===1){if(!xs(e,"OES_texture_float")||!xs(e,"WEBGL_color_buffer_float"))return!1}else{if(xs(e,"EXT_color_buffer_float"))return Ym(e);const s="EXT_color_buffer_half_float";if(xs(e,s)){const r=e.getExtension(s);return SZ(e,r)}return!1}return Ym(e)}function Ym(t){const e=g0(t),n=t.createTexture();t.bindTexture(t.TEXTURE_2D,n),t.texImage2D(t.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const a=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,a),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0);const i=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(n),t.deleteFramebuffer(a),i}function SZ(t,e){const n=g0(t,e),s=t.createTexture();t.bindTexture(t.TEXTURE_2D,s),t.texImage2D(t.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const i=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,i),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,s,0);const o=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(s),t.deleteFramebuffer(i),o}function IZ(t){return t!==2?!1:Zs(t).fenceSync!=null}function Ll(t,e){Array.isArray(t)||(t=[t]),t.forEach(n=>{n!=null&&O(n.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ke=te();ke.registerFlag("HAS_WEBGL",()=>ke.getNumber("WEBGL_VERSION")>0);ke.registerFlag("WEBGL_VERSION",()=>l$(2)?2:l$(1)?1:0);ke.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);ke.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>ke.get("WEBGL_VERSION")===2);ke.registerFlag("WEBGL_CPU_FORWARD",()=>!0);ke.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);ke.registerFlag("WEBGL_PACK",()=>ke.getBool("HAS_WEBGL"));ke.registerFlag("WEBGL_PACK_NORMALIZATION",()=>ke.getBool("WEBGL_PACK"));ke.registerFlag("WEBGL_PACK_CLIP",()=>ke.getBool("WEBGL_PACK"));ke.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>ke.getBool("WEBGL_PACK"));ke.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>ke.getBool("WEBGL_PACK"));ke.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>ke.getBool("WEBGL_PACK"));ke.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>ke.getBool("WEBGL_PACK"));ke.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>ke.getBool("WEBGL_PACK"));ke.registerFlag("WEBGL_PACK_REDUCE",()=>ke.getBool("WEBGL_PACK"));ke.registerFlag("WEBGL_LAZILY_UNPACK",()=>ke.getBool("WEBGL_PACK"));ke.registerFlag("WEBGL_CONV_IM2COL",()=>ke.getBool("WEBGL_PACK"));ke.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>ke.getBool("WEBGL_PACK"));ke.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>bZ(ke.getNumber("WEBGL_VERSION")));ke.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>xZ(ke.getNumber("WEBGL_VERSION")));ke.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const t=ke.getNumber("WEBGL_VERSION");return t===0?0:wZ(t)});ke.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>ke.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!OI());ke.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>$Z(ke.getNumber("WEBGL_VERSION")));ke.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>ke.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:ke.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));ke.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>vZ(ke.getNumber("WEBGL_VERSION")));ke.registerFlag("WEBGL_FENCE_API_ENABLED",()=>IZ(ke.getNumber("WEBGL_VERSION")));ke.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>ke.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);ke.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,t=>{if(typeof t!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${t}.`);if(t<0&&t!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${t}.`)});ke.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>OI()?1:-1,t=>{if(typeof t!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${t}.`);if(t<0&&t!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${t}.`)});ke.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);ke.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);ke.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);ke.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);ke.registerFlag("WEBGL_EXP_CONV",()=>!1);ke.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>ke.getBool("IS_TEST"));ke.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);ke.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);ke.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);ke.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function En(){let t,e,n,s,r,a,i,o,u,l;return te().getNumber("WEBGL_VERSION")===2?(t="#version 300 es",e="in",n="out",s="in",r="texture",a="outputColor",i="out vec4 outputColor;",o=te().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",u="",l=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(t="",e="attribute",n="varying",s="varying",r="texture2D",a="gl_FragColor",i="",o=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,u=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,l=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:t,attribute:e,varyingVs:n,varyingFs:s,texture2D:r,output:a,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:u,defineRound:l}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vi(t,e,n="index"){const s=Ae(e);return s.map((r,a)=>{const i=`int ${t[a]} = ${n} / ${r}`,o=a===s.length-1?`int ${t[a+1]} = ${n} - ${t[a]} * ${r}`:`index -= ${t[a]} * ${r}`;return`${i}; ${o};`}).join("")}function up(t,e,n="index"){const s=Ae(e);return s.map((r,a)=>{const i=`int ${t[a]} = ${n} / outShapeStrides[${a}]`,o=a===s.length-1?`int ${t[a+1]} = ${n} - ${t[a]} * outShapeStrides[${a}]`:`index -= ${t[a]} * outShapeStrides[${a}]`;return`${i}; ${o};`}).join("")}function _Z(t,e){const n=t.length,s=t.map(a=>`${e}[${a}]`),r=new Array(n-1);r[n-2]=s[n-1];for(let a=n-3;a>=0;--a)r[a]=`(${r[a+1]} * ${s[a+1]})`;return r}function kZ(t,e,n="index"){const s=t.map((a,i)=>i),r=_Z(s,e);return r.map((a,i)=>{const o=`int ${t[i]} = ${n} / ${r[i]}`,u=i===r.length-1?`int ${t[i+1]} = ${n} - ${t[i]} * ${r[i]}`:`index -= ${t[i]} * ${r[i]}`;return`${o}; ${u};`}).join("")}function y0(t){const e=Ae(t).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function b0(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const EE=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:AE}=WU;function CZ(t,e,n){const s=[];if(t.forEach(p=>{const f=se(p.shapeInfo.logicalShape);if(p.shapeInfo.isUniform?s.push(`uniform float ${p.name}${f>1?`[${f}]`:""};`):(s.push(`uniform sampler2D ${p.name};`),s.push(`uniform int offset${p.name};`)),n.enableShapeUniforms){const{uniformShape:m}=x0(n.packedInputs,p.shapeInfo.logicalShape,p.shapeInfo.texShape);switch(m.length){case 1:s.push(`uniform int ${p.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${p.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${p.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${p.name}Shape;`);break}s.push(`uniform ivec2 ${p.name}TexShape;`)}}),n.enableShapeUniforms){switch(e.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;");break}s.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(p=>{s.push(`uniform ${p.type} ${p.name}${p.arrayIndex?`[${p.arrayIndex}]`:""};`)});const r=s.join(`
`),a=t.map(p=>TZ(p,e,n.packedInputs,n.enableShapeUniforms)).join(`
`),i=e.texShape,o=En(),u=AZ(o);let l,c,d=OZ(o);return e.isPacked?(l=NZ(e.logicalShape,i,n.enableShapeUniforms),c=DZ(o)):(l=EZ(e.logicalShape,i,n.enableShapeUniforms),c=RZ(o)),n.packedInputs&&(d+=PZ),[d,u,c,r,l,a,n.userCode].join(`
`)}function bo(t,e=!1){const n=t.shapeInfo.logicalShape;switch(n.length){case 0:return YZ(t,e);case 1:return QZ(t,e);case 2:return eQ(t,e);case 3:return nQ(t,e);case 4:return rQ(t,e);case 5:return aQ(t);case 6:return iQ(t);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function RE(t,e){switch(t.shapeInfo.logicalShape.length){case 0:return XZ(t);case 1:return ZZ(t,e);case 2:return JZ(t,e);case 3:return tQ(t,e);default:return sQ(t,e)}}function TZ(t,e,n=!1,s){let r="";n?r+=RE(t,s):r+=bo(t,s);const a=t.shapeInfo.logicalShape,i=e.logicalShape;return a.length<=i.length&&(n?r+=oQ(t,e):r+=uQ(t,e)),r}function NZ(t,e,n){switch(t.length){case 0:return DE();case 1:return BZ(t,e,n);case 2:return jZ(t,e,n);case 3:return VZ(t,e,n);default:return UZ(t,e,n)}}function EZ(t,e,n){switch(t.length){case 0:return DE();case 1:return MZ(t,e,n);case 2:return KZ(t,e,n);case 3:return WZ(t,e,n);case 4:return GZ(t,e,n);case 5:return HZ(t,e);case 6:return qZ(t,e);default:throw new Error(`${t.length}-D output sampling is not yet supported`)}}function AZ(t){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${t.texture2D}(textureSampler, uv).r;
    }
  `}function RZ(t){return`
    void setOutput(float val) {
      ${t.output} = vec4(val, 0, 0, 0);
    }
  `}function DZ(t){return`
    void setOutput(vec4 val) {
      ${t.output} = val;
    }
  `}function OZ(t){return`${t.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${t.varyingFs} vec2 resultUV;
    ${t.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${t.defineSpecialNaN}
    ${t.defineSpecialInf}
    ${t.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${FZ}
    ${zZ}
    ${LZ}
  `}const FZ=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,zZ=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,LZ=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,PZ=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function DE(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function BZ(t,e,n){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return s[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:s[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `}function MZ(t,e,n){return e[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function VZ(t,e,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(t[2]/2),a=r*Math.ceil(t[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec3(b, r, c);
    }
  `}function WZ(t,e,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${up(["r","c","d"],t)}
    return ivec3(r, c, d);
  }
`;const s=vi(["r","c","d"],t);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `}function UZ(t,e,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(t[t.length-1]/2),a=r*Math.ceil(t[t.length-2]/2);let i=a,o="",u="b, r, c";for(let l=2;l<t.length-1;l++)i*=t[t.length-l-1],o=`
      int b${l} = index / ${i};
      index -= b${l} * ${i};
    `+o,u=`b${l}, `+u;return`
    ivec${t.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${o}

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec${t.length}(${u});
    }
  `}function GZ(t,e,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${up(["r","c","d","d2"],t)}
      return ivec4(r, c, d, d2);
    }
  `;const s=vi(["r","c","d","d2"],t);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `}function HZ(t,e){const n=vi(["r","c","d","d2","d3"],t);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function qZ(t,e){const n=vi(["r","c","d","d2","d3","d4"],t);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function jZ(t,e,n){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(tt(t,e))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;const r=Math.ceil(t[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec2(r, c);
    }
  `}function KZ(t,e,n){return tt(t,e)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:t[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:t[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${t[1]};
      int c = index - r * ${t[1]};
      return ivec2(r, c);
    }
  `}function Si(t){return`offset${t}`}function XZ(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),s=En();return`
    vec4 ${n}() {
      return ${s.texture2D}(${e}, halfCR);
    }
  `}function YZ(t,e){const n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`float ${s}() {return ${n};}`;const[r,a]=t.shapeInfo.texShape;if(r===1&&a===1)return`
      float ${s}() {
        return sampleTexture(${n}, halfCR);
      }
    `;const i=Si(n);if(e)return`
    float ${s}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});
      return sampleTexture(${n}, uv);
    }
  `;const[o,u]=t.shapeInfo.texShape;return`
    float ${s}() {
      vec2 uv = uvFromFlat(${o}, ${u}, ${i});
      return sampleTexture(${n}, uv);
    }
  `}function ZZ(t,e){const n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t.shapeInfo.texShape,a=En();if(e)return`
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${a.texture2D}(${n}, uv);
    }
  `;const i=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${a.texture2D}(${n}, uv);
    }
  `}function QZ(t,e){const n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`
      float ${s}(int index) {
        ${xo(t)}
      }
    `;const r=t.shapeInfo.texShape,a=r[0],i=r[1];if(i===1&&a===1)return`
      float ${s}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;const o=Si(n);return i===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${a}.0);
        return sampleTexture(${n}, uv);
      }
    `:a===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:e?`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${a}, ${i}, index + ${o});
      return sampleTexture(${n}, uv);
    }
  `}function JZ(t,e){const n=t.shapeInfo.logicalShape,s=t.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),a=t.shapeInfo.texShape,i=a[0],o=a[1],u=En();if(a!=null&&tt(n,a))return e?`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${u.texture2D}(${s}, uv);
      }
    `:`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);

        return ${u.texture2D}(${s}, uv);
      }
    `;if(e)return`
    vec4 ${r}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${u.texture2D}(${s}, uv);
    }
  `;const l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=Math.ceil(n[1]/2);return`
    vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${l[0]}, ${l[1]}, row, col);
      return ${u.texture2D}(${s}, uv);
    }
  `}function eQ(t,e){const n=t.shapeInfo.logicalShape,s=t.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),a=t.shapeInfo.texShape;if(a!=null&&tt(n,a)){if(e)return`
      float ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;const h=a[0],p=a[1];return`
    float ${r}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${p}.0, ${h}.0);
      return sampleTexture(${s}, uv);
    }
  `}const{newShape:i,keptDims:o}=fa(n),u=i;if(u.length<n.length){const h=wo(t,u),p=["row","col"];return`
      ${bo(h,e)}
      float ${r}(int row, int col) {
        return ${r}(${$o(p,o)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${r}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${xo(t)}
      }
    `;const l=a[0],c=a[1],d=Si(s);return c===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);
      return sampleTexture(${s}, uv);
    }
  `:l===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  `:e?`
      float ${r}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${d};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    `:`
  float ${r}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${d};
    vec2 uv = uvFromFlat(${l}, ${c}, index);
    return sampleTexture(${s}, uv);
  }
`}function tQ(t,e){const n=t.shapeInfo.logicalShape,s=t.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),a=t.shapeInfo.texShape,i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];if(n[0]===1){const h=n.slice(1),p=[1,2],f=wo(t,h),m=["b","row","col"];return`
        ${RE(f,e)}
        vec4 ${r}(int b, int row, int col) {
          return ${r}(${$o(m,p)});
        }
      `}const o=En();if(e)return`
    vec4 ${r}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${o.texture2D}(${s}, uv);
    }
  `;const u=i[0],l=i[1],c=Math.ceil(n[2]/2),d=c*Math.ceil(n[1]/2);return`
    vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${u}, ${l}, ${d}, ${c}, b, row, col);
      return ${o.texture2D}(${s}, uv);
    }
  `}function nQ(t,e){const n=t.shapeInfo.logicalShape,s=t.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),a=n[1]*n[2],i=n[2],{newShape:o,keptDims:u}=fa(n),l=o;if(l.length<n.length){const m=wo(t,l),g=["row","col","depth"];return`
        ${bo(m,e)}
        float ${r}(int row, int col, int depth) {
          return ${r}(${$o(g,u)});
        }
      `}if(t.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${a}, ${i}, 1)));
        ${xo(t)}
      }
    `;const c=t.shapeInfo.texShape,d=c[0],h=c[1],p=t.shapeInfo.flatOffset;if(h===a&&p==null)return e?`
      float ${r}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
        float ${r}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${h}.0, ${d}.0);
          return sampleTexture(${s}, uv);
        }
      `;if(h===i&&p==null)return e?`
      float ${r}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${d}.0);
      return sampleTexture(${s}, uv);
    }
  `;const f=Si(s);return e?`
    float ${r}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${f};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    `:`
      float ${r}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${a} + col * ${i} + depth + ${f};
        vec2 uv = uvFromFlat(${d}, ${h}, index);
        return sampleTexture(${s}, uv);
      }
  `}function sQ(t,e){const n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=En();if(e)return`
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${n}, uv);
    }
  `;const a=t.shapeInfo.logicalShape,i=a.length,o=t.shapeInfo.texShape,u=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],l=u[0],c=u[1],d=Math.ceil(a[i-1]/2);let h=d*Math.ceil(a[i-2]/2),p="int b, int row, int col",f=`b * ${h} + (row / 2) * ${d} + (col / 2)`;for(let m=2;m<i-1;m++)p=`int b${m}, `+p,h*=a[i-m-1],f=`b${m} * ${h} + `+f;return`
    vec4 ${s}(${p}) {
      int index = ${f};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${l});
      return ${r.texture2D}(${n}, uv);
    }
  `}function rQ(t,e){const n=t.shapeInfo.logicalShape,s=t.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),a=n[3],i=n[2]*a,o=n[1]*i,{newShape:u,keptDims:l}=fa(n);if(u.length<n.length){const b=wo(t,u),$=["row","col","depth","depth2"];return`
      ${bo(b,e)}
      float ${r}(int row, int col, int depth, int depth2) {
        return ${r}(${$o($,l)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${o}, ${i}, ${a}, 1)));
        ${xo(t)}
      }
    `;const c=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,h=d[0],p=d[1],f=`int stride2 = ${s}Shape[3];`,m=`int stride1 = ${s}Shape[2] * stride2;`,g=`int stride0 = ${s}Shape[1] * stride1;`;if(p===o&&c==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        ${f}
        ${m}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${a}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${h}.0);
        return sampleTexture(${s}, uv);
      }
    `;if(p===a&&c==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${h}.0);
        return sampleTexture(${s}, uv);
      }
    `;const y=Si(s);return e?`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f}
      ${m}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${y});
      return sampleTexture(${s}, uv);
    }
  `:`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} +
          depth * ${a} + depth2;
      vec2 uv = uvFromFlat(${h}, ${p}, index + ${y});
      return sampleTexture(${s}, uv);
    }
  `}function aQ(t){const e=t.shapeInfo.logicalShape,n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=e[4],a=e[3]*r,i=e[2]*a,o=e[1]*i,{newShape:u,keptDims:l}=fa(e);if(u.length<e.length){const m=wo(t,u),g=["row","col","depth","depth2","depth3"];return`
      ${bo(m)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${$o(g,l)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${o}, ${i}, ${a}, ${r})) +
          depth3;
        ${xo(t)}
      }
    `;const c=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,h=d[0],p=d[1];if(p===o&&c==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${a}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${h}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(p===r&&c==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${h}.0);
        return sampleTexture(${n}, uv);
      }
    `;const f=Si(n);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} + depth * ${a} +
          depth2 * ${r} + depth3 + ${f};
      vec2 uv = uvFromFlat(${h}, ${p}, index);
      return sampleTexture(${n}, uv);
    }
  `}function iQ(t){const e=t.shapeInfo.logicalShape,n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:r,keptDims:a}=fa(e);if(r.length<e.length){const g=wo(t,r),y=["row","col","depth","depth2","depth3","depth4"];return`
      ${bo(g)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${$o(y,a)});
      }
    `}const i=e[5],o=e[4]*i,u=e[3]*o,l=e[2]*u,c=e[1]*l;if(t.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${l}, ${u}, ${o})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${xo(t)}
      }
    `;const d=t.shapeInfo.flatOffset,h=t.shapeInfo.texShape,p=h[0],f=h[1];if(f===c&&d==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${l}, ${u}, ${o}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(f===i&&d==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;const m=Si(n);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${l} + depth * ${u} +
          depth2 * ${o} + depth3 * ${i} + depth4 + ${m};
      vec2 uv = uvFromFlat(${p}, ${f}, index);
      return sampleTexture(${n}, uv);
    }
  `}function xo(t){const e=t.name,n=se(t.shapeInfo.logicalShape);return n<2?`return ${e};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function oQ(t,e){const n=t.name,s=n.charAt(0).toUpperCase()+n.slice(1),r="get"+s+"AtOutCoords",a=t.shapeInfo.logicalShape.length,i=e.logicalShape.length,o=AE(t.shapeInfo.logicalShape,e.logicalShape),u=yt(i),l=i-a;let c;const d=["x","y","z","w","u","v"];a===0?c="":i<2&&o.length>=1?c="coords = 0;":c=o.map(b=>`coords.${d[b+l]} = 0;`).join(`
`);let h="";i<2&&a>0?h="coords":h=t.shapeInfo.logicalShape.map((b,$)=>`coords.${d[$+l]}`).join(", ");let p="return outputValue;";const m=se(t.shapeInfo.logicalShape)===1,y=se(e.logicalShape)===1;if(a===1&&!m&&!y)p=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(m&&!y)i===1?p=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:p=`
        return vec4(outputValue.x);
      `;else if(o.length){const b=a-2,$=a-1;o.indexOf(b)>-1&&o.indexOf($)>-1?p="return vec4(outputValue.x);":o.indexOf(b)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf($)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${r}() {
      ${u} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${s}(${h});
      ${p}
    }
  `}function uQ(t,e){const n=t.name,s=n.charAt(0).toUpperCase()+n.slice(1),r="get"+s+"AtOutCoords",a=e.texShape,i=t.shapeInfo.texShape,o=t.shapeInfo.logicalShape.length,u=e.logicalShape.length;if(!t.shapeInfo.isUniform&&o===u&&t.shapeInfo.flatOffset==null&&tt(i,a))return`
      float ${r}() {
        return sampleTexture(${n}, resultUV);
      }
    `;const l=yt(u),c=AE(t.shapeInfo.logicalShape,e.logicalShape),d=u-o;let h;const p=["x","y","z","w","u","v"];o===0?h="":u<2&&c.length>=1?h="coords = 0;":h=c.map(m=>`coords.${p[m+d]} = 0;`).join(`
`);let f="";return u<2&&o>0?f="coords":f=t.shapeInfo.logicalShape.map((m,g)=>`coords.${p[g+d]}`).join(", "),`
    float ${r}() {
      ${l} coords = getOutputCoords();
      ${h}
      return get${s}(${f});
    }
  `}function yt(t){if(t<=1)return"int";if(t===2)return"ivec2";if(t===3)return"ivec3";if(t===4)return"ivec4";if(t===5)return"ivec5";if(t===6)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function x0(t,e,n){const{newShape:s,keptDims:r}=fa(e),a=e.length,i=t&&a===3&&e[0]===1,o=i?e.slice(1):s,u=!t&&a>1&&!tt(e,n)&&s.length<a||i;return{useSqueezeShape:u,uniformShape:u?o:e,keptDims:r}}function wo(t,e){const n=JSON.parse(JSON.stringify(t));return n.shapeInfo.logicalShape=e,n}function $o(t,e){return e.map(n=>t[n]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lQ(t,e,n,s){const r=n.map((c,d)=>{const h={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:c.isUniform?!1:c.texData.isPacked,flatOffset:null};return c.texData!=null&&c.texData.slice!=null&&c.texData.slice.flatOffset>0&&(h.flatOffset=c.texData.slice.flatOffset),{name:e.variableNames[d],shapeInfo:h}}),a=r.map(c=>c.shapeInfo),i={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},o=CZ(r,i,e),u=nZ(t.gl,o),l=t.createProgram(u);return te().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:u,source:o,webGLProgram:l,inShapeInfos:a,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(t.buildVao(l),Object.assign({program:e,fragmentShader:u,source:o,webGLProgram:l,inShapeInfos:a,outShapeInfo:i},OE(t,e,l)))}function OE(t,e,n){const s=[],r=[];let a,i,o,u=null,l=null;l=t.getUniformLocation(n,"NAN",!1),te().getNumber("WEBGL_VERSION")===1&&(u=t.getUniformLocation(n,"INFINITY",!1));const c=!1;for(const d of e.variableNames){const h={name:d,uniform:t.getUniformLocation(n,d,c),offset:t.getUniformLocation(n,`offset${d}`,c)};e.enableShapeUniforms&&(h.shape=t.getUniformLocation(n,`${d}Shape`,c),h.texShape=t.getUniformLocation(n,`${d}TexShape`,c)),s.push(h)}if(e.enableShapeUniforms&&(a=t.getUniformLocation(n,"outShape",c),o=t.getUniformLocation(n,"outShapeStrides",c),i=t.getUniformLocation(n,"outTexShape",c)),e.customUniforms)for(const d of e.customUniforms)r.push(t.getUniformLocation(n,d.name,c));return{variablesLocations:s,customUniformLocations:r,infLoc:u,nanLoc:l,outShapeLocation:a,outShapeStridesLocation:o,outTexShapeLocation:i}}function c$(t,e){if(t.length!==e.length)throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${e.length} inputs`);t.forEach((n,s)=>{const r=n.logicalShape,a=e[s],i=a.shape;if(!tt(r,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${i} must match`);if(n.isUniform&&a.isUniform)return;const o=n.texShape,u=a.isUniform?null:a.texData.texShape;if(!tt(o,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${u} must match`)})}function cQ(t,e,n,s,r){e.program.enableShapeUniforms||(c$(e.inShapeInfos,n),c$([e.outShapeInfo],[s]));const a=s.texData.texture,i=s.texData.texShape;s.texData.isPacked?t.setOutputPackedMatrixTexture(a.texture,i[0],i[1]):t.setOutputMatrixTexture(a.texture,i[0],i[1]),t.setProgram(e.webGLProgram),t.bindVertexArray(e.webGLProgram.vao),te().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&t.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&t.gl.uniform1f(e.nanLoc,NaN);for(let u=0;u<n.length;++u){const l=n[u],{uniform:c,offset:d,shape:h,texShape:p}=e.variablesLocations[u];if(h){const{uniformShape:f}=x0(e.program.packedInputs,l.shape,l.texData.texShape);switch(f.length){case 1:t.gl.uniform1iv(h,new Int32Array(f));break;case 2:t.gl.uniform2iv(h,new Int32Array(f));break;case 3:t.gl.uniform3iv(h,new Int32Array(f));break;case 4:t.gl.uniform4iv(h,new Int32Array(f));break}}if(p&&t.gl.uniform2i(p,l.texData.texShape[0],l.texData.texShape[1]),c!=null){if(l.isUniform){if(se(l.shape)<2)t.gl.uniform1f(c,l.uniformValues[0]);else{let f=l.uniformValues;f instanceof Float32Array||(f=new Float32Array(f)),t.gl.uniform1fv(c,f)}continue}l.texData.slice!=null&&d!=null&&t.gl.uniform1i(d,l.texData.slice.flatOffset),t.setInputMatrixTexture(l.texData.texture.texture,c,u)}}const o=e.outShapeLocation;if(o)switch(s.shape.length){case 1:t.gl.uniform1iv(o,new Int32Array(s.shape));break;case 2:t.gl.uniform2iv(o,new Int32Array(s.shape));break;case 3:t.gl.uniform3iv(o,new Int32Array(s.shape));break;case 4:t.gl.uniform4iv(o,new Int32Array(s.shape));break}if(e.outShapeStridesLocation){const u=Ae(s.shape);switch(s.shape.length){case 2:t.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(u));break;case 3:t.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(u));break;case 4:t.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(u));break}}if(e.outTexShapeLocation&&t.gl.uniform2i(e.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),e.program.customUniforms&&r)for(let u=0;u<e.program.customUniforms.length;++u){const l=e.program.customUniforms[u],c=e.customUniformLocations[u],d=r[u];if(l.type==="float")t.gl.uniform1fv(c,d);else if(l.type==="vec2")t.gl.uniform2fv(c,d);else if(l.type==="vec3")t.gl.uniform3fv(c,d);else if(l.type==="vec4")t.gl.uniform4fv(c,d);else if(l.type==="int")t.gl.uniform1iv(c,d);else if(l.type==="ivec2")t.gl.uniform2iv(c,d);else if(l.type==="ivec3")t.gl.uniform3iv(c,d);else if(l.type==="ivec4")t.gl.uniform4iv(c,d);else throw Error(`uniform type ${l.type} is not supported yet.`)}t.executeProgram()}function dQ(t,e,n){let s="";e.concat(n).forEach(i=>{const o=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(t.enableShapeUniforms&&!i.isUniform){const u=i.texData.texShape,{useSqueezeShape:l,uniformShape:c,keptDims:d}=x0(t.packedInputs,i.shape,u);let h="",p="",f="";if(c.length===1&&t.packedInputs){const v=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];h=`${v[0]>1}_${v[1]>1}`}else if(c.length===2&&!t.packedInputs)p=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!t.packedInputs){const v=Ae(c);f=`${v[0]===u[1]}_${v[v.length-1]===u[1]}`}const m=i.shape.length,g=c.length===2&&tt(i.shape,u),y=se(i.shape)===1,b=Xi(i.shape,n.shape),$=!t.packedInputs&&m===n.shape.length&&tt(u,n.texData.texShape),w=t.packedInputs||c.length>2?"":`${u[0]>1}_${u[1]>1}`;s+=`${m}_${$}_${l?d:""}_${c.length}_${y}_${b}_${g}_${h}_${p}_${f}_${w}_${o}`}else{const u=i.isUniform?"uniform":i.texData.texShape;s+=`${i.shape}_${u}_${o}`}});const r=t.userCode;let a=t.constructor.name;return a+="_"+s+"_"+r+`${te().getNumber("WEBGL_VERSION")}`,a}function $n(t){return te().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&t<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hQ{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=fu.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=En();this.outputShape=e,this.enableShapeUniforms=$n(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?up(["r","c","d"],e):vi(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pQ{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=fu.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=En();this.outputShape=e,this.enableShapeUniforms=$n(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?up(["r","c","d"],e):vi(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fQ{constructor(e){this.variableNames=["A"],this.outTexUsage=ns.DOWNLOAD;const n=En();this.outputShape=e,this.userCode=`
      ${EE}

      void main() {
        float x = getAAtOutCoords();
        ${n.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mQ{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=ns.DOWNLOAD;const n=En();this.outputShape=e,this.userCode=`
      ${EE}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${n.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gQ={R:0,G:1,B:2,A:3};class d${constructor(e,n=!1,s="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=En();this.outputShape=e,this.enableShapeUniforms=$n(this.outputShape.length);let a="result";n&&(a="floor(result * 255. + 0.5)");let i="";for(let o=0;o<s.length;o++){const u=s[o];i+=`
          if(offset == ${o}) {
            result = values[${gQ[u]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?b0():y0(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${s.length});

        flatIndex = idiv(flatIndex, ${s.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${i}
        }
        ${r.output} = vec4(${a}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yQ{constructor(e,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=En();this.outputShape=e,this.enableShapeUniforms=$n(this.outputShape.length);let r="",a="result";n&&(a="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let o=0;o<=1;o++){const u=i*2+o;r+=`
          localCoords = coords;
          if(localCoords[2] + ${o} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${o};
          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${i};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${s.texture2D}(A, uv);

            if (offset == 0) {
              result[${u}] = values[0];
            } else if (offset == 1) {
              result[${u}] = values[1];
            } else if (offset == 2) {
              result[${u}] = values[2];
            } else {
              result[${u}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?b0():y0(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${s.output} = ${a};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bQ(t){const e=En(),n=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return tZ(t,n)}function xQ(t){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return iZ(t,e)}function wQ(t){const e=new Uint16Array([0,1,2,2,1,3]);return oZ(t,e)}function Pl(t,e,n,s,r,a){lZ(e,n);const i=uZ(t),o=t.TEXTURE_2D;return be(t,()=>t.bindTexture(o,i)),be(t,()=>t.texParameteri(o,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)),be(t,()=>t.texParameteri(o,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)),be(t,()=>t.texParameteri(o,t.TEXTURE_MIN_FILTER,t.NEAREST)),be(t,()=>t.texParameteri(o,t.TEXTURE_MAG_FILTER,t.NEAREST)),te().getNumber("WEBGL_VERSION")===1?be(t,()=>t.texImage2D(o,0,s,e,n,0,r,a,null)):be(t,()=>t.texStorage2D(o,1,s,e,n)),be(t,()=>t.bindTexture(t.TEXTURE_2D,null)),{texture:i,texShape:[n,e]}}function FE(t){return t.internalFormatFloat}function $Q(t,e,n,s){const[r,a]=zl(e,n);return Pl(t,r,a,FE(s),s.textureFormatFloat,t.FLOAT)}function zE(t){return t.internalFormatHalfFloat}function vQ(t,e,n,s){const[r,a]=zl(e,n);return Pl(t,r,a,zE(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function LE(t){return t.downloadTextureFormat}function SQ(t,e,n,s){const[r,a]=zl(e,n);return Pl(t,r,a,LE(s),t.RGBA,t.UNSIGNED_BYTE)}function PE(t){return t.internalFormatPackedFloat}function IQ(t,e,n,s){const[r,a]=yo(e,n);return Pl(t,r,a,PE(s),t.RGBA,t.FLOAT)}function BE(t){return t.internalFormatPackedHalfFloat}function _Q(t,e,n,s){const[r,a]=yo(e,n);return Pl(t,r,a,BE(s),t.RGBA,s.textureTypeHalfFloat)}function kQ(t,e,n){return be(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),o$(t,e,"clipSpacePos",n,3,20,0)&&o$(t,e,"uv",n,2,20,12)}function CQ(t,e,n,s,r,a){be(t,()=>t.bindTexture(t.TEXTURE_2D,e));let i,o,u;r instanceof Uint8Array?(i=new Uint8Array(n*s*4),o=t.UNSIGNED_BYTE,u=t.RGBA):(i=new Float32Array(n*s*4),o=t.FLOAT,u=a.internalFormatPackedFloat),i.set(r),te().getNumber("WEBGL_VERSION")===2?be(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,n,s,t.RGBA,o,i)):be(t,()=>t.texImage2D(t.TEXTURE_2D,0,u,n,s,0,t.RGBA,o,i)),be(t,()=>t.bindTexture(t.TEXTURE_2D,null))}function TQ(t,e,n){be(t,()=>t.bindTexture(t.TEXTURE_2D,e)),n.data instanceof Uint8Array?te().getNumber("WEBGL_VERSION")===2?be(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,n.width,n.height,t.RGBA,t.UNSIGNED_BYTE,n.data)):be(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,n.width,n.height,0,t.RGBA,t.UNSIGNED_BYTE,n.data)):te().getNumber("WEBGL_VERSION")===2?be(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,t.RGBA,t.UNSIGNED_BYTE,n)):be(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,n)),be(t,()=>t.bindTexture(t.TEXTURE_2D,null))}function NQ(t,e,n,s){const r=t.createBuffer();be(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,r));const o=4*4*e*n;return be(t,()=>t.bufferData(t.PIXEL_PACK_BUFFER,o,t.STREAM_READ)),be(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,0)),be(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null)),r}function EQ(t,e,n){const s=t,r=new Float32Array(n);return s.bindBuffer(s.PIXEL_PACK_BUFFER,e),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r}function AQ(t,e,n,s){const[r,a]=zl(e,n),i=4,o=new Uint8Array(KY(e*n,i));return be(t,()=>t.readPixels(0,0,r,a,s.downloadTextureFormat,t.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}function RQ(t,e,n,s,r,a,i,o){const u=t,l=new Float32Array(XY(a,i));return u.bindBuffer(u.PIXEL_PACK_BUFFER,e),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,l),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),l}function DQ(t,e,n){const s=new Float32Array(e*n*4);return be(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,s)),s}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sf{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const n=te().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,HY(n,e)):this.gl=Zs(n),e=this.gl,te().getNumber("WEBGL_VERSION")===2){const a=e;this.createVertexArray=()=>be(a,()=>a.createVertexArray()),this.bindVertexArray=i=>be(a,()=>a.bindVertexArray(i)),this.deleteVertexArray=i=>be(a,()=>a.deleteVertexArray(i)),this.getVertexArray=()=>be(a,()=>a.getParameter(a.VERTEX_ARRAY_BINDING))}else if(e!=null){const a=e.getExtension("OES_vertex_array_object");if(a==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>be(e,()=>a.createVertexArrayOES()),this.bindVertexArray=i=>be(e,()=>a.bindVertexArrayOES(i)),this.deleteVertexArray=i=>be(e,()=>a.deleteVertexArrayOES(i)),this.getVertexArray=()=>be(e,()=>e.getParameter(a.VERTEX_ARRAY_BINDING_OES))}let s="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),te().getNumber("WEBGL_VERSION")===1){const a="OES_texture_float",i="OES_texture_half_float";if(this.textureFloatExtension=ac(this.gl,a),xs(this.gl,i))this.textureHalfFloatExtension=ac(this.gl,i);else if(te().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),xs(this.gl,r))this.colorBufferHalfFloatExtension=ac(this.gl,r);else if(te().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",xs(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else if(xs(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=xQ(this.gl),this.indexBuffer=wQ(this.gl),this.framebuffer=cZ(this.gl),this.textureConfig=g0(this.gl,this.textureHalfFloatExtension)}get debug(){return te().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;be(e,()=>e.finish()),be(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),be(e,()=>e.deleteFramebuffer(this.framebuffer)),be(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),be(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),be(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,n){return this.throwIfDisposed(),$Q(this.gl,e,n,this.textureConfig)}createFloat16MatrixTexture(e,n){return this.throwIfDisposed(),vQ(this.gl,e,n,this.textureConfig)}createUnsignedBytesMatrixTexture(e,n){return this.throwIfDisposed(),SQ(this.gl,e,n,this.textureConfig)}uploadPixelDataToTexture(e,n){this.throwIfDisposed(),TQ(this.gl,e,n)}uploadDenseMatrixToTexture(e,n,s,r){this.throwIfDisposed(),CQ(this.gl,e,n,s,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,n){return this.throwIfDisposed(),_Q(this.gl,e,n,this.textureConfig)}createPackedMatrixTexture(e,n){return this.throwIfDisposed(),IQ(this.gl,e,n,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(u$(this.gl,this.framebuffer),this.outputTexture=null),be(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,n,s){return this.downloadMatrixDriver(e,()=>AQ(this.gl,n,s,this.textureConfig))}downloadPackedMatrixFromBuffer(e,n,s,r,a,i){return RQ(this.gl,e,n,s,r,a,i,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,n){return EQ(this.gl,e,n)}createBufferFromTexture(e,n,s){this.bindTextureToFrameBuffer(e);const r=NQ(this.gl,n,s,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let n,s;if(te().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,a=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),s=()=>{const i=r.clientWaitSync(a,0,0);return i===r.ALREADY_SIGNALED||i===r.CONDITION_SATISFIED},n=a}else te().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(n=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(n,te().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:n,isFencePassed:s}}downloadMatrixFromPackedTexture(e,n,s){return this.downloadMatrixDriver(e,()=>DQ(this.gl,n,s))}createProgram(e){this.throwIfDisposed();const n=this.gl;this.vertexShader==null&&(this.vertexShader=bQ(n));const s=rZ(n);be(n,()=>n.attachShader(s,this.vertexShader)),be(n,()=>n.attachShader(s,e)),aZ(n,s);const r=Object.assign(s,{vao:this.createVertexArray()});return this.debug&&Jp(n,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const n=this.gl;be(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),kQ(n,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(be(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&Jp(this.gl,this.program),be(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,n,s=!0){return this.throwIfDisposed(),s?hZ(this.gl,e,n):pZ(this.gl,e,n)}getAttributeLocation(e,n){return this.throwIfDisposed(),be(this.gl,()=>this.gl.getAttribLocation(e,n))}getUniformLocationNoThrow(e,n){return this.throwIfDisposed(),this.gl.getUniformLocation(e,n)}setInputMatrixTexture(e,n,s){this.throwIfDisposed(),this.throwIfNoProgram(),fZ(this.gl,e,n,s)}setOutputMatrixTexture(e,n,s){this.setOutputMatrixTextureDriver(e,s,n)}setOutputPackedMatrixTexture(e,n,s){this.throwIfDisposed();const[r,a]=yo(n,s);this.setOutputMatrixTextureDriver(e,r,a)}setOutputMatrixWriteRegion(e,n,s,r){this.setOutputMatrixWriteRegionDriver(s,e,r,n)}setOutputPackedMatrixWriteRegion(e,n,s,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&Jp(this.gl,this.program),ic(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const n=this.getVertexArray();console.assert(n===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}be(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),be(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=ac(this.gl,te().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(te().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),a=s.createQuery();return s.beginQuery(r.TIME_ELAPSED_EXT,a),a}const e=this.getQueryTimerExtensionWebGL1(),n=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,n),n}endQuery(){if(te().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const n=this.gl,s=this.getQueryTimerExtensionWebGL2();n.endQuery(s.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await Ww(()=>this.disposed||this.isQueryAvailable(e,te().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,te().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,n){if(n===0)return null;if(n===2){const s=this.gl;return s.getQueryParameter(e,s.QUERY_RESULT)/1e6}else{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(e,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,n){if(n===0)return!0;if(n===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),a=s.getQueryParameter(e,s.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),a&&!this.disjoint}else{const s=this.getQueryTimerExtensionWebGL1(),r=s.getQueryObjectEXT(e,s.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(n=>{this.addItemToPoll(()=>e.isFencePassed(),()=>n())})}pollItems(){const e=OQ(this.itemsToPoll.map(n=>n.isDoneFn));for(let n=0;n<=e;++n){const{resolveFn:s}=this.itemsToPoll[n];s()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,n){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:n}),this.itemsToPoll.length>1)return;let s;"setTimeoutCustom"in te().platform&&(s=te().platform.setTimeoutCustom.bind(te().platform)),Ww(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,s)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),ef(this.gl,e,this.framebuffer),this.debug&&ic(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(ef(this.gl,this.outputTexture,this.framebuffer),this.debug&&ic(this.gl)):u$(this.gl,this.framebuffer)}downloadMatrixDriver(e,n){this.bindTextureToFrameBuffer(e);const s=n();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(e,n,s){this.throwIfDisposed();const r=this.gl;ef(r,e,this.framebuffer),this.debug&&ic(r),this.outputTexture=e,be(r,()=>r.viewport(0,0,n,s)),be(r,()=>r.scissor(0,0,n,s))}setOutputMatrixWriteRegionDriver(e,n,s,r){this.throwIfDisposed(),be(this.gl,()=>this.gl.scissor(e,n,s,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function OQ(t){let e=0;for(;e<t.length&&t[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:FQ,bincountImpl:ME,bincountReduceImpl:zQ,bitwiseAndImpl:LQ,castImpl:PQ,ceilImpl:BQ,concatImpl:MQ,equalImpl:VQ,expImpl:WQ,expm1Impl:UQ,floorImpl:GQ,gatherNdImpl:HQ,gatherV2Impl:qQ,greaterImpl:jQ,greaterEqualImpl:KQ,lessImpl:XQ,lessEqualImpl:YQ,linSpaceImpl:ZQ,logImpl:QQ,maxImpl:JQ,maximumImpl:eJ,minimumImpl:tJ,multiplyImpl:nJ,negImpl:sJ,notEqualImpl:rJ,prodImpl:aJ,raggedGatherImpl:iJ,raggedRangeImpl:oJ,raggedTensorToTensorImpl:uJ,rangeImpl:lJ,rsqrtImpl:cJ,scatterImpl:dJ,sigmoidImpl:hJ,simpleAbsImpl:VE,sliceImpl:pJ,sparseFillEmptyRowsImpl:fJ,sparseReshapeImpl:mJ,sparseSegmentReductionImpl:WE,sqrtImpl:gJ,staticRegexReplaceImpl:yJ,stridedSliceImpl:bJ,stringNGramsImpl:xJ,stringSplitImpl:wJ,stringToHashBucketFastImpl:$J,subImpl:vJ,tileImpl:SJ,topKImpl:IJ,transposeImpl:w0,uniqueImpl:_J}=T8;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UE(t,e){return["x","y","z","w","u","v"].slice(0,e).map(n=>`${t}.${n}`)}function kn(t,e){return e===1?[t]:UE(t,e)}function kJ(t,e){if(t===1)return"rc";let n="";for(let s=0;s<t;s++)n+=e[s],s<t-1&&(n+=",");return n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CJ{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=$n(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const n=kn("rc",this.rank),s=yt(this.rank),r=this.getOutOfBoundsCondition(n),a=this.getSetup(n),i=this.getOutput(n);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${a}

            setOutput(vec4(${i}));
          }
        }
      `}}getSourceCoordsArr(e){const n=[];for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){let a=`${s===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let i=2;i<this.rank;i++)a=`${e[e.length-1-i]},`+a;n.push(a)}return n}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let n="";for(let s=this.rank-2;s<this.rank;s++)n+=`${e[s]} >= ${this.enableShapeUniforms?`outShape[${s}]`:this.outputShape[s]}`,s<this.rank-1&&(n+="||");return n}getSetup(e){if(this.rank===1)return"";const n=e.slice(-2),s=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${n[0]};
      int c = ${n[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${s};
      bool rEdge = rp1 >= ${r};
    `}getOutput(e){const n=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${n[0]}),
            cEdge ? 0. : getA(${n[1]}),
            rEdge ? 0. : getA(${n[2]}),
            rEdge || cEdge ? 0. : getA(${n[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GE{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=$n(this.outputShape.length);let s="";for(let r=0;r<4;r++){let a="thisRC = rc;";r%2===1&&(a+="thisRC.z += 1;"),r>1&&(a+="thisRC.y += 1;"),s+=`
        ${a}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${TJ(n,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?b0():y0(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${s}

        setOutput(result);
      }
    `}}function TJ(t,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?kZ(["r","c","d"],"inputShape"):vi(["r","c","d"],t)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NJ{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,n,s){const r=p$(n,s),a=f$(e,r,s);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);const i=h$(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();const u=this.freeTextures[a].pop();return this.usedTextures[a].push(u),u}let o;return r===cn.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===cn.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===cn.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===cn.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===cn.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[a].push(o),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),o}releaseTexture(e,n,s,r){if(this.freeTextures==null)return;const a=p$(s,r),i=f$(n,a,r);i in this.freeTextures||(this.freeTextures[i]=[]);const o=h$(n,a,this.gpgpu.gl,this.gpgpu.textureConfig,r),u=te().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");u!==-1&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=o):(this.freeTextures[i].push(e),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;const l=this.usedTextures[i],c=l&&l.indexOf(e);if(c==null||c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[c]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const n=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*n)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function EJ(t,e){const n=t;if(e===n.R32F)return 4;if(e===n.R16F)return 2;if(e===n.RGBA32F)return 16;if(e===t.RGBA)return 16;if(e===n.RGBA16F)return 8;if(e===n.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function h$(t,e,n,s,r){const a=AJ(e,s);let i;if(r){const[u,l]=yo(t[0],t[1]);i=u*l}else{const[u,l]=zl(t[0],t[1]);i=u*l}const o=EJ(n,a);return i*o}function AJ(t,e){switch(t){case cn.PACKED_2X2_FLOAT32:return PE(e);case cn.PACKED_2X2_FLOAT16:return BE(e);case cn.UNPACKED_FLOAT32:return FE(e);case cn.UNPACKED_FLOAT16:return zE(e);case cn.PACKED_4X1_UNSIGNED_BYTE:return LE(e);default:throw new Error(`Unknown physical texture type ${t}`)}}function RJ(t){return te().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?cn.PACKED_2X2_FLOAT32:cn.UNPACKED_FLOAT32:t?cn.PACKED_2X2_FLOAT16:cn.UNPACKED_FLOAT16}function p$(t,e){if(t===ns.UPLOAD)return cn.PACKED_2X2_FLOAT32;if(t===ns.RENDER||t==null)return RJ(e);if(t===ns.DOWNLOAD||t===ns.PIXELS)return cn.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${t}`)}function f$(t,e,n){return`${t[0]}_${t[1]}_${e}_${n}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lr{constructor(e,n){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=$n(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${n}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const Cs="if (isnan(x)) return x;",DJ="return x;",m$="return abs(x);",OJ="return (x >= 0.0) ? x : (exp(x) - 1.0);",FJ=Cs+`
  return (x < 0.0) ? 0.0 : x;
`,zJ=Cs+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Xr="return x;",LJ="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PJ="return x;",BJ=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,MJ=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,VJ=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,WJ="return 1.0 / (1.0 + exp(-1.0 * x));";class Qr{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=$n(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${n}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UJ{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=$n(this.outputShape.length);const n=e.length,s=kn("rc",n),r=yt(n),a=kJ(n,s),i=s.slice(-2),o=n<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${a});

        setOutput(getChannel(packedInput, ${o}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GJ=sb,HJ=1e-7,qJ=1e-4,lc={};function jJ(t){return t in lc||(lc[t]={}),lc[t]}const KJ=te().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),XJ=600;function YJ(){return te().global.screen==null?1024:te().global.screen.height*te().global.screen.width*window.devicePixelRatio*XJ/1024/1024}class lp extends gg{nextDataId(){return lp.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!te().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let n;if(e!=null){if(e instanceof sf)n=e;else{const s=Zs(te().getNumber("WEBGL_VERSION"),e);n=new sf(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=Zs(te().getNumber("WEBGL_VERSION"));n=new sf(s),this.binaryCache=jJ(te().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new NJ(this.gpgpu),this.numMBBeforeWarning=YJ(),this.texData=new fI(this,ar())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,n,s,r,a,i){const o=this.makeTensorInfo(n,s),u=this.texData.get(o.dataId);u.isPacked=!1,u.texture={texture:e,texShape:[r,a]},u.texShape=[r,a];const l=oc(n),c=new d$(l,!1,i),d=this.runWebGLProgram(c,[o],s,[[r,a]]);return d.shape=n,u.texture=null,this.disposeIntermediateTensorInfo(o),d.dataId}write(e,n,s){if((te().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||te().getBool("DEBUG"))&&this.checkNumericalProblems(e),s==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:n,dtype:s,values:e,usage:ns.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const n=this.texData.get(e);n.refCount++}decRef(e){if(this.texData.has(e)){const n=this.texData.get(e);n.refCount--}}move(e,n,s,r,a){if(te().getBool("DEBUG")&&this.checkNumericalProblems(n),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:r,values:n,usage:ns.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const n=this.texData.get(e),{values:s,dtype:r,complexTensorInfos:a,slice:i,shape:o,isPacked:u}=n;if(i!=null){let h;u?h=new Qr(o,Xr):h=new lr(o,Xr);const p=this.runWebGLProgram(h,[{dataId:e,shape:o,dtype:r}],r),f=this.readSync(p.dataId);return this.disposeIntermediateTensorInfo(p),f}if(s!=null)return this.convertAndCacheOnCPU(e);if(r==="string")return s;const l=this.activeTimers!=null;let c;l&&(c=Rn());let d;if(r==="complex64"){const h=this.readSync(a.real.dataId),p=this.readSync(a.imag.dataId);d=Rr(h,p)}else d=this.getValuesFromTexture(e);return l&&(this.downloadWaitMs+=Rn()-c),this.convertAndCacheOnCPU(e,d)}async read(e){if(this.pendingRead.has(e)){const f=this.pendingRead.get(e);return new Promise(m=>f.push(m))}const n=this.texData.get(e),{values:s,shape:r,slice:a,dtype:i,complexTensorInfos:o,isPacked:u}=n;if(a!=null){let f;u?f=new Qr(r,Xr):f=new lr(r,Xr);const m=this.runWebGLProgram(f,[{dataId:e,shape:r,dtype:i}],i),g=this.read(m.dataId);return this.disposeIntermediateTensorInfo(m),g}if(s!=null)return this.convertAndCacheOnCPU(e);if(te().getBool("DEBUG")&&!te().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&te().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l=null,c;if(i!=="complex64"&&te().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(e);const f=this.texData.get(c.dataId);l=this.gpgpu.createBufferFromTexture(f.texture.texture,...rc(r))}this.pendingRead.set(e,[]),i!=="complex64"&&await this.gpgpu.createAndWaitForFence();let d;if(i==="complex64"){const f=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),m=f[0],g=f[1];d=Rr(m,g)}else if(l==null)d=this.getValuesFromTexture(e);else{const f=se(r);d=this.gpgpu.downloadFloat32MatrixFromBuffer(l,f)}if(c!=null&&this.disposeIntermediateTensorInfo(c),l!=null){const f=this.gpgpu.gl;be(f,()=>f.deleteBuffer(l))}const h=this.convertAndCacheOnCPU(e,d),p=this.pendingRead.get(e);return this.pendingRead.delete(e),p.forEach(f=>f(h)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&ar().removeDataId(e,this),this.pendingDeletes--),h}readToGPU(e,n={}){const s=this.texData.get(e),{values:r,shape:a,slice:i,dtype:o,isPacked:u,texture:l}=s;if(o==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(i!=null){let p;u?p=new Qr(a,Xr):p=new lr(a,Xr);const f=this.runWebGLProgram(p,[{dataId:e,shape:a,dtype:o}],o),m=this.readToGPU(f,n);return this.disposeIntermediateTensorInfo(f),m}if(l==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const c=this.decode(e,n.customTexShape),d=ar().makeTensorFromTensorInfo(c),h=this.texData.get(c.dataId);return Object.assign({tensorRef:d},h.texture)}bufferSync(e){const n=this.readSync(e.dataId);if(e.dtype==="string")try{const s=n.map(r=>sa(r));return qe(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return qe(e.shape,e.dtype,n)}checkNumericalProblems(e){if(e!=null)for(let n=0;n<e.length;n++){const s=e[n];if(!JY(s))throw te().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:n,dtype:s,isPacked:r}=this.texData.get(e),a=se(n);if(te().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const h=this.decode(e),p=this.texData.get(h.dataId),f=this.gpgpu.downloadMatrixFromPackedTexture(p.texture.texture,...rc(n)).subarray(0,a);return this.disposeIntermediateTensorInfo(h),f}const i=te().getBool("WEBGL_PACK")&&r===!0,o=i?oc(n):n,u=i?new mQ(o):new fQ(o),l=this.runWebGLProgram(u,[{shape:o,dtype:s,dataId:e}],"float32"),c=this.texData.get(l.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(l),d}timerAvailable(){return te().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const n=this.activeTimers,s=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=s,r=!0):this.activeTimers.push(s),this.activeTimers=s,e();const a=Ja(this.activeTimers.map(u=>u.query)).filter(u=>u!=null),i=Ja(this.activeTimers.map(u=>u.name)).filter(u=>u!=null);this.activeTimers=n,r&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(te().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const u=await Promise.all(a);o.kernelMs=hz(u),o.getExtraProfileInfo=()=>u.map((l,c)=>({name:i[c],ms:l})).map(l=>`${l.name}: ${l.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return te().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Rn(),endMs:null}}endTimer(e){return te().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Rn(),e)}async getQueryTime(e){if(te().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const n=e;return n.endMs-n.startMs}disposeData(e,n=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(n?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!n&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return s!=null&&(this.disposeData(s.real.dataId,n),this.disposeData(s.imag.dataId,n)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:n,dtype:s,texShape:r,usage:a,isPacked:i,slice:o}=this.texData.get(e),u=o&&o.origDataId||e,l=this.dataRefCount.get(u);l>1?this.dataRefCount.set(u,l-1):(this.dataRefCount.delete(u),n!=null&&(this.numBytesInGPU-=this.computeBytes(r,s),this.textureManager.releaseTexture(n,r,a,i)));const c=this.texData.get(e);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,n=KJ){return te().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>this.texData.get(s.dataId).texture==null&&se(s.shape)<n)}getGPGPUContext(){return this.gpgpu}where(e){ts("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const n=e.dataSync();return GJ(e.shape,n)}packedUnaryOp(e,n,s){const r=new Qr(e.shape,n),a=this.compileAndRun(r,[e],s);return ar().makeTensorFromTensorInfo(a)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const r=VE(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,r)}if(te().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,m$,e.dtype);const n=new lr(e.shape,m$),s=this.compileAndRun(n,[e]);return ar().makeTensorFromTensorInfo(s)}makeTensorInfo(e,n,s){let r;if(n==="string"&&s!=null&&s.length>0&&wu(s[0])){const a=s.map(i=>ea(i));r=this.write(a,e,n)}else r=this.write(s,e,n);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:n}}makeOutput(e,n,s){return ar().makeTensorFromTensorInfo(this.makeTensorInfo(e,n,s),this)}unpackTensor(e){const n=new UJ(e.shape);return this.runWebGLProgram(n,[e],e.dtype)}packTensor(e){const n=new CJ(e.shape);return this.runWebGLProgram(n,[e],e.dtype,null,!0)}packedReshape(e,n){const s=[no(e.shape),...so(e.shape)],r={dtype:e.dtype,shape:s,dataId:e.dataId},a=[no(n),...so(n)],i=new GE(a,s),o=!0,u=[s],l=this.runWebGLProgram(i,[r],e.dtype,u,o);return{dataId:l.dataId,shape:n,dtype:l.dtype}}decode(e,n){const s=this.texData.get(e),{isPacked:r,shape:a,dtype:i}=s;if(n!=null){const h=se(a),p=n[0]*n[1]*4;O(h<=p,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const o=oc(a);let u;r?u=new pQ(o):u=new hQ(o);const l=!0,c=[n??rc(o)],d=this.runWebGLProgram(u,[{shape:o,dtype:i,dataId:e}],i,c,l,n);return{dtype:i,shape:a,dataId:d.dataId}}runWebGLProgram(e,n,s,r,a=!1,i){const o=this.makeTensorInfo(e.outputShape,s),u=this.texData.get(o.dataId);if(e.packedOutput&&(u.isPacked=!0),e.outPackingScheme===fu.DENSE){const y=i??rc(e.outputShape);u.texShape=y.map(b=>b*2)}if(e.outTexUsage!=null&&(u.usage=e.outTexUsage),se(o.shape)===0)return u.values=dn(o.dtype,0),o;const l=[],c=n.map(y=>{if(y.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let b=this.texData.get(y.dataId);if(b.texture==null){if(!e.packedInputs&&se(y.shape)<=te().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:y.shape,texData:null,isUniform:!0,uniformValues:b.values};e.packedInputs&&(b.isPacked=!0,b.shape=y.shape)}if(this.uploadToGPU(y.dataId),!!b.isPacked!=!!e.packedInputs)y=b.isPacked?this.unpackTensor(y):this.packTensor(y),l.push(y),b=this.texData.get(y.dataId);else if(b.isPacked&&!ud(b.shape,y.shape)){const $=y,w=y.shape;y.shape=b.shape,y=this.packedReshape(y,w),l.push(y),b=this.texData.get(y.dataId),$.shape=w}return{shape:y.shape,texData:b,isUniform:!1}});this.uploadToGPU(o.dataId);const d={shape:o.shape,texData:u,isUniform:!1},h=dQ(e,c,d),p=this.getAndSaveBinary(h,()=>lQ(this.gpgpu,e,c,d)),f=this.activeTimers!=null;let m;f&&(m=this.startTimer()),te().get("ENGINE_COMPILE_ONLY")||cQ(this.gpgpu,p,c,d,r),l.forEach(y=>this.disposeIntermediateTensorInfo(y)),f&&(m=this.endTimer(m),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(m)}));const g=te().getNumber("WEBGL_FLUSH_THRESHOLD");if(g>0){const y=Rn();y-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=y)}if(!te().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&a===!1){const y=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),y}return o}compileAndRun(e,n,s,r,a=!1){return s=s||n[0].dtype,this.runWebGLProgram(e,n,s,r,a)}getAndSaveBinary(e,n){return e in this.binaryCache||(this.binaryCache[e]=n()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(te().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(n=>{this.gpgpu.deleteProgram(this.binaryCache[n].webGLProgram),delete this.binaryCache[n]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=ee(()=>{if(!te().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=te().getBool("DEBUG");te().set("DEBUG",!1);const n=this.abs(Re(1e-8)).dataSync()[0];if(te().set("DEBUG",e),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?HJ:qJ}uploadToGPU(e){const n=this.texData.get(e),{shape:s,dtype:r,values:a,texture:i,usage:o,isPacked:u}=n;if(i!=null)return;const l=this.activeTimers!=null;let c;l&&(c=Rn());let d=n.texShape;if(d==null&&(d=yZ(s,u),n.texShape=d),a!=null){const h=oc(s);let p,f=d[1],m=d[0];const g=a instanceof Uint8Array||a instanceof Uint8ClampedArray;(u||!g)&&([f,m]=yo(d[0],d[1])),u?p=new yQ(h,g):p=new d$(h,g);const y=g?[m,f]:d,b=this.makeTensorInfo(y,r),$=this.texData.get(b.dataId);g?$.usage=ns.PIXELS:$.usage=ns.UPLOAD,$.texShape=y,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(b.dataId),f,m,a);const w=[[m,f]],k=this.runWebGLProgram(p,[b],r,w,!0),C=this.texData.get(k.dataId);n.texShape=C.texShape,n.isPacked=C.isPacked,n.usage=C.usage,te().get("ENGINE_COMPILE_ONLY")?this.disposeData(k.dataId):(n.texture=C.texture,n.values=null,this.texData.delete(k.dataId)),this.disposeIntermediateTensorInfo(b),l&&(this.uploadWaitMs+=Rn()-c)}else{const h=this.acquireTexture(d,o,r,u);n.texture=h}}convertAndCacheOnCPU(e,n){const s=this.texData.get(e),{dtype:r}=s;return n!=null&&(s.values=ZJ(n,r)),s.values}acquireTexture(e,n,s,r){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const a=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${a} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,n,r)}computeBytes(e,n){return e[0]*e[1]*Lc(n)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,n]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(n));return Promise.all(e)}else{for(const[,n]of Object.entries(this.binaryCache)){const s=new Promise(r=>{try{this.checkCompletion_(n),r(!0)}catch(a){throw a}});e.push(s)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await Tk(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(NE(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:n,customUniformLocations:s,infLoc:r,nanLoc:a,outShapeLocation:i,outShapeStridesLocation:o,outTexShapeLocation:u}=OE(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=n,e.customUniformLocations=s,e.infLoc=r,e.nanLoc=a,e.outShapeLocation=i,e.outShapeStridesLocation=o,e.outTexShapeLocation=u}}createTensorFromGPUData(e,n,s){e.channels=e.channels||"RGBA";const{texture:r,height:a,width:i,channels:o}=e,u=ar().backend;if(!u.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const l=u.writeTexture(r,n,s,a,i,o);return ar().makeTensorFromDataId(l,n,s,u)}}lp.nextDataId=0;function ZJ(t,e){if(e==="float32"||e==="complex64")return t;if(e==="int32"||e==="bool"){const n=e==="int32"?new Int32Array(t.length):new Uint8Array(t.length);for(let s=0;s<n.length;++s)n[s]=Math.round(t[s]);return n}else throw new Error(`Unknown dtype ${e}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */FI()&&PI("webgl",()=>new lp,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $0=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class di{constructor(e,n,s){this.variableNames=["A","B"],this.outputShape=We(n,s),this.enableShapeUniforms=$n(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ii=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class vo{constructor(e,n,s,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=We(n,s);const a=this.outputShape.length;this.enableShapeUniforms=$n(a);let i="";if(r)if(a===0||se(this.outputShape)===1)i=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(i=`
          ${yt(a)} coords = getOutputCoords();
        `,a===1)this.enableShapeUniforms?i+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:i+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const u=kn("coords",a);this.enableShapeUniforms?i+=`
            bool nextRowOutOfBounds =
              (${u[a-2]} + 1) >= outShape[${a} - 2];
            bool nextColOutOfBounds =
              (${u[a-1]} + 1) >= outShape[${a} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:i+=`
            bool nextRowOutOfBounds =
              (${u[a-2]} + 1) >= ${this.outputShape[a-2]};
            bool nextColOutOfBounds =
              (${u[a-1]} + 1) >= ${this.outputShape[a-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${i}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yn(t){const{inputs:e,backend:n}=t,{x:s}=e;return n.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const QJ={kernelName:Vu,backendName:"webgl",kernelFunc:Yn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _a(t){const{inputs:e,backend:n}=t,{real:s,imag:r}=e,a=n.makeTensorInfo(s.shape,"complex64"),i=n.texData.get(a.dataId),o=Yn({inputs:{x:s},backend:n}),u=Yn({inputs:{x:r},backend:n});return i.complexTensorInfos={real:o,imag:u},a}const JJ={kernelName:kg,backendName:"webgl",kernelFunc:_a};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HE="return (a < 0.) ? b * a : a;",qE=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function eee(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{alpha:a}=s,i=n.makeTensorInfo([],"float32",ma(a,"float32")),o=te().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new vo(qE,r.shape,i.shape):new di(HE,r.shape,i.shape),u=n.runWebGLProgram(o,[r,i],"float32");return n.disposeIntermediateTensorInfo(i),u}const tee={kernelName:Wd,backendName:"webgl",kernelFunc:eee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jE="return (a < 0.) ? b * a : a;",KE=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function nee(t){const{inputs:e,backend:n}=t,{x:s,alpha:r}=e,a=te().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new vo(KE,s.shape,r.shape):new di(jE,s.shape,r.shape);return n.runWebGLProgram(a,[s,r],"float32")}const see={kernelName:oh,backendName:"webgl",kernelFunc:nee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const So="if (isnan(x)) return x;";function it({opSnippet:t,packedOpSnippet:e,cpuKernelImpl:n,dtype:s}){return({inputs:r,backend:a})=>{const{x:i}=r,o=a,u=s||i.dtype;if(o.shouldExecuteOnCPU([i])&&n!=null){const d=o.texData.get(i.dataId),h=n(d.values,u);return o.makeTensorInfo(i.shape,u,h)}const l=te().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let c;return l?c=new Qr(i.shape,e):c=new lr(i.shape,t),o.runWebGLProgram(c,[i],u)}}function gn({opSnippet:t,packedOpSnippet:e,checkOutOfBounds:n=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:a}){return({inputs:i,backend:o})=>{const{a:u,b:l}=i,c=o;if(s&&u.dtype==="complex64"){const f=c.texData.get(u.dataId),m=c.texData.get(l.dataId),[g,y]=[[f.complexTensorInfos.real,m.complexTensorInfos.real],[f.complexTensorInfos.imag,m.complexTensorInfos.imag]].map($=>{const[w,v]=$,k={dataId:w.dataId,dtype:w.dtype,shape:u.shape},C={dataId:v.dataId,dtype:v.dtype,shape:l.shape},N=new di(t,u.shape,l.shape);return c.runWebGLProgram(N,[k,C],Hn(w.dtype,v.dtype))}),b=_a({inputs:{real:g,imag:y},backend:c});return c.disposeIntermediateTensorInfo(g),c.disposeIntermediateTensorInfo(y),b}const d=a||Hn(u.dtype,l.dtype);if((u.dtype==="string"||l.dtype==="string"||c.shouldExecuteOnCPU([u,l]))&&r!=null){const f=c.texData.get(u.dataId).values,m=c.texData.get(l.dataId).values,g=u.dtype==="string"?Dr(f):f,y=u.dtype==="string"?Dr(m):m,[b,$]=r(u.shape,l.shape,g,y,d),w=c.makeTensorInfo($,d),v=c.texData.get(w.dataId);return v.values=b,w}const h=te().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let p;return h?p=new vo(e,u.shape,l.shape,n):p=new di(t,u.shape,l.shape),c.runWebGLProgram(p,[u,l],d)}}function mu(t,e=!1){if(t==="linear")return e?PJ:DJ;if(t==="relu")return e?MJ:FJ;if(t==="elu")return e?BJ:OJ;if(t==="relu6")return e?VJ:zJ;if(t==="prelu")return e?KE:jE;if(t==="leakyrelu")return e?qE:HE;if(t==="sigmoid")return e?WJ:LJ;throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XE{constructor(e,n,s,r=!1,a=!1,i=!1,o=null,u=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=$n(this.outputShape.length);const c=r?e[1]:e[2],d=Math.ceil(c/2),h=r?"i * 2, rc.y":"rc.y, i * 2",p=a?"rc.z, i * 2":"i * 2, rc.z",f=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],m=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let g="",y="";o&&(u?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${o}
        }`:l?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${o}
        }`:g=`vec4 activation(vec4 x) {
          ${o}
        }`,y="result = activation(result);");const b=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let $="rc.x",w="rc.x";e[0]<n[0]?$=`imod(rc.x, ${e[0]})`:n[0]<e[0]&&(w=`imod(rc.x, ${n[0]})`),this.userCode=`
      ${g}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${d}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${$};
        int batchB = ${w};
        for (int i = 0; i < ${d}; i++) {
          vec4 a = getMatrixA(batchA, ${h});
          vec4 b = getMatrixB(batchB, ${p});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${f[0]} * ${m[0]});
          result += (${f[1]} * ${m[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${b}

        ${y}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g$={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class y${constructor(e,n,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=We(n,s),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b$="return a * b;";function v0(t){const{inputs:e,backend:n}=t,{a:s,b:r}=e,a=Hn(s.dtype,r.dtype);if(s.dtype==="complex64"){const o=n.texData.get(s.dataId),u=n.texData.get(r.dataId),l=new y$(g$.REAL,s.shape,r.shape),c=new y$(g$.IMAG,s.shape,r.shape),d=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:s.shape},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:r.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:r.shape}],h=n.runWebGLProgram(l,d,"float32"),p=n.runWebGLProgram(c,d,"float32"),f=_a({inputs:{real:h,imag:p},backend:n});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),f}if(n.shouldExecuteOnCPU([s,r])){const o=n.texData.get(s.dataId),u=n.texData.get(r.dataId),[l,c]=nJ(s.shape,r.shape,o.values,u.values,a),d=n.makeTensorInfo(c,a),h=n.texData.get(d.dataId);return h.values=l,d}let i;return te().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new vo(b$,s.shape,r.shape):i=new di(b$,s.shape,r.shape),n.runWebGLProgram(i,[s,r],a)}const ree={kernelName:Yu,backendName:"webgl",kernelFunc:v0};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aee(t,e,n){const s=[no(t.shape),...so(t.shape)],r={dtype:t.dtype,shape:s,dataId:t.dataId},a=[no(e),...so(e)],i=new GE(a,s),o=!0,u=[s],l=n.runWebGLProgram(i,[r],t.dtype,u,o);return{dataId:l.dataId,shape:e,dtype:l.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function me(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{shape:a}=s,i=n,o=se(r.shape),u=mI(a,o),l=se(u);O(o===l,()=>`The new shape (${u}) has ${l} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);const c=i.texData.get(r.dataId);return c.isPacked&&!ud(r.shape,u)&&!(c.texture!==null&&ud(c.shape,u))?aee(r,u,i):(i.incRef(r.dataId),{dataId:r.dataId,shape:u,dtype:r.dtype})}const iee={kernelName:lh,backendName:"webgl",kernelFunc:me};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class x${constructor(e,n){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:a,outSize:i}=e;this.outputShape=[r,i];const o=Math.floor(s/4)*4,u=s%4;let l="sumValue += dot(values, ones);";if(n!=null){const d=1/n;l=`sumValue += dot(values * ${qi(d)?d.toPrecision(2):d}, ones);`}let c="";a%s>0&&(c=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${o}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${o};
        if (${u===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${u===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${u===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oee{constructor(e,n){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:a,outSize:i}=e;this.outputShape=[r,i];let o="0.0",u="";n==="prod"?o="1.0":n==="min"?(o="1.0 / 1e-20",u="min"):n==="max"&&(o="-1.0 / 1e-20",u="max");let l=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="sum"?l="sumValue":n==="prod"?l="prodValue":n==="all"?l="allValue":n==="any"&&(l="anyValue");const c=Math.floor(s/4)*4,d=s%4;let h=`
      if (${n==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${n==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${u}(values, minMaxValue);
        if (${n==="min"} || ${n==="max"}) {
          minMaxValue = ${u}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,p="vec4";n==="all"?(o="1.0",h=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,p="bvec4"):n==="any"&&(o="0.0",h=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,p="bvec4");let f="";a%s>0&&(f=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${o};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${o});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${h}
        }

        int inIdx = inOffset + ${c};
        if (${d===1}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${h}
        } else if (${d===2}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${h}
        } else if (${d===3}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${h}
        }
        setOutput(${l});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uee(t){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const n=e.length?e[e.length-1].outSize:t[1],s=jh(n);e.push({inSize:n,windowSize:s,outSize:Math.ceil(n/s)})}return e}function _i(t,e,n,s){const r=uee(t.shape);let a=t;for(let i=0;i<r.length;i++){const{inSize:o,windowSize:u,outSize:l}=r[i];let c,d;n==="mean"?c=i===0?new x$({windowSize:u,inSize:o,batchSize:t.shape[0],outSize:l},o):new x$({windowSize:u,inSize:o,batchSize:t.shape[0],outSize:l}):c=new oee({windowSize:u,inSize:o,batchSize:t.shape[0],outSize:l},n),d=a,a=s.runWebGLProgram(c,[a],e),d.dataId!==t.dataId&&s.disposeIntermediateTensorInfo(d)}return a}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lee{constructor(e,n){this.variableNames=["A"];const s=new Array(e.length);for(let i=0;i<s.length;i++)s[i]=e[n[i]];this.outputShape=s,this.rank=s.length;const r=yt(this.rank),a=cee(n);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${a}));
    }
    `}}function cee(t){const e=t.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(e);for(let r=0;r<t.length;r++)s[t[r]]=n[r];return s.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dee{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(e.length);for(let c=0;c<s.length;c++)s[c]=e[n[c]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=yt(this.rank),a=UE("rc",this.rank),i=new Array(this.rank);for(let c=0;c<n.length;c++)i[n[c]]=a[c];const o=`vec2(${i.slice(-2).join()})`,u=`++${a[this.rank-1]} < ${s[this.rank-1]}`,l=`getChannel(getA(${i.join()}), ${o})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l};
      if(${u}) {
        result[1] = ${l};
      }
      --${a[this.rank-1]};
      if(++${a[this.rank-2]} < ${s[this.rank-2]}) {
        result[2] = ${l};
        if(${u}) {
          result[3] = ${l};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cp(t,e,n){const s=te().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new dee(t.shape,e):new lee(t.shape,e);return n.runWebGLProgram(s,[t],t.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hee(t,e,n,s){const r=e,a=t.shape.length,i=Ye(r,t.shape);let o=i;const u=At(o,a),l=u!=null;let c=t;l&&(c=cp(t,u,s),o=Pt(o.length,a)),fn("sum",o,a);const[d,h]=an(c.shape,o);let p=d;n&&(p=Lt(d,i));const f=se(h),g=se(t.shape)/f,y=me({inputs:{x:c},attrs:{shape:[g,f]},backend:s}),b=Iy(t.dtype),$=_i(y,b,"sum",s),w=me({inputs:{x:$},attrs:{shape:p},backend:s});return s.disposeIntermediateTensorInfo(y),s.disposeIntermediateTensorInfo($),l&&s.disposeIntermediateTensorInfo(c),w}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dp(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:a,keepDims:i}=s;return hee(r,a,i,n)}const pee={kernelName:mh,backendName:"webgl",kernelFunc:dp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tn(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{perm:a}=s,i=n,o=r.shape.length,u=new Array(o);for(let c=0;c<u.length;c++)u[c]=r.shape[a[c]];let l;if(i.shouldExecuteOnCPU([r])){const d=i.texData.get(r.dataId).values,h=w0(d,r.shape,r.dtype,a,u);l=i.makeTensorInfo(u,r.dtype);const p=i.texData.get(l.dataId);p.values=h}else l=cp(r,a,i);return l}const fee={kernelName:Mi,backendName:"webgl",kernelFunc:Tn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YE=1e3;function ld({a:t,b:e,transposeA:n,transposeB:s,backend:r,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:u=null}){const l=t.shape.length,c=e.shape.length,d=n?t.shape[l-2]:t.shape[l-1],h=s?e.shape[c-1]:e.shape[c-2],p=n?t.shape[l-1]:t.shape[l-2],f=s?e.shape[c-2]:e.shape[c-1],m=t.shape.slice(0,-2),g=e.shape.slice(0,-2),y=se(m),b=se(g),w=We(t.shape.slice(0,-2),e.shape.slice(0,-2)).concat([p,f]);O(d===h,()=>`Error in matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${t.shape} and ${e.shape} and transposeA=${n} and transposeB=${s} must match.`);const v=n?[y,d,p]:[y,p,d],k=s?[b,f,h]:[b,h,f],C=me({inputs:{x:t},backend:r,attrs:{shape:v}}),N=me({inputs:{x:e},backend:r,attrs:{shape:k}}),A=[C,N],I=Math.max(y,b),E=n?C.shape[1]:C.shape[2],z=a!=null,P=i!=null,H=u==="leakyrelu",G=u!=null?mu(u,!0):null,W=z||P||H||G!=null;let L;if((p===1||f===1)&&E>YE&&W===!1){let Y=C,ne=N;n&&(Y=Tn({inputs:{x:C},backend:r,attrs:{perm:[0,2,1]}}),A.push(Y)),s&&(ne=Tn({inputs:{x:N},backend:r,attrs:{perm:[0,2,1]}}),A.push(ne));const M=f!==1,Z=f===1;let J=Y;M&&(J=me({inputs:{x:Y},backend:r,attrs:{shape:[I,E,1]}}),A.push(J));const oe=f===1?2:1;let de=ne;Z&&(de=me({inputs:{x:ne},backend:r,attrs:{shape:[I,1,E]}}),A.push(de));const fe=v0({inputs:{a:J,b:de},backend:r});L=dp({inputs:{x:fe},backend:r,attrs:{axis:oe,keepDims:!0}}),A.push(fe)}else{const Y=Hn(t.dtype,e.dtype),ne=new XE(v,k,[I,p,f],n,s,z,G,P,H),M=[C,N];if(a!=null&&M.push(a),P&&M.push(i),H){const Z=r.makeTensorInfo([],"float32",ma(o,"float32"));M.push(Z),A.push(Z)}L=r.runWebGLProgram(ne,M,Y)}const B=me({inputs:{x:L},backend:r,attrs:{shape:w}});A.push(L);for(const Y of A)r.disposeIntermediateTensorInfo(Y);return B}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mee(t){const{inputs:e,backend:n,attrs:s}=t,{a:r,b:a,bias:i,preluActivationWeights:o}=e,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:d}=s;return ld({a:r,b:a,transposeA:u,transposeB:l,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:d,activation:c})}const gee={kernelName:Pc,backendName:"webgl",kernelFunc:mee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w$="return abs(x);";function yee(t){const{inputs:e,backend:n}=t,{x:s}=e;if(n.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const a=n.texData.get(s.dataId),i=VE(a.values);return n.makeTensorInfo(s.shape,s.dtype,i)}let r;return te().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new Qr(s.shape,w$):r=new lr(s.shape,w$),n.runWebGLProgram(r,[s],s.dtype)}const bee={kernelName:wd,backendName:"webgl",kernelFunc:yee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xee=Cs+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,wee=it({opSnippet:xee}),$ee={kernelName:$u,backendName:"webgl",kernelFunc:wee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vee=Cs+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,See=it({opSnippet:vee}),Iee={kernelName:vu,backendName:"webgl",kernelFunc:See};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $$="return a + b;",_ee=gn({opSnippet:$$,packedOpSnippet:$$,supportsComplex:!0,cpuKernelImpl:FQ}),kee={kernelName:lo,backendName:"webgl",kernelFunc:_ee};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Cee{constructor(e,n){this.outputShape=[],this.outputShape=e,this.variableNames=n.map((a,i)=>`T${i}`);const s=[];this.variableNames.forEach(a=>{s.push(`float v${a} = get${a}AtOutCoords();`)});const r=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Tee{constructor(e,n){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=n.map((a,i)=>`T${i}`);const s=[];this.variableNames.forEach(a=>{s.push(`vec4 v${a} = get${a}AtOutCoords();`)});const r=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oc(t){const{inputs:e,backend:n}=t,s=e;if(s.length===1)return Yn({inputs:{x:s[0]},backend:n});if(s.length>te().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const u=Math.floor(s.length/2),l=Oc({inputs:s.slice(0,u),backend:n}),c=Oc({inputs:s.slice(u),backend:n});return Oc({inputs:[l,c],backend:n})}const r=s.map(u=>u.dtype).reduce((u,l)=>Hn(u,l)),a=s.map(u=>u.shape),o=te().getBool("WEBGL_PACK")?new Tee(s[0].shape,a):new Cee(s[0].shape,a);return n.runWebGLProgram(o,s,r)}const Nee={kernelName:$d,backendName:"webgl",kernelFunc:Oc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eee(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:a,keepDims:i}=s,o=r.shape.length,u=Ye(a,r.shape);let l=u;const c=At(l,o);let d=r;c!=null&&(d=Tn({inputs:{x:r},backend:n,attrs:{perm:c}}),l=Pt(l.length,o)),fn("all",l,o);const[h,p]=an(d.shape,l),f=se(p),m=me({inputs:{x:d},backend:n,attrs:{shape:[-1,f]}}),g=_i(m,m.dtype,"all",n);let y;if(i){const b=Lt(h,u);y=me({inputs:{x:g},backend:n,attrs:{shape:b}})}else y=me({inputs:{x:g},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),c!=null&&n.disposeIntermediateTensorInfo(d),y}const Aee={kernelName:wg,backendName:"webgl",kernelFunc:Eee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ree(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:a,keepDims:i}=s,o=r.shape.length,u=Ye(a,r.shape);let l=u;const c=At(l,o);let d=r;c!=null&&(d=Tn({inputs:{x:r},backend:n,attrs:{perm:c}}),l=Pt(l.length,o)),fn("any",l,o);const[h,p]=an(d.shape,l),f=se(p),m=me({inputs:{x:d},backend:n,attrs:{shape:[-1,f]}}),g=_i(m,m.dtype,"any",n);let y;if(i){const b=Lt(h,u);y=me({inputs:{x:g},backend:n,attrs:{shape:b}})}else y=me({inputs:{x:g},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),c!=null&&n.disposeIntermediateTensorInfo(d),y}const Dee={kernelName:$g,backendName:"webgl",kernelFunc:Ree};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Oee{constructor(e,n,s){this.variableNames=["A"];const{windowSize:r,batchSize:a,outSize:i}=e;s||this.variableNames.push("bestIndicesA"),this.outputShape=[a,i];const o=n==="max"?">":"<",u=s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${u};
          float candidate = getA(batch, inIdx);
          if (candidate ${o} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fee{constructor(e,n,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,O(e.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const a=e[e.length-1],i=Math.ceil(a/n);this.outputShape=e.slice(0,-1),i>1&&this.outputShape.push(i),r||this.variableNames.push("bestIndicesA");const o=this.outputShape,u=o.length,l=yt(u),c=kn("coords",u);let d,h;if(i===1){h=u+1;const N=yt(h);d=`
        ${N} sourceLocR = ${N}(${c.join()}, 0);
        ++${c[u-1]};
        ${N} sourceLocG = ${N}(${c.join()}, 0);
        ++${c[u-2]};
        ${N} sourceLocA = ${N}(${c.join()}, 0);
        --${c[u-1]};
        ${N} sourceLocB = ${N}(${c.join()}, 0);
        --${c[u-2]};`}else h=u,d=`
        ${l} sourceLocR = coords;
        ++${c[u-1]};
        ${l} sourceLocG = coords;
        ++${c[u-2]};
        ${l} sourceLocA = coords;
        --${c[u-1]};
        ${l} sourceLocB = coords;
        --${c[u-2]};`;const p=["x","y","z","w","u","v"].slice(0,h),f="."+p[h-1],m=p.map(N=>"int "+N),g=kn("sourceLocR",h-1).concat("inIdx.r"),y=kn("sourceLocG",h-1).concat("inIdx.g"),b=kn("sourceLocB",h-1).concat("inIdx.b"),$=kn("sourceLocA",h-1).concat("inIdx.a"),w=s==="max"?"greaterThan":"lessThan",v=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${$.join()})));`,k=`vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${y.join()}) : 0.,
            hasNextRow ? getAChannel(${b.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${$.join()}) : 0.)`,C=r?"":`
      float getBestIndicesAChannel(${m.join()}) {
        return getChannel(getBestIndicesA(${p.join()}),
                                          vec2(${p.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${m.join()}) {
        return getChannel(getA(${p.join()}),
                               vec2(${p.slice(-2).join()}));
      }
      ${C}
      void main() {
        ${l} coords = getOutputCoords();
        bool hasNextCol = ${c[u-1]} < ${o[u-1]-1};
        bool hasNextRow = ${c[u-2]} < ${o[u-2]-1};
        ${d}
        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},
          sourceLocB${f}, sourceLocA${f}) * ${n};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${k};

        for (int i = 0; i < ${n}; i++) {
          inIdx = srcIdx;
          ${v}
          vec4 candidate = ${k};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${w}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZE(t,e,n,s=null){let r=e.shape[0],a=e.shape[1];s!=null&&(r=s.shape[0],a=s.shape[1]);const i=jh(a),o={windowSize:i,inSize:a,batchSize:r,outSize:Math.ceil(a/i)},u=new Oee(o,n,s==null),l=[e];s!=null&&l.push(s);const c=t.runWebGLProgram(u,l,"int32");if(c.shape[1]===1)return c;const d=ZE(t,e,n,c);return t.disposeIntermediateTensorInfo(c),d}function QE(t,e,n,s=null){const r=s!=null?s.shape:e.shape,a=r[r.length-1],i=jh(a),o=new Fee(r,i,n,s==null),u=s==null?[e]:[e,s],l=t.runWebGLProgram(o,u,"int32");if(l.shape.length===e.shape.length){const c=QE(t,e,n,l);return t.disposeIntermediateTensorInfo(l),c}return l}function JE(t,e,n,s){const r=[n];if(fn("arg"+s.charAt(0).toUpperCase()+s.slice(1),r,e.shape.length),!te().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const a=[],i=t.texData.get(e.dataId),o=i!==null&&i.isPacked;let u=e;o&&(u=t.unpackTensor(e),a.push(u));const[l,c]=an(u.shape,r),d=se(c),h=me({inputs:{x:u},backend:t,attrs:{shape:[-1,d]}});a.push(h);const p=ZE(t,h,s);a.push(p);const f=me({inputs:{x:p},backend:t,attrs:{shape:l}});return a.forEach(m=>t.disposeIntermediateTensorInfo(m)),f}return QE(t,e,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zee(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:a}=s;let i=Ye(a,r.shape);const o=At(i,r.shape.length);let u=r;const l=[];o!=null&&(u=Tn({inputs:{x:r},backend:n,attrs:{perm:o}}),l.push(u),i=Pt(i.length,u.shape.length)),fn("argMax",[i[0]],u.shape.length);const c=JE(n,u,i[0],"max");return l.forEach(d=>n.disposeIntermediateTensorInfo(d)),c}const Lee={kernelName:vd,backendName:"webgl",kernelFunc:zee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pee(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:a}=s;let i=Ye(a,r.shape);const o=At(i,r.shape.length);let u=r;const l=[];o!=null&&(u=Tn({inputs:{x:r},backend:n,attrs:{perm:o}}),l.push(u),i=Pt(i.length,u.shape.length)),fn("argMin",[i[0]],u.shape.length);const c=JE(n,u,i[0],"min");return l.forEach(d=>n.disposeIntermediateTensorInfo(d)),c}const Bee={kernelName:Sd,backendName:"webgl",kernelFunc:Pee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mee=Cs+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,Vee=it({opSnippet:Mee}),Wee={kernelName:Su,backendName:"webgl",kernelFunc:Vee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uee=Cs+"return log(x + sqrt(x * x + 1.0));",Gee=it({opSnippet:Uee}),Hee={kernelName:Iu,backendName:"webgl",kernelFunc:Gee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qee=Cs+`
  return atan(x);
`,jee=it({opSnippet:qee}),Kee={kernelName:_u,backendName:"webgl",kernelFunc:jee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xee=$0+`
  return atan(a, b);
`,Yee=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Ii+`
  return result;
`,Zee=gn({opSnippet:Xee,packedOpSnippet:Yee}),Qee={kernelName:Cu,backendName:"webgl",kernelFunc:Zee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jee=Cs+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,ete=it({opSnippet:Jee}),tte={kernelName:ku,backendName:"webgl",kernelFunc:ete};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gu{constructor(e,n,s,r=!1,a=!1){if(this.variableNames=["x"],n==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const i=e.filterWidth,o=e.strideHeight,u=e.strideWidth,l=e.dilationHeight,c=e.dilationWidth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,p=e.padInfo.top,f=e.padInfo.left;this.outputShape=e.outShape;const m=n==="avg",g=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,y=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let b="0.0";if(m||(b="-1.0 / 1e-20"),s){this.userCode=`
        const ivec2 strides = ivec2(${o}, ${u});
        const ivec2 pads = ivec2(${p}, ${f});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${d};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${h};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value >= currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?a?g:y:`wR * ${h} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const $="max";let w=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(w="avgValue / max(count, 1.0)");const v=Math.floor(i/4)*4,k=i%4,C=`
      if (${m}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${$}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${u});
      const ivec2 pads = ivec2(${p}, ${f});
      const float initializationValue = ${b};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${d};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${v}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${C}
          }

          int xC = xCCorner + ${v};
          if (${k===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${C}
          } else if (${k===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${C}
          } else if (${k===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${C}
          }
        }
        setOutput(${w});
      }
    `}}class S0{constructor(e,n,s,r=!1,a=!1){if(this.variableNames=["x"],n==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const i=e.filterWidth,o=e.strideDepth,u=e.strideHeight,l=e.strideWidth,c=e.dilationDepth,d=e.dilationHeight,h=e.dilationWidth,p=e.effectiveFilterDepth,f=e.effectiveFilterHeight,m=e.effectiveFilterWidth,g=e.padInfo.front,y=e.padInfo.top,b=e.padInfo.left;this.outputShape=e.outShape;const $=n==="avg";let w="0.0";if($||(w="-1.0 / 1e-20"),s){this.userCode=`
        const ivec3 strides =
            ivec3(${o}, ${u}, ${l});
        const ivec3 pads = ivec3(${g}, ${y}, ${b});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${p};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${f};
                wR += ${d}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${m};
                  wC += ${h}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value >= currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?a?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${f} * ${m} +
                      wR * ${m} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const v="max";let k=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(k="avgValue / max(count, 1.0)");const C=Math.floor(i/4)*4,N=i%4,A=`
      if (${$}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${v}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${o}, ${u}, ${l});
      const ivec3 pads = ivec3(${g}, ${y}, ${b});
      const float initializationValue = ${w};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${w});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f};
            wR += ${d}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${C}; wC += 4) {
              int xC = xCCorner + wC * ${h};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                getValue(batch, xD, xR, xC + 2 * ${h}, ch),
                getValue(batch, xD, xR, xC + 3 * ${h}, ch)
              );

              ${A}
            }

            int xC = xCCorner + ${C};
            if (${N===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${A}
            } else if (${N===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                initializationValue,
                initializationValue
              );

              ${A}
            } else if (${N===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                getValue(batch, xD, xR, xC + 2 * ${h}, ch),
                initializationValue
              );

              ${A}
            }
          }
        }
        setOutput(${k});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nte(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e;Ll(r,"avgPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=s,l=1;O(pn(i,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);const c=_s(r.shape,a,i,l,o,u);if(c.filterWidth===1&&c.filterHeight===1&&tt(c.inShape,c.outShape))return Yn({inputs:{x:r},backend:n});const d=new gu(c,"avg",!1);return n.runWebGLProgram(d,[r],"float32")}const ste={kernelName:Id,backendName:"webgl",kernelFunc:nte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rte(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{filterSize:a,strides:i,pad:o,dimRoundingMode:u,dataFormat:l}=s,c=[1,1,1],d=Or(r.shape,a,i,c,o,u,l),h=new S0(d,"avg",!1);return n.runWebGLProgram(h,[r],"float32")}const ate={kernelName:_d,backendName:"webgl",kernelFunc:rte};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ite{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const n=e.filterHeight,s=e.filterWidth,r=e.strideHeight,a=e.strideWidth,i=e.dilationHeight,o=e.dilationWidth,u=e.effectiveFilterHeight,l=e.effectiveFilterWidth,c=u-1-e.padInfo.top,d=l-1-e.padInfo.left,h=1/(n*s);this.userCode=`
      const ivec2 pads = ivec2(${c}, ${d});
      const float avgMultiplier = float(${h});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${u};
            wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${o}) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class ote{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const n=e.filterDepth,s=e.filterHeight,r=e.filterWidth,a=e.strideDepth,i=e.strideHeight,o=e.strideWidth,u=e.dilationDepth,l=e.dilationHeight,c=e.dilationWidth,d=e.effectiveFilterDepth,h=e.effectiveFilterHeight,p=e.effectiveFilterWidth,f=d-1-e.padInfo.front,m=h-1-e.padInfo.top,g=p-1-e.padInfo.left,y=1/(n*s*r);this.userCode=`
      const ivec3 pads = ivec3(${f}, ${m}, ${g});
      const float avgMultiplier = float(${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${u}) {
          float dyD = float(dyDCorner + wD) / ${a}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${h};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${p};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ute(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:a}=e,i=a,{filterSize:o,strides:u,pad:l,dimRoundingMode:c}=s,d=[1,1,1],h=Or(i.shape,o,u,d,l,c),p=new ote(h);return n.runWebGLProgram(p,[r],i.dtype)}const lte={kernelName:Sg,backendName:"webgl",kernelFunc:ute};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cte(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:a}=e,i=a;Ll([r,a],"avgPoolGrad");const{filterSize:o,strides:u,pad:l}=s,c=_s(i.shape,o,u,1,l),d=new ite(c);return n.runWebGLProgram(d,[r],i.dtype)}const dte={kernelName:vg,backendName:"webgl",kernelFunc:cte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hte(t){const{inputs:e,backend:n,attrs:s}=t,{a:r,b:a}=e,{transposeA:i,transposeB:o}=s;return ld({a:r,b:a,transposeA:i,transposeB:o,backend:n})}const pte={kernelName:kd,backendName:"webgl",kernelFunc:hte};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fte{constructor(e,n,s,r,a,i){this.outputShape=[],this.variableNames=["x","mean","variance"],We(e,n),We(e,s);let o="0.0";r!=null&&(We(e,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let u="1.0";a!=null&&(We(e,a),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${o};
        float scale = ${u};
        float inv = scale * inversesqrt(variance + float(${i}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mte{constructor(e,n,s,r,a,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],We(e,n),We(e,s);let o="vec4(0.0)";r!=null&&(We(e,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let u="vec4(1.0)";a!=null&&(We(e,a),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${o};
        vec4 scale = ${u};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${i}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gte=({inputs:t,backend:e,attrs:n})=>{const{x:s,mean:r,variance:a,offset:i,scale:o}=t;O(r.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),O(i==null||r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),O(o==null||r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=n;u==null&&(u=.001);const l=[s,r,a];let c=null;i!=null&&(c=i.shape,l.push(i));let d=null;o!=null&&(d=o.shape,l.push(o));const h=te().getBool("WEBGL_PACK_NORMALIZATION")?new mte(s.shape,r.shape,a.shape,c,d,u):new fte(s.shape,r.shape,a.shape,c,d,u);return e.runWebGLProgram(h,l,l[0].dtype)},yte={kernelName:Bd,backendName:"webgl",kernelFunc:gte};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bte{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const n=yt(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=xte(this.rank);let r;const a=e.map((i,o)=>`sourceLoc.${Zm[o]} = start[${o}] + coords.${Zm[o]};`);r=`
        ${n} sourceLoc;
        ${n} coords = getOutputCoords();
        ${a.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${s}));
      }
    `}}const Zm=["x","y","z","w","u","v"];function xte(t){if(t===1)return"sourceLoc";if(t<=6)return Zm.slice(0,t).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wte{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=yt(this.rank),s=kn("coords",this.rank),r=kn("sourceLoc",this.rank),a=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,i=`getChannel(getSource(${r.join()}), ${a})`,o=`
      result.x = ${i};
      if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${i};
        --${r[this.rank-1]};
      }
    `,u=this.rank===1?"":`
      --${s[this.rank-1]};
      if (++${s[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${i};
        if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${i};
        }
      }
    `,l=this.rank<=4?`sourceLoc = coords +
            ${n}(${e.map((c,d)=>`start[${d}]`).join()});`:e.map((c,d)=>`${r[d]} = ${s[d]} + start[${d}];`).join(`
`);this.userCode=`
      void main() {
        ${n} coords = getOutputCoords();
        ${n} sourceLoc;
        ${l}
        vec4 result = vec4(0.);
        ${o}
        ${u}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $te(t,e,n,s){const r=s.texData.get(t.dataId),a=s.makeTensorInfo(n,t.dtype),i=s.texData.get(a.dataId);Object.assign(i,r),i.refCount=1,i.shape=n,i.dtype=t.dtype;let o=yb(e,Ae(t.shape));r.slice&&(o+=r.slice.flatOffset),i.slice={flatOffset:o,origDataId:r.slice&&r.slice.origDataId||t.dataId};const u=s.dataRefCount.get(i.slice.origDataId)||1;return s.dataRefCount.set(i.slice.origDataId,u+1),a}function Io(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{begin:a,size:i}=s,[o,u]=qh(r,a,i);if(fb(r,o,u),se(u)===0)return n.makeTensorInfo(u,r.dtype,[]);if(n.shouldExecuteOnCPU([r])||r.dtype==="string"){const d=n.texData.get(r.dataId),h=pJ(d.values,o,u,r.shape,r.dtype);return n.makeTensorInfo(u,r.dtype,h)}const{isPacked:l}=n.texData.get(r.dataId),c=gb(r.shape,o,u);if(l||!c){const d=te().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new wte(u):new bte(u),h=[o];return n.runWebGLProgram(d,[r],r.dtype,h)}return n.uploadToGPU(r.dataId),$te(r,o,u,n)}const vte={kernelName:fh,backendName:"webgl",kernelFunc:Io};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ste=t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockShape:a,crops:i}=s;O(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const o=a.reduce((b,$)=>b*$),u=Il(r.shape,a,o),l=_l(u.length,a.length),c=kl(r.shape,a,o),d=vb(i,a.length),h=Sb(c,i,a.length),p=[],f=me({inputs:{x:r},backend:n,attrs:{shape:u}}),m=Tn({inputs:{x:f},backend:n,attrs:{perm:l}}),g=me({inputs:{x:m},backend:n,attrs:{shape:c}}),y=Io({inputs:{x:g},backend:n,attrs:{begin:d,size:h}});return p.push(f),p.push(m),p.push(g),p.forEach(b=>n.disposeIntermediateTensorInfo(b)),y},Ite={kernelName:Cd,backendName:"webgl",kernelFunc:Ste};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _te(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,weights:a}=e,{size:i}=s,o=n.readSync(r.dataId),u=n.readSync(a.dataId),l=ME(o,u,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,l)}const kte={kernelName:Ig,backendName:"webgl",kernelFunc:_te};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cte=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,Tte=`
  return float(int(a.r) & int(b.r));
`;function Nte(t){const{inputs:e,backend:n}=t,{a:s,b:r}=e,a=te().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=te().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([s,r])||i===1){const u=n.texData.get(s.dataId).values,l=n.texData.get(r.dataId).values,[c,d]=LQ(s.shape,r.shape,u,l,s.dtype),h=n.makeTensorInfo(d,s.dtype),p=n.texData.get(h.dataId);return p.values=c,h}let o;return a?o=new vo(Cte,s.shape,r.shape,!1):o=new di(Tte,s.shape,r.shape),n.runWebGLProgram(o,[s,r],s.dtype)}const Ete={kernelName:Td,backendName:"webgl",kernelFunc:Nte};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ate(t){const{inputs:e,backend:n}=t,{s0:s,s1:r}=e,a=n.readSync(s.dataId),i=n.readSync(r.dataId),o=We(Array.from(a),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const Rte={kernelName:_g,backendName:"webgl",kernelFunc:Ate};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dte="return float(a != b);",eA=gn({opSnippet:Dte,cpuKernelImpl:rJ,dtype:"bool"}),Ote={kernelName:nh,backendName:"webgl",kernelFunc:eA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bl(t){const{inputs:e,backend:n}=t,{input:s}=e,r=n.texData.get(s.dataId);return Yn({inputs:{x:r.complexTensorInfos.real},backend:n})}const Fte={kernelName:ry,backendName:"webgl",kernelFunc:Bl};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zte="return float(int(x));";function Lte(t,e){const n=new lr(t.shape,zte),s=e.runWebGLProgram(n,[t],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qm(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{dtype:a}=s;if(a==="complex64"){if(r.dtype==="complex64")return Yn({inputs:{x:r},backend:n});const i=Gt(r.shape),o=Qm({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),u=_a({inputs:{real:o,imag:i},backend:n});return i.dispose(),n.disposeIntermediateTensorInfo(o),u}if(r.dtype==="complex64"){const i=Bl({inputs:{input:r},backend:n}),o=Qm({inputs:{x:i},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(i),o}if(!gI(r.dtype,a)){const i=Yn({inputs:{x:r},backend:n});return{dataId:i.dataId,shape:i.shape,dtype:a}}if(n.shouldExecuteOnCPU([r])){const i=n.texData.get(r.dataId).values,[o,u,l]=PQ(i,r.shape,r.dtype,a);return n.makeTensorInfo(o,u,l)}if(a==="int32")return Lte(r,n);if(a==="bool"){const i=n.makeTensorInfo([],"bool",dn("bool",1)),u=eA({inputs:{a:r,b:i},backend:n});return n.disposeIntermediateTensorInfo(i),u}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${a}`)}const Pte={kernelName:Tu,backendName:"webgl",kernelFunc:Qm};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v$="return ceil(x);",Bte=it({opSnippet:v$,packedOpSnippet:v$,cpuKernelImpl:BQ}),Mte={kernelName:Nu,backendName:"webgl",kernelFunc:Bte};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vte{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wte{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ute(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{clipValueMin:a,clipValueMax:i}=s;let o;te().getBool("WEBGL_PACK_CLIP")?o=new Wte(r.shape):o=new Vte(r.shape);const u=[[a],[i]];return n.runWebGLProgram(o,[r],r.dtype,u)}const Gte={kernelName:Eu,backendName:"webgl",kernelFunc:Ute};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hte{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S$(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}function qte(t){const{inputs:e,backend:n}=t,{x:s}=e,r=n.texData.get(s.dataId),a=new Hte(s.shape),i=[S$(s,r.complexTensorInfos.real),S$(s,r.complexTensorInfos.imag)];return n.runWebGLProgram(a,i,i[0].dtype)}const jte={kernelName:Nd,backendName:"webgl",kernelFunc:qte};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Kte{constructor(e){this.outputShape=[],this.outputShape=hr(e,1),this.variableNames=e.map((i,o)=>`T${o}`);const n=new Array(e.length-1);n[0]=e[0][1];for(let i=1;i<n.length;i++)n[i]=n[i-1]+e[i][1];const s=[`if (yC < ${n[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<n.length;i++){const o=n[i-1];s.push(`else if (yC < ${n[i]}) setOutput(getT${i}(yR, yC-${o}));`)}const r=n.length,a=n[n.length-1];s.push(`else setOutput(getT${r}(yR, yC-${a}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xte{constructor(e,n){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=hr(e,n);const s=this.outputShape,r=s.length,a=yt(r),i=kn("coords",r),o=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((m,g)=>`T${g}`);const u=new Array(e.length-1);u[0]=e[0][n];for(let m=1;m<u.length;m++)u[m]=u[m-1]+e[m][n];const l=o[n],c=o.slice(-2),d=o.join();let h=`if (${l} < ${u[0]}) {
        return getChannel(
            getT0(${d}), vec2(${c.join()}));
        }`;for(let m=1;m<u.length;m++){const g=u[m-1];h+=`
        if (${l} < ${u[m]}  && ${l} >= ${u[m-1]}) {
          return getChannel(
            getT${m}(${cc(o,l,g)}),
            vec2(${cc(c,l,g)}));
        }`}const p=u.length,f=u[u.length-1];h+=`
        return getChannel(
          getT${p}(${cc(o,l,f)}),
          vec2(${cc(c,l,f)}));`,this.userCode=`
      float getValue(${o.map(m=>"int "+m)}) {
        ${h}
      }

      void main() {
        ${a} coords = getOutputCoords();
        vec4 result = vec4(getValue(${i}), 0., 0., 0.);

        ${i[r-1]} = ${i[r-1]} + 1;
        if (${i[r-1]} < ${s[r-1]}) {
          result.g = getValue(${i});
        }

        ${i[r-2]} = ${i[r-2]} + 1;
        if (${i[r-2]} < ${s[r-2]}) {
          result.a = getValue(${i});
        }

        ${i[r-1]} = ${i[r-1]} - 1;
        if (${i[r-2]} < ${s[r-2]} &&
            ${i[r-1]} < ${s[r-1]}) {
          result.b = getValue(${i});
        }
        setOutput(result);
      }
    `}}function cc(t,e,n){const s=t.indexOf(e);return t.map((a,i)=>i===s?`${a} - ${n}`:a).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hp(t){const{inputs:e,backend:n}=t,{input:s}=e,r=n.texData.get(s.dataId);return Yn({inputs:{x:r.complexTensorInfos.imag},backend:n})}const Yte={kernelName:Gg,backendName:"webgl",kernelFunc:hp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xo(t,e,n){const s=t[0].dtype;if(s==="complex64"){const p=t.map(b=>Bl({inputs:{input:b},backend:n})),f=t.map(b=>hp({inputs:{input:b},backend:n})),m=Xo(p,e,n),g=Xo(f,e,n),y=_a({inputs:{real:m,imag:g},backend:n});return p.forEach(b=>n.disposeIntermediateTensorInfo(b)),f.forEach(b=>n.disposeIntermediateTensorInfo(b)),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),y}let r=n.shouldExecuteOnCPU(t);if(s==="string"&&(r=!0),r){const p=t.map(w=>{const k=[-1,se(w.shape.slice(e))];return me({inputs:{x:w},backend:n,attrs:{shape:k}})}),f=p.map(w=>({vals:n.readSync(w.dataId),shape:w.shape})),m=hr(p.map(w=>w.shape),1),g=p[0].shape[0]===1,y=MQ(f,m,s,g),b=hr(t.map(w=>w.shape),e),$=n.makeTensorInfo(b,s,y);return p.forEach(w=>n.disposeIntermediateTensorInfo(w)),$}const a=t.filter(p=>se(p.shape)>0),i=te().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&a[0].shape.length>1;if(a.length===1){const p=i?new lr(t[0].shape,Xr):new Qr(t[0].shape,Xr);return n.runWebGLProgram(p,t,s)}const o=te().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(a.length>o){const p=[];for(let m=0;m<a.length;m+=o){const g=a.slice(m,m+o);p.push(Xo(g,e,n))}const f=Xo(p,e,n);for(const m of p)n.disposeIntermediateTensorInfo(m);return f}if(i){const p=new Xte(a.map(f=>f.shape),e);return n.runWebGLProgram(p,a,s)}const{tensors2D:u,outShape:l}=Zte(a,e,n),c=new Kte(u.map(p=>p.shape)),d=n.runWebGLProgram(c,u,s);u.forEach(p=>n.disposeIntermediateTensorInfo(p));const h=me({inputs:{x:d},attrs:{shape:l},backend:n});return n.disposeIntermediateTensorInfo(d),h}function Zte(t,e,n){const s=hr(t.map(a=>a.shape),e);return{tensors2D:t.map(a=>me({inputs:{x:a},attrs:{shape:[-1,se(a.shape.slice(e))]},backend:n})),outShape:s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tA(t){const{inputs:e,backend:n,attrs:s}=t,{axis:r}=s,a=Ye(r,e[0].shape)[0],i=e.map(l=>l.shape);xb(i,a);const o=hr(e.map(l=>l.shape),a);if(se(o)===0)return n.makeTensorInfo(o,e[0].dtype,[]);const u=e.filter(l=>se(l.shape)>0);return u.length===1?Yn({inputs:{x:u[0]},backend:n}):Xo(u,a,n)}const Qte={kernelName:Ed,backendName:"webgl",kernelFunc:tA};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nA{constructor(e,n=!1,s=null,r=!1,a=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const i=e.padInfo.top,o=e.padInfo.left,u=e.strideHeight,l=e.strideWidth,c=e.dilationHeight,d=e.dilationWidth,h=e.filterHeight,p=e.filterWidth,f=Math.floor(e.inChannels/4)*4,m=e.inChannels%4,g=e.dataFormat==="channelsLast",y=g?1:2,b=g?2:3,$=g?3:1;let w="",v="";s&&(r?w=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:a?w=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:w=`
          float activation(float x) {
            ${s}
          }
        `,v="result = activation(result);");const k=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${w}

      const ivec2 strides = ivec2(${u}, ${l});
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${$}];

        ivec2 xRCCorner =
            ivec2(coords[${y}], coords[${b}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${h}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${p}; wC++) {
            int xC = xCCorner + wC * ${d};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${f}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${m===1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${f}) *
                    getW(wR, wC, ${f}, d2);
              } else {
                dotProd +=
                    getX(batch, ${f}, xR, xC) *
                    getW(wR, wC, ${f}, d2);
              }

            } else if (${m===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${m===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2),
                getW(wR, wC, ${f} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1),
                  getX(batch, xR, xC, ${f} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC),
                  getX(batch, ${f} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${k}
        ${v}
        setOutput(result);
      }
    `}}class Jte{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const n=e.padInfo.front,s=e.padInfo.top,r=e.padInfo.left,a=e.strideDepth,i=e.strideHeight,o=e.strideWidth,u=e.dilationDepth,l=e.dilationHeight,c=e.dilationWidth,d=e.filterDepth,h=e.filterHeight,p=e.filterWidth,f=Math.floor(e.inChannels/4)*4,m=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${a}, ${i}, ${o});
      const ivec3 pads = ivec3(${n}, ${s}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${d}; wF++) {
          int xF = xFCorner + wF * ${u};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${h}; wR++) {
            int xR = xRCorner + wR * ${l};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${f}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${m===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${f}) *
                  getW(wF, wR, wC, ${f}, d2);
              } else if (${m===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${m===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1),
                  getX(batch, xF, xR, xC, ${f} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2),
                  getW(wF, wR, wC, ${f} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sA{constructor(e,n=!1,s=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=$n(this.outputShape.length);const i=e.padInfo.left,o=e.strideWidth,u=e.dilationWidth,l=e.filterHeight,c=e.filterWidth,d=c;let h=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<c;g++)h+=`
           vec4 xTexelC${g*2};
           int xTexelC${g*2}Ready;
           vec4 xTexelC${g*2+1};
           int xTexelC${g*2+1}Ready;
           vec4 xC${g};`;h+=`
     for (int r = 0; r < ${l}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let g=0;g<c;g++)h+=`
           xTexelC${g*2} = vec4(0.0);
           xTexelC${g*2}Ready = 0;
           xTexelC${g*2+1} = vec4(0.0);
           xTexelC${g*2+1}Ready = 0;
           xC${g} = vec4(0.0);`;h+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let g=0;g<(d+1)/2;g++){const y=g*2;if(h+=`
           xC = xCCorner + ${y*u};
           `,o===1){if(y<c&&(i%2===1?(h+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }
               `,u===1&&y>0?h+=`
                 xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);
                 `:h+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                   } else {
                     xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                   }
                   `):h+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xC${y} = xTexelC${y};
                 `,y+1<c)){const b=i%2===0?yg(u):u;u%2===0&&i%2===1||u%2!==0&&i%2!==1?(h+=`
                   xCOffset = xC + imod(pads[1], 2) + ${b};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                     xTexelC${y+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${y+1}.zw = vec2(0.0);
                     }
                     xTexelC${y+1}Ready = 1;
                   }
                   `,u>1?h+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);
                     } else {
                      xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);
                     }
                     `:h+=`
                     xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);
                     `):b===1?h+=`
                     xC${y+1} = xTexelC${y};
                     `:h+=`
                     xCOffset = xC + ${b};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                       xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${y+1}.zw = vec2(0.0);
                       }
                       xTexelC${y+1}Ready = 1;
                     }

                     xC${y+1} = xTexelC${y+1};
                     `}}else y<c&&(i%2===1?(h+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.0);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
               `,y+1<c&&(h+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);
                 `)):(h+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(
                   xTexelC${y}.xy, xTexelC${y+1}.xy);
               `,y+1<c&&(h+=`
                   xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
                 `)));y<c&&(h+=`
             wTexel = getW(r, ${y}, d1, d2);
             dotProd += xC${y}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${y}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,y+1<c&&(h+=`
               wTexel = getW(r, ${y+1}, d1, d2);
               dotProd += xC${y+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${y+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}h+=`
     }
   `,h+=`
     }
   `,h+=`
     }
   `;let p="",f="";s&&(r?p=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${s}
         }`:a?p=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${s}
         }`:p=`vec4 activation(vec4 x) {
           ${s}
         }`,f="result = activation(result);");const m=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${p}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${h}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${m}
         ${f}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ene{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=$n(this.outputShape.length);const{dataFormat:s}=n,r=En(),a=s==="channelsLast",i=a?1:2,o=a?2:3,u=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let l="";for(let c=0;c<=1;c++)for(let d=0;d<=1;d++)l+=`
          blockIndex = rc.z + ${d};
          pos = rc.y + ${c};

          ${u}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${i}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${o}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${a}) {
                  innerDims = vec2(d1, ch);
                  result[${c*2+d}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c*2+d}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${r.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cd(t,e){const n=t.length;return n>=3?e?[...t.slice(0,-3),t[n-3]*t[n-2],t[n-1]]:[...t.slice(0,-3),t[n-3],t[n-2]*t[n-1]]:!e&&n===1&&t[0]>1?[t[0],1]:null}function rA({x:t,filter:e,convInfo:n,backend:s,bias:r=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){const u=t.shape,l=s.texData.get(t.dataId),c=n.inChannels,d=u[0]*u[1]*u[2],h=n.outChannels,p=n.dataFormat==="channelsLast",f=!1,m=!1;let g;const y=[];if(a!=null){const w=cd(a.shape,p);w!=null&&(a=me({inputs:{x:a},backend:s,attrs:{shape:w}}),y.push(a))}if(r!=null){const w=cd(r.shape,p);w!=null&&(r=me({inputs:{x:r},backend:s,attrs:{shape:w}}),y.push(r))}if(!((d===1||h===1)&&c>YE)&&l.isPacked&&p&&l.texture!=null&&u[2]%2!==0&&tt(l.shape.slice(-3),u.slice(-3))){const w=u[0]*u[1]*(u[2]+1),v={dataId:t.dataId,shape:[1,w,n.inChannels],dtype:t.dtype},k=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,O(ud(l.shape,v.shape),()=>`packed reshape ${l.shape} to ${v.shape} isn't free`);const C=me({inputs:{x:e},backend:s,attrs:{shape:[1,n.inChannels,n.outChannels]}});y.push(C);const N=ld({a:v,b:C,backend:s,transposeA:f,transposeB:m,bias:r,activation:o,preluActivationWeights:a,leakyreluAlpha:i}),A=s.texData.get(N.dataId);O(A.isPacked,()=>"batchMatMul result is expected to be packed"),l.shape=k,A.shape=n.outShape,g=Yn({inputs:{x:N},backend:s}),g.shape=n.outShape,y.push(N)}else{const w=n.outHeight*n.outWidth,v=me({inputs:{x:t},backend:s,attrs:{shape:p?[n.batchSize,w,n.inChannels]:[n.batchSize,n.inChannels,w]}}),k=me({inputs:{x:e},backend:s,attrs:{shape:[1,n.inChannels,n.outChannels]}}),C=ld({a:p?v:k,b:p?k:v,transposeA:!p,transposeB:m,backend:s,bias:r,activation:o,preluActivationWeights:a,leakyreluAlpha:i});g=me({inputs:{x:C},backend:s,attrs:{shape:n.outShape}}),y.push(v),y.push(k),y.push(C)}for(const w of y)s.disposeIntermediateTensorInfo(w);return g}function aA({x:t,filter:e,convInfo:n,backend:s,bias:r=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){const{filterWidth:u,filterHeight:l,inChannels:c,outWidth:d,outHeight:h,dataFormat:p}=n,f=p==="channelsLast",m=u*l*c,g=h*d,y=[n.batchSize,m,g],b=!0,$=!1,w=[];if(a!=null){const B=cd(a.shape,f);B!=null&&(a=me({inputs:{x:a},backend:s,attrs:{shape:B}}),w.push(a))}if(r!=null){const B=cd(r.shape,f);B!=null&&(r=me({inputs:{x:r},backend:s,attrs:{shape:B}}),w.push(r))}const v=me({inputs:{x:e},backend:s,attrs:{shape:[1,m,se(e.shape)/m]}});w.push(v);const k=new ene(y,n),C=[t.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],N=s.runWebGLProgram(k,[t],"float32",C),A=me({inputs:{x:N},backend:s,attrs:{shape:y}});w.push(N),w.push(A);const I=r!=null,E=a!=null,z=o==="leakyrelu",P=o?mu(o,!0):null,H=new XE(f?A.shape:v.shape,f?v.shape:A.shape,f?[n.batchSize,g,n.outChannels]:[n.batchSize,n.outChannels,g],b,$,I,P,E,z),G=f?[A,v]:[v,A];if(r&&G.push(r),E&&G.push(a),z){const B=s.makeTensorInfo([],"float32",ma(i,"float32"));G.push(B),w.push(B)}const W=s.runWebGLProgram(H,G,"float32"),L=me({inputs:{x:W},backend:s,attrs:{shape:n.outShape}});w.push(W);for(const B of w)s.disposeIntermediateTensorInfo(B);return L}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tne(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:a}=e,{strides:i,pad:o,dataFormat:u,dilations:l,dimRoundingMode:c}=s,d=Fr(u),h=rn(r.shape,a.shape,i,l,o,c,!1,d);let p;if(h.filterHeight===1&&h.filterWidth===1&&h.dilationHeight===1&&h.dilationWidth===1&&h.strideHeight===1&&h.strideWidth===1&&(h.padInfo.type==="SAME"||h.padInfo.type==="VALID"))p=rA({x:r,filter:a,convInfo:h,backend:n});else if(h.strideWidth<=2&&d==="channelsLast"&&te().getBool("WEBGL_EXP_CONV")){const m=new sA(h),g=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];p=n.runWebGLProgram(m,[r,a],"float32",g)}else if(te().getBool("WEBGL_CONV_IM2COL"))p=aA({x:r,filter:a,convInfo:h,backend:n});else{const m=new nA(h);p=n.runWebGLProgram(m,[r,a],"float32")}const f=me({inputs:{x:p},backend:n,attrs:{shape:h.outShape}});return n.disposeIntermediateTensorInfo(p),f}const nne={kernelName:Ad,backendName:"webgl",kernelFunc:tne};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sne{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,i=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${a};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${i?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class rne{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterHeight,s=e.filterWidth,r=e.strideHeight,a=e.strideWidth,i=e.dataFormat==="channelsLast",o=n-1-e.padInfo.top,u=s-1-e.padInfo.left,l=i?1:2,c=i?2:3,d=i?3:1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${d}];

        ivec2 dyCorner = ivec2(coords[${l}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${i}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class ane{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideDepth,s=e.strideHeight,r=e.strideWidth,a=e.padInfo.front,i=e.padInfo.top,o=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${n} - ${a};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${i};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${o};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class ine{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterDepth,s=e.filterHeight,r=e.filterWidth,a=e.strideDepth,i=e.strideHeight,o=e.strideWidth,u=n-1-e.padInfo.front,l=s-1-e.padInfo.top,c=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${u}, ${l}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${n}; wF++) {
          float dyF = float(dyFCorner + wF) / ${a}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${n} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function one(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:a}=e,{strides:i,pad:o,dataFormat:u,dimRoundingMode:l,filterShape:c}=s,d=Fr(u),h=rn(r.shape,c,i,1,o,l,!1,d),p=new sne(h);return n.runWebGLProgram(p,[r,a],"float32")}const une={kernelName:Cg,backendName:"webgl",kernelFunc:one};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lne{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=$n(this.outputShape.length);const n=e.filterHeight,s=e.filterWidth,r=n-1-e.padInfo.top,a=s-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            int wCPerm = ${s} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cne(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:a}=e,{inputShape:i,strides:o,pad:u,dataFormat:l,dimRoundingMode:c}=s,d=Fr(l),h=rn(i,a.shape,o,1,u,c,!1,d);if(te().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&d==="channelsLast"){const p=[[h.strideHeight,h.strideWidth]],f=new lne(h);return n.runWebGLProgram(f,[r,a],"float32",p)}else{const p=new rne(h);return n.runWebGLProgram(p,[r,a],"float32")}}const dne={kernelName:Rd,backendName:"webgl",kernelFunc:cne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hne(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:a}=e,{strides:i,pad:o,dilations:u}=s,l=ba(r.shape,a.shape,i,u,o),c=new Jte(l);return n.runWebGLProgram(c,[r,a],"float32")}const pne={kernelName:Dd,backendName:"webgl",kernelFunc:hne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fne(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:a}=e,{strides:i,pad:o,filterShape:u}=s,l=ba(r.shape,u,i,1,o),c=new ane(l);return n.runWebGLProgram(c,[r,a],"float32")}const mne={kernelName:Tg,backendName:"webgl",kernelFunc:fne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gne(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:a}=e,{pad:i,strides:o,inputShape:u}=s,l=ba(u,a.shape,o,1,i),c=new ine(l);return n.runWebGLProgram(c,[r,a],"float32")}const yne={kernelName:Ng,backendName:"webgl",kernelFunc:gne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bne=So+`
  return cos(x);
`,xne=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Ii}
  return result;
`,wne=it({opSnippet:bne,packedOpSnippet:xne}),$ne={kernelName:Au,backendName:"webgl",kernelFunc:wne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vne=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,Sne=it({opSnippet:vne}),Ine={kernelName:Ru,backendName:"webgl",kernelFunc:Sne};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _ne{constructor(e,n,s,r,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[i,o,u,l]=e,[c]=n,[d,h]=s;this.outputShape=[c,d,h,l];const p=r==="bilinear"?1:0,[f,m]=[`${o-1}.0`,`${u-1}.0`],[g,y,b]=d>1?[`${(o-1)/(d-1)}`,"(y2-y1) * height_ratio",`y1*${f} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${f}`],[$,w,v]=h>1?[`${(u-1)/(h-1)}`,"(x2-x1) * width_ratio",`x1*${m} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${m}`];this.userCode=`
      const float height_ratio = float(${g});
      const float width_ratio = float(${$});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${i}) {
          return;
        }

        float height_scale = ${y};
        float width_scale = ${w};

        float in_y = ${b};
        if( in_y < 0.0 || in_y > ${f} ) {
          setOutput(float(${a}));
          return;
        }
        float in_x = ${v};
        if( in_x < 0.0 || in_x > ${m} ) {
          setOutput(float(${a}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${p} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kne=t=>{const{inputs:e,backend:n,attrs:s}=t,{image:r,boxes:a,boxInd:i}=e,{cropSize:o,method:u,extrapolationValue:l}=s,c=new _ne(r.shape,a.shape,o,u,l);return n.runWebGLProgram(c,[r,a,i],"float32")},Cne={kernelName:Ag,backendName:"webgl",kernelFunc:kne};var yu;(function(t){t.Prod="*",t.Sum="+"})(yu||(yu={}));class I${constructor(e,n,s,r){this.op=e,this.outputShape=n,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const a=this.outputShape.length,i=this.op===yu.Prod?"1.0":"0.0",o=s?i:`getX(${_$(a,"coords",this.op)})`,u=this.outputShape[this.outputShape.length-1];let l="",c="";s?(l=r?`end != ${u-1}`:"end != 0",c=r?"end + 1":"end - 1"):(l=r?`end + pow2 < ${u}`:"end >= pow2",c=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${yt(a)} coords = getOutputCoords();
        int end = ${k$(a,"coords",this.op)};
        float val = ${o};
        int pow2 = int(pow(2.0, index));
        if (${l}) {
          int idx = ${c};
          ${k$(a,"coords",this.op)} = idx;
          val ${this.op}= getX(${_$(a,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function _$(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.x, ${e}.y`;if(t===3)return`${e}.x, ${e}.y, ${e}.z`;if(t===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${n} for rank ${t} is not yet supported`)}function k$(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.y`;if(t===3)return`${e}.z`;if(t===4)return`${e}.w`;throw new Error(`Cumulative ${n} for rank ${t} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iA(t,e,n,s,r,a){const i=e.shape.length,o=At([s],i);let u=e;o!=null&&(u=Tn({inputs:{x:e},backend:n,attrs:{perm:o}}));const l=Pt(1,i)[0];if(l!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${s}`);const c=u.shape[l];let d=Yn({inputs:{x:u},backend:n});for(let h=0;h<=Math.ceil(Math.log2(c))-1;h++){const p=new I$(t,u.shape,!1,a),f=[[h]],m=d;d=n.runWebGLProgram(p,[d],d.dtype,f),n.disposeIntermediateTensorInfo(m)}if(r){const h=new I$(t,u.shape,r,a),p=d;d=n.runWebGLProgram(h,[d],d.dtype),n.disposeIntermediateTensorInfo(p)}if(o!=null){const h=xa(o),p=Tn({inputs:{x:d},backend:n,attrs:{perm:h}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(u),p}return d}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tne(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:a,exclusive:i,reverse:o}=s;return iA(yu.Prod,r,n,a,i,o)}const Nne={kernelName:Eg,backendName:"webgl",kernelFunc:Tne};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ene(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:a,exclusive:i,reverse:o}=s;return iA(yu.Sum,r,n,a,i,o)}const Ane={kernelName:Od,backendName:"webgl",kernelFunc:Ene};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rne(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,weights:a}=e,{size:i,binaryOutput:o}=s;if(r.shape.length===1){const u=n.readSync(r.dataId),l=n.readSync(a.dataId),c=ME(u,l,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,c)}else if(r.shape.length===2){const u=n.bufferSync(r),l=n.bufferSync(a),c=zQ(u,l,i,o);return n.makeTensorInfo(c.shape,a.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const Dne={kernelName:Rg,backendName:"webgl",kernelFunc:Rne};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class One{constructor(e,n,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=n,this.dataFormat=s,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${n};
      int offset_h = imod(h, ${n});
      int in_w = w / ${n};
      int offset_w = imod(w, ${n});
      int offset_d = (offset_h * ${n} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fne(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockSize:a,dataFormat:i}=s,o=r.shape[0],u=i==="NHWC"?r.shape[1]:r.shape[2],l=i==="NHWC"?r.shape[2]:r.shape[3],c=i==="NHWC"?r.shape[3]:r.shape[1],d=u*a,h=l*a,p=c/(a*a),f=i==="NHWC"?[o,d,h,p]:[o,p,d,h],m=new One(f,a,i);return n.runWebGLProgram(m,[r],r.dtype)}const zne={kernelName:Dg,backendName:"webgl",kernelFunc:Fne};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oA{constructor(e,n=!1,s=null,r=!1,a=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=$n(this.outputShape.length);const i=e.filterHeight,o=e.filterWidth,u=e.outChannels/e.inChannels;let l="",c="";s&&(r?l=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:a?l=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:l=`
          float activation(float x) {
            ${s}
          }
        `,c="result = activation(result);");const d=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${u};
        int q = d2 - d1 * ${u};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${i}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${o}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${d}
        ${c}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uA{constructor(e,n=!1,s=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=$n(this.outputShape.length);const i=e.outChannels/e.inChannels,o=e.padInfo.left,u=e.strideWidth,l=e.dilationWidth,c=e.filterHeight,d=e.filterWidth,h=d;let p=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<d;y++)p+=`
          vec4 xTexelC${y*2};
          int xTexelC${y*2}Ready;
          vec4 xTexelC${y*2+1};
          int xTexelC${y*2+1}Ready;
          vec4 xC${y};`;p+=`
    for (int r = 0; r < ${c}; r++) {
      `;for(let y=0;y<d;y++)p+=`
          xTexelC${y*2} = vec4(0.0);
          xTexelC${y*2}Ready = 0;
          xTexelC${y*2+1} = vec4(0.0);
          xTexelC${y*2+1}Ready = 0;
          xC${y} = vec4(0.0);`;p+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let y=0;y<(h+1)/2;y++){const b=y*2;if(p+=`
          xC = xCCorner + ${b*l};
          `,u===1){if(b<d&&(o%2===1?(p+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }
              `,l===1&&b>0?p+=`
                xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                `:p+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                  } else {
                    xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                  }
                  `):p+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xC${b} = xTexelC${b};
                `,b+1<d)){const $=o%2===0?yg(l):l;l%2===0&&o%2===1||l%2!==0&&o%2!==1?(p+=`
                  xCOffset = xC + imod(pads[1], 2) + ${$};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                    xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${b+1}.zw = vec2(0.0);
                    }
                    xTexelC${b+1}Ready = 1;
                  }
                  `,l>1?p+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);
                    } else {
                     xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);
                    }
                    `:p+=`
                    xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                    `):$===1?p+=`
                    xC${b+1} = xTexelC${b};
                    `:p+=`
                    xCOffset = xC + ${$};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                      xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${b+1}.zw = vec2(0.0);
                      }
                      xTexelC${b+1}Ready = 1;
                    }

                    xC${b+1} = xTexelC${b+1};
                    `}}else b<d&&(o%2===1?(p+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.0);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
              `,b+1<d&&(p+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                `)):(p+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(
                  xTexelC${b}.xy, xTexelC${b+1}.xy);
              `,b+1<d&&(p+=`
                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                `)));b<d&&(p+=`
            wTexel = getW(r, ${b}, d1, q);
            dotProd += xC${b} * vec4(wTexel.xz, wTexel.xz);
          `,b+1<d&&(p+=`
              wTexel = getW(r, ${b+1}, d1, q);
              dotProd += xC${b+1} * vec4(wTexel.xz, wTexel.xz);
            `))}p+=`
    }
  `,p+=`
      }
    `;let f="",m="";s&&(r?f=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:a?f=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:f=`vec4 activation(vec4 x) {
          ${s}
        }`,m="result = activation(result);");const g=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${f}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${p}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${g}
        ${m}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lne(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:a}=e,{strides:i,pad:o,dilations:u,dimRoundingMode:l}=s;let c=u;c==null&&(c=[1,1]),O(pn(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const d=rn(r.shape,a.shape,i,c,o,l,!0);let h;te().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?h=new uA(d):h=new oA(d);const p=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return n.runWebGLProgram(h,[r,a],"float32",p)}const Pne={kernelName:Fd,backendName:"webgl",kernelFunc:Lne};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bne{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${i} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${a};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Mne{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterHeight,s=e.filterWidth,r=e.strideHeight,a=e.strideWidth,i=n-1-e.padInfo.top,o=s-1-e.padInfo.left,u=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${u}; dm++) {
              int d2 = d1 * ${u} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vne(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:a}=e,{strides:i,dilations:o,pad:u,dimRoundingMode:l,filterShape:c}=s,d=rn(r.shape,c,i,o,u,l,!0),h=new Bne(d);return n.runWebGLProgram(h,[r,a],"float32")}const Wne={kernelName:Og,backendName:"webgl",kernelFunc:Vne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Une(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:a}=e,{strides:i,dilations:o,pad:u,dimRoundingMode:l,inputShape:c}=s,d=rn(c,a.shape,i,o,u,l,!0),h=new Mne(d);return n.runWebGLProgram(h,[r,a],"float32")}const Gne={kernelName:Fg,backendName:"webgl",kernelFunc:Une};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hne{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qne(t){const{inputs:e,backend:n}=t,{x:s}=e,r=[...s.shape,...s.shape],a=se(s.shape),i=me({inputs:{x:s},backend:n,attrs:{shape:[a]}}),o=new Hne(a),u=n.runWebGLProgram(o,[i],i.dtype),l=me({inputs:{x:u},backend:n,attrs:{shape:r}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),l}const jne={kernelName:zg,backendName:"webgl",kernelFunc:qne};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Kne{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:n,inWidth:s,padInfo:r,strideHeight:a,strideWidth:i,filterHeight:o,filterWidth:u,dilationHeight:l,dilationWidth:c}=e,{top:d,left:h}=r;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${i});
      const ivec2 pads = ivec2(${d}, ${h});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${o}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${n}) {
            for (int w = 0; w < ${u}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xne(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:a}=e,{strides:i,pad:o,dilations:u}=s,l=yl(r.shape,a.shape,i,o,"NHWC",u);let c;const d=new Kne(l);c=n.runWebGLProgram(d,[r,a],"float32");const h=me({inputs:{x:c},backend:n,attrs:{shape:l.outShape}});return n.disposeIntermediateTensorInfo(c),h}const Yne={kernelName:zd,backendName:"webgl",kernelFunc:Xne};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zne(t){const{inputs:e,backend:n,attrs:s}=t,{equation:r}=s,a=e,{allDims:i,summedDims:o,idDims:u}=Ab(r,a.length);Db(i.length,u,a);const{path:l,steps:c}=Ob(o,u),d=c.length;let h=null,p=i.length;const f=[];for(let m=0;m<d;++m){for(const g of c[m]){const{permutationIndices:y,expandDims:b}=Rb(p,u[g]);let $;Fb(y)?$=a[g]:($=Tn({inputs:{x:a[g]},backend:n,attrs:{perm:y}}),f.push($));const w=$.shape.slice();for(let v=0;v<b.length;++v)w.splice(b[v],0,1);tt($.shape,w)||($=me({inputs:{x:$},backend:n,attrs:{shape:w}}),f.push($)),h===null?h=$:(h=v0({inputs:{a:$,b:h},backend:n}),f.push(h))}m<d-1&&(l[m]>=0&&(h=dp({inputs:{x:h},backend:n,attrs:{axis:l[m]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(const m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}const Qne={kernelName:Lg,backendName:"webgl",kernelFunc:Zne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jne="return (x >= 0.0) ? x : (exp(x) - 1.0);",ese=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,tse=it({opSnippet:Jne,packedOpSnippet:ese}),nse={kernelName:Ou,backendName:"webgl",kernelFunc:tse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sse="return (b >= 0.0) ? a : a * (b + 1.0);",rse=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,ase=t=>{const{inputs:e,backend:n}=t,{dy:s,y:r}=e,a=te().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new vo(rse,s.shape,r.shape):new di(sse,s.shape,r.shape);return n.runWebGLProgram(a,[s,r],s.dtype)},ise={kernelName:Pg,backendName:"webgl",kernelFunc:ase};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ose=`
  return vec4(equal(a, b));
`,use="return float(a == b);",lse=gn({opSnippet:use,packedOpSnippet:ose,dtype:"bool",cpuKernelImpl:VQ}),cse={kernelName:Ld,backendName:"webgl",kernelFunc:lse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dse=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${Ib};
  float a1 = ${_b};
  float a2 = ${kb};
  float a3 = ${Cb};
  float a4 = ${Tb};
  float a5 = ${Nb};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,hse=it({opSnippet:dse}),pse={kernelName:Fu,backendName:"webgl",kernelFunc:hse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fse=So+`
  return exp(x);
`,mse=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,lA=it({opSnippet:fse,packedOpSnippet:mse,cpuKernelImpl:WQ,dtype:"float32"}),gse={kernelName:zu,backendName:"webgl",kernelFunc:lA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jm(t){const{inputs:e,attrs:n,backend:s}=t,{dim:r}=n,{input:a}=e,i=a.shape.length,o=a.shape.slice();let u=r;return r<0&&(O(-(i+1)<=r,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+r+1),o.splice(u,0,1),me({inputs:{x:a},backend:s,attrs:{shape:o}})}const yse={kernelName:Pd,backendName:"webgl",kernelFunc:Jm};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C$="return exp(x) - 1.0;",bse=it({opSnippet:C$,packedOpSnippet:C$,cpuKernelImpl:UQ}),xse={kernelName:Lu,backendName:"webgl",kernelFunc:bse};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class T${constructor(e,n,s){this.variableNames=["real","imag"];const r=n[1];this.outputShape=n;const a=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=s?`${r}.0`:"1.0";let o;if(e==="real")o="return real * expR - imag * expI;";else if(e==="imag")o="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${a};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${o}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${i};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cA(t,e,n){const s=n.texData.get(t.dataId),r=se(t.shape),a=t.shape[t.shape.length-1],i=r/a,o=me({inputs:{x:t},backend:n,attrs:{shape:[i,a]}}),u=o.shape,l=new T$("real",u,e),c=new T$("imag",u,e),d=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:u},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:u}],h=n.runWebGLProgram(l,d,"float32"),p=n.runWebGLProgram(c,d,"float32"),f=_a({inputs:{real:h,imag:p},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p);const m=me({inputs:{x:f},backend:n,attrs:{shape:t.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(f),m}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wse(t){const{inputs:e,backend:n}=t,{input:s}=e;return cA(s,!1,n)}const $se={kernelName:Bg,backendName:"webgl",kernelFunc:wse};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vse{constructor(e,n){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ml(t){const{backend:e,attrs:n}=t,{shape:s,value:r}=n;let{dtype:a}=n;if(a=a||oo(r),a==="string"){const i=zt(a,se(s));return i.fill(r),e.makeTensorInfo(s,a,i)}else{const i=new vse(s,r),o=[[r]];return e.runWebGLProgram(i,[],a,o)}}const Sse={kernelName:Mg,backendName:"webgl",kernelFunc:Ml};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ise{constructor(e){this.variableNames=["Image"],this.outputShape=[];const n=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${n} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${n}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _se={kernelName:Vg,backendName:"webgl",kernelFunc:({inputs:t,backend:e})=>{const{image:n}=t,s=e,r=new Ise(n.shape);return s.runWebGLProgram(r,[n],n.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N$="return floor(x);",kse=it({opSnippet:N$,packedOpSnippet:N$,cpuKernelImpl:GQ}),Cse={kernelName:Pu,backendName:"webgl",kernelFunc:kse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tse=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,Nse=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,Ese=gn({opSnippet:Tse,packedOpSnippet:Nse,dtype:"int32"}),Ase={kernelName:Bu,backendName:"webgl",kernelFunc:Ese};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rse{constructor(e){this.variableNames=["A"];const n=En(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${s}.0);

        vec4 values = ${n.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dse{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const n=En(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${s}.0);
            vec4 values = ${n.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ose={kernelName:um,backendName:"webgl",kernelFunc:Fse};let Ai,rf=te().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function Fse(t){const{inputs:e,backend:n,attrs:s}=t;let{pixels:r}=e;const{numChannels:a}=s,i=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,o=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,[u,l]=i?[r.videoWidth,r.videoHeight]:[r.width,r.height],c=[l,u],d=[l,u,a];if(o||i){const m=te().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Ai==null||m!==rf)&&(rf=m,Ai=document.createElement("canvas").getContext("2d",{willReadFrequently:rf})),Ai.canvas.width=u,Ai.canvas.height=l,Ai.drawImage(r,0,0,u,l),r=Ai.canvas}const h=n.makeTensorInfo(c,"int32");n.texData.get(h.dataId).usage=ns.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(h.dataId),r);const p=te().getBool("WEBGL_PACK")?new Dse(d):new Rse(d),f=n.runWebGLProgram(p,[h],"int32");return n.disposeData(h.dataId),f}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zse(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:a,bias:i,preluActivationWeights:o}=e,{strides:u,pad:l,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=s,m=Fr(c),g=rn(r.shape,a.shape,u,d,l,h,!1,m);let y;const b=[],$=i!=null,w=o!=null,v=p==="leakyrelu",k=()=>{const N=[r,a],A=(I,E)=>{if(E==="NCHW"&&I.shape.length===1&&I.shape[0]!==1){const z=me({inputs:{x:I},backend:n,attrs:{shape:[I.shape[0],1,1]}});return b.push(z),z}return I};if($&&N.push(A(i,c)),w&&N.push(A(o,c)),v){const I=n.makeTensorInfo([],"float32",ma(f,"float32"));N.push(I),b.push(I)}return N};if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))y=rA({x:r,filter:a,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else if(g.strideWidth<=2&&m==="channelsLast"&&te().getBool("WEBGL_EXP_CONV")){const N=p?mu(p,!0):null,A=new sA(g,$,N,w,v),I=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],E=k();y=n.runWebGLProgram(A,E,"float32",I)}else if(te().getBool("WEBGL_CONV_IM2COL"))y=aA({x:r,filter:a,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else{const N=p?mu(p,!1):null,A=new nA(g,$,N,w,v),I=k();y=n.runWebGLProgram(A,I,"float32")}const C=me({inputs:{x:y},backend:n,attrs:{shape:g.outShape}});return b.push(y),b.forEach(N=>n.disposeIntermediateTensorInfo(N)),C}const Lse={kernelName:Bc,backendName:"webgl",kernelFunc:zse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pse(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:a,bias:i,preluActivationWeights:o}=e,{strides:u,pad:l,dilations:c,dimRoundingMode:d,activation:h,leakyreluAlpha:p}=s,f=[];let m=c;m==null&&(m=[1,1]),O(pn(u,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${m}'`);const g=rn(r.shape,a.shape,u,m,l,d,!0),y=te().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,b=h?mu(h,y):null,$=[r,a],w=i!=null,v=o!=null,k=h==="leakyrelu";if(w&&$.push(i),v&&$.push(o),k){const I=n.makeTensorInfo([],"float32",ma(p,"float32"));$.push(I),f.push(I)}let C;y?C=new uA(g,w,b,v,k):C=new oA(g,w,b,v,k);const N=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],A=n.runWebGLProgram(C,$,"float32",N);return f.forEach(I=>n.disposeIntermediateTensorInfo(I)),A}const Bse={kernelName:Mc,backendName:"webgl",kernelFunc:Pse};class Mse{constructor(e,n,s,r){this.sliceDim=e,this.strides=n,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=s;const a=yt(s.length);let i=`
    int index;`;for(let o=0;o<this.sliceDim;o++)i+=`
          index = round(getIndices(coords[0], ${o}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[o]};
          flattenIndex += index * ${this.strides[o]};`;this.userCode=`
         void main() {
          ${a} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${i}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vse(t){const{inputs:e,backend:n}=t,{params:s,indices:r}=e,a=r.shape,i=a[a.length-1],o=se(s.shape),[u,l,c,d]=pb(s,r),h=me({inputs:{x:r},backend:n,attrs:{shape:[l,i]}}),p=me({inputs:{x:s},backend:n,attrs:{shape:[se(s.shape)/c,c]}});if(n.shouldExecuteOnCPU([s,r])||s.dtype==="string"){const y=n.readSync(r.dataId),b=n.bufferSync(s),$=HQ(y,b,s.dtype,l,i,c,d,s.shape,o);return n.makeTensorInfo(u,s.dtype,$.values)}const f=new Mse(i,d,[l,c],s.shape),m=n.runWebGLProgram(f,[p,h],p.dtype),g=me({inputs:{x:m},backend:n,attrs:{shape:u}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}const Wse={kernelName:Wg,backendName:"webgl",kernelFunc:Vse};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Use{constructor(e,n){this.variableNames=["A","indices"],this.outputShape=n,this.rank=n.length;const s=yt(this.rank),r=Gse(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}}function Gse(t,e){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<t.length;r++)r===2?s.push("index"):s.push(`${n[r]}`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dA(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,indices:a}=e,{axis:i,batchDims:o}=s,u=Ye(i,r.shape)[0];if(te().get("DEBUG")){const b=n.readSync(a.dataId),$=r.shape[u];for(let w=0;w<b.length;++w){const v=b[w];O(v<=$-1&&v>=0,()=>`GatherV2: the index value ${v} is not in [0, ${$-1}]`)}}const l=Lb(r,a,u,o),c=se(a.shape),d=[],h=me({inputs:{x:r},backend:n,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),p=me({inputs:{x:a},backend:n,attrs:{shape:[l.batchSize,c/l.batchSize]}});d.push(h),d.push(p);const f=[l.batchSize,l.outerSize,c/l.batchSize,l.sliceSize];if(n.shouldExecuteOnCPU([r,a])||r.dtype==="string"){const b=n.bufferSync(p),$=n.bufferSync(h),w=qQ($,b,f);return d.forEach(v=>n.disposeIntermediateTensorInfo(v)),n.makeTensorInfo(l.outputShape,w.dtype,w.values)}const m=new Use(h.shape,f),g=n.runWebGLProgram(m,[h,p],h.dtype);d.push(g);const y=me({inputs:{x:g},backend:n,attrs:{shape:l.outputShape}});return d.forEach(b=>n.disposeIntermediateTensorInfo(b)),y}const Hse={kernelName:Md,backendName:"webgl",kernelFunc:dA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qse="return float(a > b);",jse=`
  return vec4(greaterThan(a, b));
`,Kse=gn({opSnippet:qse,packedOpSnippet:jse,cpuKernelImpl:jQ,dtype:"bool"}),Xse={kernelName:Vd,backendName:"webgl",kernelFunc:Kse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yse="return float(a >= b);",Zse=`
  return vec4(greaterThanEqual(a, b));
`,Qse=gn({opSnippet:Yse,packedOpSnippet:Zse,dtype:"bool",cpuKernelImpl:KQ}),Jse={kernelName:Mu,backendName:"webgl",kernelFunc:Qse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ere(t){const{inputs:e,backend:n}=t,{input:s}=e;return cA(s,!0,n)}const tre={kernelName:Ug,backendName:"webgl",kernelFunc:ere};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nre="return float(!isnan(x) && !isinf(x));",sre=it({opSnippet:nre,dtype:"bool"}),rre={kernelName:Wu,backendName:"webgl",kernelFunc:sre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const are="return float(isinf(x));",ire=it({opSnippet:are,dtype:"bool"}),ore={kernelName:Uu,backendName:"webgl",kernelFunc:ire};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ure="return float(isnan(x));",lre=it({opSnippet:ure,dtype:"bool"}),cre={kernelName:Gu,backendName:"webgl",kernelFunc:lre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dre="return float(a < b);",hre=`
  return vec4(lessThan(a, b));
`,pre=gn({opSnippet:dre,packedOpSnippet:hre,cpuKernelImpl:XQ,dtype:"bool"}),fre={kernelName:Ud,backendName:"webgl",kernelFunc:pre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mre="return float(a <= b);",gre=`
  return vec4(lessThanEqual(a, b));
`,yre=gn({opSnippet:mre,packedOpSnippet:gre,cpuKernelImpl:YQ,dtype:"bool"}),bre={kernelName:Gd,backendName:"webgl",kernelFunc:yre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xre(t){const{backend:e,attrs:n}=t,{start:s,stop:r,num:a}=n,i=ZQ(s,r,a);return e.makeTensorInfo([i.length],"float32",i)}const wre={kernelName:Hg,backendName:"webgl",kernelFunc:xre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $re=So+`
  return x < 0.0 ? 0./0. : log(x);
`,vre=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,Sre=it({opSnippet:$re,packedOpSnippet:vre,cpuKernelImpl:QQ}),Ire={kernelName:Hu,backendName:"webgl",kernelFunc:Sre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _re=So+`
  return log(1.0 + x);
`,kre=it({opSnippet:_re}),Cre={kernelName:qu,backendName:"webgl",kernelFunc:kre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tre="return float(a >= 1.0 && b >= 1.0);",Nre=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,Ere=gn({opSnippet:Tre,packedOpSnippet:Nre,dtype:"bool"}),Are={kernelName:Hd,backendName:"webgl",kernelFunc:Ere};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rre="return float(!(x >= 1.0));",Dre=it({opSnippet:Rre}),Ore={kernelName:qd,backendName:"webgl",kernelFunc:Dre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fre="return float(a >= 1.0 || b >= 1.0);",zre=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,Lre=gn({opSnippet:Fre,packedOpSnippet:zre,dtype:"bool"}),Pre={kernelName:jd,backendName:"webgl",kernelFunc:Lre};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bre{constructor(e,n,s,r,a){this.variableNames=["x"],this.outputShape=[];const i=n,o=e[3]-1;this.outputShape=e;let u;const l=`float(${s}) + float(${r}) * sum`;a===.5?u=`inversesqrt(${l})`:a===1?u=`1.0/(${l})`:u=`exp(log(${l}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${i}; j <= ${i}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${o}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${u};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mre{constructor(e,n,s,r,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=n,o=e[3]-1;this.outputShape=e;let u;const l=`float(${s}) + float(${r}) * sum`;a===.5?u=`inversesqrt(${l})`:a===1?u=`1.0/(${l})`:u=`exp(log(${l}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${i};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${i}; j <= ${i}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${u};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vre=t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{depthRadius:a,bias:i,alpha:o,beta:u}=s,l=te().getBool("WEBGL_PACK_NORMALIZATION")?new Mre(r.shape,a,i,o,u):new Bre(r.shape,a,i,o,u);return n.runWebGLProgram(l,[r],r.dtype)},Wre={kernelName:Kd,backendName:"webgl",kernelFunc:Vre};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ure{constructor(e,n,s,r,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=n,this.bias=s,this.alpha=r,this.beta=a,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${n})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${n} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${a})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${a});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gre=t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r,y:a,dy:i}=e,{depthRadius:o,bias:u,alpha:l,beta:c}=s,d=new Ure(r.shape,o,u,l,c);return n.runWebGLProgram(d,[r,a,i],r.dtype)},Hre={kernelName:qg,backendName:"webgl",kernelFunc:Gre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qre(t,e,n,s){const r=se(e),i=se(t.shape)/r,o=me({inputs:{x:t},attrs:{shape:[i,r]},backend:s}),u=_i(o,t.dtype,"max",s),l=me({inputs:{x:u},attrs:{shape:n},backend:s});return s.disposeIntermediateTensorInfo(o),s.disposeIntermediateTensorInfo(u),l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hA(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{reductionIndices:a,keepDims:i}=s,o=r.shape.length,u=Ye(a,r.shape);let l=u;const c=At(l,o),d=c!=null,h=n.shouldExecuteOnCPU([r]);let p=r;if(d){if(h){const $=n.texData.get(p.dataId).values,w=new Array(o);for(let C=0;C<w.length;C++)w[C]=r.shape[c[C]];const v=w0($,r.shape,r.dtype,c,w);p=n.makeTensorInfo(w,r.dtype);const k=n.texData.get(p.dataId);k.values=v}else p=cp(r,c,n);l=Pt(l.length,o)}fn("max",l,o);const[f,m]=an(p.shape,l);let g=f;i&&(g=Lt(f,u));let y;if(h){const $=n.texData.get(p.dataId).values,w=JQ($,se(m),g,r.dtype);y=n.makeTensorInfo(g,r.dtype);const v=n.texData.get(y.dataId);v.values=w}else y=qre(p,m,g,n);return d&&n.disposeIntermediateTensorInfo(p),y}const jre={kernelName:Xd,backendName:"webgl",kernelFunc:hA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kre=$0+`
  return max(a, b);
`,Xre=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Ii+`
  return result;
`,Yre=gn({opSnippet:Kre,packedOpSnippet:Xre,cpuKernelImpl:eJ}),Zre={kernelName:ju,backendName:"webgl",kernelFunc:Yre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qre(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e;Ll(r,"maxPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=s,l=1;O(pn(i,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);const c=_s(r.shape,a,i,l,o,u);if(c.filterWidth===1&&c.filterHeight===1&&tt(c.inShape,c.outShape))return Yn({inputs:{x:r},backend:n});const d=new gu(c,"max",!1);return n.runWebGLProgram(d,[r],r.dtype)}const Jre={kernelName:Yd,backendName:"webgl",kernelFunc:Qre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eae(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{filterSize:a,strides:i,pad:o,dataFormat:u,dimRoundingMode:l}=s,c=[1,1,1],d=Or(r.shape,a,i,c,o,l,u),h=new S0(d,"max",!1);return n.runWebGLProgram(h,[r],r.dtype)}const tae={kernelName:Zd,backendName:"webgl",kernelFunc:eae};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nae{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const n=e.strideHeight,s=e.strideWidth,r=e.dilationHeight,a=e.effectiveFilterHeight,i=e.effectiveFilterWidth,o=a-1-e.padInfo.top,u=i-1-e.padInfo.left,l=a*i-1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${a};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${i}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${i} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class sae{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const n=e.strideDepth,s=e.strideHeight,r=e.strideWidth,a=e.dilationDepth,i=e.dilationHeight,o=e.dilationWidth,u=e.effectiveFilterDepth,l=e.effectiveFilterHeight,c=e.effectiveFilterWidth,d=u-1-e.padInfo.front,h=l-1-e.padInfo.top,p=c-1-e.padInfo.left,f=u*l*c-1;this.userCode=`
      const ivec3 pads = ivec3(${d}, ${h}, ${p});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${u};
           wD += ${a}) {
          float dyD = float(dyDCorner + wD) / ${n}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${i}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${o}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${f} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rae(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:a}=e,i=a,{filterSize:o,strides:u,pad:l,dimRoundingMode:c}=s,d=[1,1,1],h=Or(i.shape,o,u,d,l,c),p=new S0(h,"max",!0),f=n.runWebGLProgram(p,[i],i.dtype),m=new sae(h),g=n.runWebGLProgram(m,[r,f],i.dtype);return n.disposeIntermediateTensorInfo(f),g}const aae={kernelName:Kg,backendName:"webgl",kernelFunc:rae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iae(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:a,output:i}=e,o=a;Ll([a,i],"maxPoolGrad");const{filterSize:u,strides:l,pad:c,dimRoundingMode:d}=s,h=_s(o.shape,u,l,1,c,d),p=!0,f=new gu(h,"max",p),m=n.runWebGLProgram(f,[o],o.dtype),g=new nae(h),y=n.runWebGLProgram(g,[r,m],o.dtype);return n.disposeIntermediateTensorInfo(m),y}const oae={kernelName:jg,backendName:"webgl",kernelFunc:iae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uae(t,e,n,s){let r=new gu(n,"max",!1);const a=s.runWebGLProgram(r,[t],"float32");r=new gu(n,"max",!0,!0,e);const i=s.runWebGLProgram(r,[t],"float32");return[a,i]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lae={kernelName:Xg,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:s}=t,{filterSize:r,strides:a,pad:i,includeBatchInIndex:o}=e,u=n;O(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const l=[1,1];O(pn(a,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${l}'`);const c=_s(s.shape,r,a,l,i),[d,h]=uae(s,o,c,u);return[d,h]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cae(t,e,n,s){const r=se(e),i=se(t.shape)/r,o=me({inputs:{x:t},attrs:{shape:[i,r]},backend:s}),u=_i(o,"float32","mean",s),l=me({inputs:{x:u},attrs:{shape:n},backend:s});return s.disposeIntermediateTensorInfo(o),s.disposeIntermediateTensorInfo(u),l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dae={kernelName:Qd,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:s}=t,{keepDims:r,axis:a}=e,i=n,o=s.shape.length,u=Ye(a,s.shape);let l=u;const c=At(l,o),d=c!=null,h=i.shouldExecuteOnCPU([s]),p=[];let f=s;if(d){if(h){const w=i.texData.get(f.dataId).values,v=new Array(o);for(let N=0;N<v.length;N++)v[N]=s.shape[c[N]];const k=w0(w,s.shape,s.dtype,c,v);f=i.makeTensorInfo(v,s.dtype);const C=i.texData.get(f.dataId);C.values=k}else f=cp(s,c,i);p.push(f),l=Pt(l.length,o)}fn("sum",l,o);const[m,g]=an(f.shape,l);let y=m;r&&(y=Lt(m,u));const b=cae(f,g,y,i);for(const $ of p)i.disposeIntermediateTensorInfo($);return b}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hae(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:a,keepDims:i}=s,o=r.shape.length,u=Ye(a,r.shape);let l=u;const c=At(l,o);let d=r;c!=null&&(d=Tn({inputs:{x:r},backend:n,attrs:{perm:c}}),l=Pt(l.length,r.shape.length)),fn("min",l,o);const[h,p]=an(d.shape,l),f=se(p),m=me({inputs:{x:d},backend:n,attrs:{shape:[-1,f]}}),g=_i(m,m.dtype,"min",n);let y;if(i){const b=Lt(h,u);y=me({inputs:{x:g},backend:n,attrs:{shape:b}})}else y=me({inputs:{x:g},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),c!=null&&n.disposeIntermediateTensorInfo(d),y}const pae={kernelName:Jd,backendName:"webgl",kernelFunc:hae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fae=$0+`
  return min(a, b);
`,mae=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Ii+`
  return result;
`,gae=gn({opSnippet:fae,packedOpSnippet:mae,cpuKernelImpl:tJ}),yae={kernelName:Ku,backendName:"webgl",kernelFunc:gae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bae{constructor(e,n,s){this.variableNames=["x"],this.outputShape=n.map((c,d)=>c[0]+e[d]+c[1]);const r=e.length,a=yt(r),i=n.map(c=>c[0]).join(","),o=n.map((c,d)=>c[0]+e[d]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l=s==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${i};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${a} start = ${a}(${i});
      ${a} end = ${a}(${o});

      void main() {
        ${a} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${a} coords = outC - start;
        setOutput(getX(${u}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xae{constructor(e,n,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n.map((f,m)=>f[0]+e[m]+f[1]);const r=e.length,a=yt(r),i=n.map(f=>f[0]).join(","),o=n.map((f,m)=>f[0]+e[m]).join(","),u=kn("rc",r),l=kn("source",r),c=`${u[r-1]} < ${this.outputShape[r-1]}`,d=r===1?"source":`vec2(${l.slice(-2).join()})`,h=s==="reflect"?0:1;let p="";if(r===1){const f=`
        ${a} source = rc;
        if (source < start) {
          source = start * 2 - source - ${h};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${h};
        }
        source -= start;
      `;p=`
        ${a} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${l.join()}), ${d});
        ${u[r-1]} += 1;
        if(${c}) {
          ${f}
          result[1] = getChannel(getX(${l.join()}), ${d});
        }
      `}else{const f=`
        ${a} source = rc;
        ${a} lt = ${a}(lessThan(source, start));
        ${a} gte = ${a}(greaterThanEqual(source, end));
        ${a} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${h}) +
                gte * ((end - 1) * 2 - source + ${h});
        source -= start;
      `;p=`
        ${a} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${l.join()}), ${d});
        ${u[r-1]} += 1;
        if(${c}) {
          ${f}
          result[1] = getChannel(getX(${l.join()}), ${d});
        }
        rc = outputLoc;
        ${u[r-2]} += 1;
        if(${u[r-2]} < ${this.outputShape[r-2]}) {
          ${f}
          result[2] = getChannel(getX(${l.join()}), ${d});
          ${u[r-1]} += 1;
          if(${c}) {
            ${f}
            result[3] = getChannel(getX(${l.join()}), ${d});
          }
        }
      `}this.userCode=`
      const ${a} start = ${a}(${i});
      const ${a} end = ${a}(${o});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wae=({inputs:t,backend:e,attrs:n})=>{const{x:s}=t,{paddings:r,mode:a}=n,i=te().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new xae(s.shape,r,a):new bae(s.shape,r,a);return e.runWebGLProgram(i,[s],s.dtype)},$ae={kernelName:eh,backendName:"webgl",kernelFunc:wae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vae=`if (b == 0.0) return NAN;
  return mod(a, b);`,Sae=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Ii+`
  return result;
`,Iae=gn({opSnippet:vae,packedOpSnippet:Sae}),_ae={kernelName:Xu,backendName:"webgl",kernelFunc:Iae};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kae{constructor(e,n,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,s],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${n-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${n-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cae=`
if (a == b) {
  return 1.0;
};
return a / b;`,Tae=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,pA=gn({opSnippet:Cae,packedOpSnippet:Tae,checkOutOfBounds:!0}),Nae={kernelName:Du,backendName:"webgl",kernelFunc:pA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const E$="return a - b;",fA=gn({opSnippet:E$,packedOpSnippet:E$,supportsComplex:!0,cpuKernelImpl:vJ}),Eae={kernelName:dl,backendName:"webgl",kernelFunc:fA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mA(t){const{inputs:e,backend:n,attrs:s}=t,{logits:r}=e,{dim:a}=s,i=Ye([a],r.shape),o=hA({inputs:{x:r},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),u=Lt(o.shape,i),l=me({inputs:{x:o},backend:n,attrs:{shape:u}}),c=fA({inputs:{a:r,b:l},backend:n}),d=lA({inputs:{x:c},backend:n}),h=dp({inputs:{x:d},backend:n,attrs:{axis:i,keepDims:!1}}),p=me({inputs:{x:h},backend:n,attrs:{shape:u}}),f=pA({inputs:{a:d,b:p},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),f}const Aae={kernelName:bh,backendName:"webgl",kernelFunc:mA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rae(t){const{inputs:e,backend:n,attrs:s}=t,{logits:r}=e,{numSamples:a,seed:i,normalized:o}=s,u=o?r:mA({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),l=u.shape[0],c=u.shape[1],d=new kae(l,c,a),h=[[i]],p=n.runWebGLProgram(d,[u],"int32",h);return o||n.disposeIntermediateTensorInfo(u),p}const Dae={kernelName:Yg,backendName:"webgl",kernelFunc:Rae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oae=Cs+`
  return -x;
`,Fae=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function zae(t){const{inputs:e,backend:n}=t,{x:s}=e;if(n.shouldExecuteOnCPU([s])){const a=n.texData.get(s.dataId),[i,o]=sJ(a.values,s.shape,s.dtype);return n.makeTensorInfo(o,s.dtype,i)}let r;return te().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new Qr(s.shape,Fae):r=new lr(s.shape,Oae),n.runWebGLProgram(r,[s],s.dtype)}const Lae={kernelName:th,backendName:"webgl",kernelFunc:zae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pae=ib;function Bae(t){ts("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:a}=e,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u}=s,l=n.readSync(r.dataId),c=n.readSync(a.dataId),{selectedIndices:d}=Pae(l,c,i,o,u);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}const Mae={kernelName:Zg,backendName:"webgl",kernelFunc:Bae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vae=ob;function Wae(t){ts("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:a}=e,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,padToMaxOutputSize:l}=s,c=n.readSync(r.dataId),d=n.readSync(a.dataId),{selectedIndices:h,validOutputs:p}=Vae(c,d,i,o,u,l);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}const Uae={kernelName:Qg,backendName:"webgl",kernelFunc:Wae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gae=ub;function Hae(t){ts("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:a}=e,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,softNmsSigma:l}=s,c=n.readSync(r.dataId),d=n.readSync(a.dataId),h=i,p=o,f=u,m=l,{selectedIndices:g,selectedScores:y}=Gae(c,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}const qae={kernelName:Jg,backendName:"webgl",kernelFunc:Hae};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jae{constructor(e,n,s,r){this.variableNames=["indices"],this.outputShape=[e,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${s}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kae=t=>{const{inputs:e,backend:n,attrs:s}=t,{indices:r}=e,{dtype:a,depth:i,onValue:o,offValue:u}=s,l=se(r.shape),c=new jae(l,i,o,u),d=me({inputs:{x:r},backend:n,attrs:{shape:[l]}}),h=n.runWebGLProgram(c,[d],a);n.disposeIntermediateTensorInfo(d);const p=[...r.shape,i],f=me({inputs:{x:h},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(h),f},Xae={kernelName:rh,backendName:"webgl",kernelFunc:Kae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dd(t){const{inputs:e,backend:n}=t,{x:s}=e;if(s.dtype==="complex64"){const r=Bl({inputs:{input:s},backend:n}),a=dd({inputs:{x:r},backend:n}),i=hp({inputs:{input:s},backend:n}),o=dd({inputs:{x:i},backend:n}),u=_a({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),u}else return Ml({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:n})}const Yae={kernelName:vh,backendName:"webgl",kernelFunc:dd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gA(t){const{inputs:e,backend:n}=t,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const r=Bl({inputs:{input:s},backend:n}),a=gA({inputs:{x:r},backend:n}),i=hp({inputs:{input:s},backend:n}),o=dd({inputs:{x:i},backend:n}),u=_a({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),u}else return Ml({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:n})}const Zae={kernelName:sh,backendName:"webgl",kernelFunc:gA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qae(t){const{inputs:e,backend:n,attrs:s}=t,{axis:r}=s;if(e.length===1)return Jm({inputs:{input:e[0]},backend:n,attrs:{dim:r}});const a=e[0].shape,i=e[0].dtype;e.forEach(c=>{Zn(a,c.shape,"All tensors passed to stack must have matching shapes"),O(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],u=e.map(c=>{const d=Jm({inputs:{input:c},backend:n,attrs:{dim:r}});return o.push(d),d}),l=tA({inputs:u,backend:n,attrs:{axis:r}});return o.forEach(c=>n.disposeIntermediateTensorInfo(c)),l}const Jae={kernelName:ah,backendName:"webgl",kernelFunc:Qae};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eie{constructor(e,n,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((l,c)=>l[0]+e[c]+l[1]);const r=e.length,a=yt(r),i=n.map(l=>l[0]).join(","),o=n.map((l,c)=>l[0]+e[c]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${i};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${a} start = ${a}(${i});
      ${a} end = ${a}(${o});

      void main() {
        ${a} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${a} coords = outC - start;
          setOutput(getX(${u}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tie{constructor(e,n,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((m,g)=>m[0]+e[g]+m[1]);const r=e.length,a=yt(r),i=n.map(m=>m[0]).join(","),o=n.map((m,g)=>m[0]+e[g]).join(","),u=kn("rc",r),l=kn("source",r),c=`${u[r-1]} < ${this.outputShape[r-1]}`,d=r===1?"source":`vec2(${l.slice(-2).join()})`,h=[`${a} rc = outputLoc;`,`${u[r-1]} += 1;
       if(${c}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${u[r-2]} += 1;
       if(${u[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${u[r-1]} += 1;
         if(${c}) {`],p=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let f="";for(let m=0,g=r===1?2:4;m<g;m++)f+=`
        ${h[m]}
        if (${p}) {
          result[${m}] = float(value);
        } else {
          ${a} source = rc - start;
          result[${m}] = getChannel(getX(${l.join()}), ${d});
        }
      `;f+=r===1?"} ":"}}",this.userCode=`
      const ${a} start = ${a}(${i});
      const ${a} end = ${a}(${o});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yA=t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{paddings:a,constantValue:i}=s;if(se(r.shape)===0){const l=a.map((c,d)=>c[0]+r.shape[d]+c[1]);return Ml({backend:n,attrs:{shape:l,value:i,dtype:r.dtype}})}const o=te().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new tie(r.shape,a,i):new eie(r.shape,a,i),u=[[i]];return n.runWebGLProgram(o,[r],r.dtype,u)},nie={kernelName:ih,backendName:"webgl",kernelFunc:yA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sie=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,rie=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Ii+`
  return result;
`,aie=gn({opSnippet:sie,packedOpSnippet:rie}),iie={kernelName:Zu,backendName:"webgl",kernelFunc:aie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oie(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:a,keepDims:i}=s,o=r.shape.length,u=[],l=Ye(a,r.shape);let c=l;const d=At(c,o);let h=r;d!=null&&(h=Tn({inputs:{x:r},backend:n,attrs:{perm:d}}),c=Pt(c.length,o),u.push(h)),fn("prod",c,o);let p;if(n.shouldExecuteOnCPU([h])){const f=n.texData.get(h.dataId).values,{outVals:m,outShape:g,outDtype:y}=aJ(h.shape,h.dtype,f,c);p=n.makeTensorInfo(g,y,m)}else{const[f,m]=an(h.shape,c),g=se(m),y=me({inputs:{x:h},backend:n,attrs:{shape:[-1,g]}}),b=Iy(r.dtype),$=_i(y,b,"prod",n);p=me({inputs:{x:$},backend:n,attrs:{shape:f}}),u.push(y),u.push($)}if(i){u.push(p);const f=Lt(p.shape,l);p=me({inputs:{x:p},backend:n,attrs:{shape:f}})}return u.forEach(f=>n.disposeIntermediateTensorInfo(f)),p}const uie={kernelName:uh,backendName:"webgl",kernelFunc:oie};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lie(t){const{inputs:e,backend:n,attrs:s}=t,{paramsNestedSplits:r,paramsDenseValues:a,indices:i}=e,{outputRaggedRank:o}=s,u=r.map(y=>n.readSync(y.dataId)),l=r.map(y=>y.shape),c=n.readSync(a.dataId),d=n.readSync(i.dataId),[h,p,f]=iJ(u,l,c,a.shape,a.dtype,d,i.shape,o),m=h.map(y=>n.makeTensorInfo([y.length],"int32",y)),g=n.makeTensorInfo(f,a.dtype,p);return m.concat([g])}const cie={kernelName:ey,backendName:"webgl",kernelFunc:lie};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function die(t){const{inputs:e,backend:n}=t,{starts:s,limits:r,deltas:a}=e,i=n.readSync(s.dataId),o=n.readSync(r.dataId),u=n.readSync(a.dataId),[l,c]=oJ(i,s.shape,s.dtype,o,r.shape,u,a.shape),d=n.makeTensorInfo([l.length],"int32",l),h=n.makeTensorInfo([c.length],s.dtype,c);return[d,h]}const hie={kernelName:ty,backendName:"webgl",kernelFunc:die};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pie(t){const{inputs:e,backend:n,attrs:s}=t,{shape:r,values:a,defaultValue:i,rowPartitionTensors:o}=e,{rowPartitionTypes:u}=s,l=n.readSync(r.dataId),c=n.readSync(a.dataId),d=n.readSync(i.dataId),h=o.map(g=>n.readSync(g.dataId)),p=o.map(g=>g.shape),[f,m]=uJ(l,r.shape,c,a.shape,a.dtype,d,i.shape,h,p,u);return n.makeTensorInfo(f,a.dtype,m)}const fie={kernelName:ny,backendName:"webgl",kernelFunc:pie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bA=t=>{const{backend:e,attrs:n}=t,{start:s,stop:r,step:a,dtype:i}=n,o=lJ(s,r,a,i);return e.makeTensorInfo([o.length],i,o)},mie={kernelName:sy,backendName:"webgl",kernelFunc:bA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gie="return 1.0 / x;",yie=it({opSnippet:gie}),bie={kernelName:Qu,backendName:"webgl",kernelFunc:yie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xie=Cs+`
  return (x < 0.0) ? 0.0 : x;
`,wie=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,$ie=it({opSnippet:xie,packedOpSnippet:wie}),vie={kernelName:Ju,backendName:"webgl",kernelFunc:$ie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sie=Cs+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Iie=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,_ie=it({opSnippet:Sie,packedOpSnippet:Iie}),kie={kernelName:el,backendName:"webgl",kernelFunc:_ie};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Cie{constructor(e,n,s,r,a){this.variableNames=["A"],this.outputShape=[];const[i,o,u,l]=e;this.outputShape=[i,n,s,l];const c=[r&&n>1?o-1:o,r&&s>1?u-1:u],d=[r&&n>1?n-1:n,r&&s>1?s-1:s];let h;a?h="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":h="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/d[0]},
          ${c[1]/d[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${h};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Tie{constructor(e,n,s,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,o,u,l]=e;this.outputShape=[i,n,s,l];const c=[r&&n>1?o-1:o,r&&s>1?u-1:u],d=[r&&n>1?n-1:n,r&&s>1?s-1:s];let h;a?h="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":h="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/d[0]},
          ${c[1]/d[1]},
          ${c[1]/d[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${h};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${s-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nie(t){const{inputs:e,backend:n,attrs:s}=t,{images:r}=e,{alignCorners:a,halfPixelCenters:i,size:o}=s,[u,l]=o,c=te().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Tie(r.shape,u,l,a,i):new Cie(r.shape,u,l,a,i);return n.runWebGLProgram(c,[r],"float32")}const Eie={kernelName:dh,backendName:"webgl",kernelFunc:Nie};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Aie{constructor(e,n,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,r,a]=n,[,i,o]=e,u=[s&&i>1?r-1:r,s&&o>1?a-1:a],l=[s&&i>1?i-1:i,s&&o>1?o-1:o],c=u[0]/l[0],d=u[1]/l[1],h=1/c,p=1/d,f=Math.ceil(h)*2+2,m=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${d});

        const float invHeightScale = float(${h});
        const float invWidthScale = float(${p});

        const int winHeight = int(${f});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rie(t){const{inputs:e,backend:n,attrs:s}=t,{images:r,dy:a}=e,{alignCorners:i}=s,o=new Aie(a.shape,r.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}const Die={kernelName:iy,backendName:"webgl",kernelFunc:Rie};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Oie{constructor(e,n,s,r,a){this.variableNames=["A"],this.outputShape=[];const[i,o,u,l]=e;this.outputShape=[i,n,s,l];const c=[r&&n>1?o-1:o,r&&s>1?u-1:u],d=[r&&n>1?n-1:n,r&&s>1?s-1:s],h=r?"0.5":"0.0";let p;a?p="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/d[0]},
          ${c[1]/d[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fie{constructor(e,n,s,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,o,u,l]=e;this.outputShape=[i,n,s,l];const c=[r&&n>1?o-1:o,r&&s>1?u-1:u],d=[r&&n>1?n-1:n,r&&s>1?s-1:s],h=r?"0.5":"0.0";let p;a?p="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/d[0]},
          ${c[1]/d[1]},
          ${c[1]/d[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${s-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zie(t){const{inputs:e,backend:n,attrs:s}=t,{images:r}=e,{alignCorners:a,halfPixelCenters:i,size:o}=s,[u,l]=o,c=te().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Fie(r.shape,u,l,a,i):new Oie(r.shape,u,l,a,i);return n.runWebGLProgram(c,[r],r.dtype)}const Lie={kernelName:ch,backendName:"webgl",kernelFunc:zie};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Pie{constructor(e,n,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,r,a]=n,[,i,o]=e,u=[s&&i>1?r-1:r,s&&o>1?a-1:a],l=[s&&i>1?i-1:i,s&&o>1?o-1:o],c=u[0]/l[0],d=u[1]/l[1],h=1/c,p=1/d,f=Math.ceil(h)*2+2,m=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${d});

        const float invHeightScale = float(${h});
        const float invWidthScale = float(${p});

        const int winHeight = int(${f});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float sourceFracRow =
              float(${u[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${u[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${a}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bie(t){const{inputs:e,backend:n,attrs:s}=t,{images:r,dy:a}=e,{alignCorners:i}=s,o=new Pie(a.shape,r.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}const Mie={kernelName:ay,backendName:"webgl",kernelFunc:Bie};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vie{constructor(e,n){this.variableNames=["x"];const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=e,s===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const r=o=>n.indexOf(o)!==-1&&e[o]!==1?`${e[o]} - coords[${o}] - 1`:`coords[${o}]`,a=e.map((o,u)=>r(u)).join(","),i=yt(s);this.userCode=`
      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wie{constructor(e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=e;const r=kn("rc",s),a=`${r[s-1]} + 1 < ${this.outputShape[s-1]}`,i=`${r[s-2]} + 1 < ${this.outputShape[s-2]}`,o=yt(s);s===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${a}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${o} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${u(r.slice())};
          if(${a}){
            result.g = ${l(r.slice())};
          }
          if(${i}) {
            result.b = ${c(r.slice())};
            if(${a}) {
              result.a = ${d(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function u(f){return h(f)}function l(f){return f[s-1]="("+f[s-1]+" + 1)",h(f)}function c(f){return f[s-2]="("+f[s-2]+" + 1)",h(f)}function d(f){return f[s-1]="("+f[s-1]+" + 1)",f[s-2]="("+f[s-2]+" + 1)",h(f)}function h(f){const m=e.map((b,$)=>p($,f)),g=m.join(","),y=m.slice(-2).join(",");return`getChannel(getX(${g}), vec2(${y}))`}function p(f,m){return n.indexOf(f)!==-1&&e[f]!==1?`${e[f]} - ${m[f]} - 1`:`${m[f]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uie(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{dims:a}=s,i=r.shape.length,o=Ye(a,r.shape);if(i===0)return Yn({inputs:{x:r},backend:n});const u=te().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Wie(r.shape,o):new Vie(r.shape,o);return n.runWebGLProgram(u,[r],r.dtype)}const Gie={kernelName:hh,backendName:"webgl",kernelFunc:Uie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hie{constructor(e,n){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=e[1],r=e[2];this.outputShape=e;let a="";typeof n=="number"?a=`float outputValue = ${n.toFixed(2)};`:a=`
        vec3 fill = vec3(${n.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${a}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${s}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qie={kernelName:Sy,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:s}=t,{radians:r,fillValue:a,center:i}=e,o=n,u=new Hie(s.shape,a),[l,c]=$b(i,s.shape[1],s.shape[2]),d=[[l,c,Math.sin(r),Math.cos(r)]];return o.runWebGLProgram(u,[s],s.dtype,d)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jie=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,Kie=it({opSnippet:jie}),Xie={kernelName:tl,backendName:"webgl",kernelFunc:Kie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yie="return inversesqrt(x);",Zie=it({opSnippet:Yie,cpuKernelImpl:cJ}),Qie={kernelName:nl,backendName:"webgl",kernelFunc:Zie};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class I0{constructor(e,n,s,r,a,i,o=!0,u=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;const l=yt(a.length),c=yt(i.length);let d="";s===1?d="i":s===2&&(d="i, j");const h=`getIndices(${d})`;let p="";r===1?p="i":r===2&&(p="i, coords[1]");const f=`getUpdates(${p})`;let m="";u&&(m="coords[0], coords[1]");const g=`getDefaultValue(${m})`,y=n>1?"strides[j]":"strides";this.userCode=`
        ${l} strides = ${l}(${a});

        void main() {
          ${c} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${n}; j++) {
              int index = round(${h});
              flattenedIndex += index * ${y};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${f};
              found = true;
            }
          }
          setOutput(mix(${g}, sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jie{constructor(e,n,s,r,a,i,o=!0,u=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i;const l=yt(a.length),c=yt(i.length);let d="";s===1?d="i":s===2&&(d="i, j");const h=`getIndices(${d})`;let p="";r===1?p="i":r===2&&(p="i, coords[1]");const f=`getUpdates(${p})`;let m="";u&&(m="coords[0], coords[1]");const g=`getDefaultValue(${m})`,y=n>1?"strides[j]":"strides",b=n>1?"strides[j + 1]":"strides";this.userCode=`
        ${l} strides = ${l}(${a});

        void main() {
          ${c} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${n}; j+=2) {
              ivec4 index = round(${h});
              flattenedIndex += index.xz * ${y};
              if (j + 1 < ${n}) {
                flattenedIndex += index.yw * ${b};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${f};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${g}, sum, found));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eoe(t){const{inputs:e,backend:n,attrs:s}=t,{indices:r,updates:a}=e,{shape:i}=s,{sliceRank:o,numUpdates:u,sliceSize:l,strides:c,outputSize:d}=xi(a,r,i),h=[d/l,l];if(d===0)return n.makeTensorInfo(i,r.dtype);const p=me({inputs:{x:r},backend:n,attrs:{shape:[u,o]}}),f=me({inputs:{x:a},backend:n,attrs:{shape:[u,l]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0]));let g;te().getBool("WEBGL_PACK")?g=new Jie(u,o,p.shape.length,f.shape.length,c,h):g=new I0(u,o,p.shape.length,f.shape.length,c,h);const y=n.runWebGLProgram(g,[f,p,m],f.dtype),b=me({inputs:{x:y},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(m),b}const toe={kernelName:oy,backendName:"webgl",kernelFunc:eoe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class noe{constructor(e,n,s,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,s];const a="while (left < right) {",i=`for (int i = 0; i < ${Math.ceil(Math.log2(n+1))}; ++i) { if (left >= right) break;`,o=te().getNumber("WEBGL_VERSION")===2?a:i,u=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${o}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${u} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function soe(t){const{inputs:e,backend:n,attrs:s}=t,{sortedSequence:r,values:a}=e,{side:i}=s,o=new noe(r.shape[0],r.shape[1],a.shape[1],i),u=[[r.shape[1]]];return n.runWebGLProgram(o,[r,a],"int32",u)}const roe={kernelName:ly,backendName:"webgl",kernelFunc:soe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aoe{constructor(e,n,s){this.variableNames=["c","a","b"],this.outputShape=n;let r,a;if(s>4)throw Error(`Where for rank ${s} is not yet supported`);if(s===1)a="resRC",r="resRC";else{const o=["resRC.x","resRC.y","resRC.z","resRC.w"],u=[],l=[];for(let c=0;c<n.length;c++)l.push(`${o[c]}`),c<e&&u.push(`${o[c]}`);r=u.join(),a=l.join()}const i=yt(s);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${a}));
        } else {
          setOutput(getB(${a}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ioe(t){const{inputs:e,backend:n}=t,{condition:s,t:r,e:a}=e,i=new aoe(s.shape.length,r.shape,r.shape.length);return n.runWebGLProgram(i,[s,r,a],Hn(r.dtype,a.dtype))}const ooe={kernelName:ph,backendName:"webgl",kernelFunc:ioe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uoe=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${Kh};
  float scale = ${Xh};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,loe=it({opSnippet:uoe}),coe={kernelName:sl,backendName:"webgl",kernelFunc:loe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const doe=So+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,hoe=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,poe=it({opSnippet:doe,packedOpSnippet:hoe,cpuKernelImpl:hJ}),foe={kernelName:ol,backendName:"webgl",kernelFunc:poe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const moe=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,goe=it({opSnippet:moe}),yoe={kernelName:il,backendName:"webgl",kernelFunc:goe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const boe=So+`
  return sin(x);
`,xoe=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Ii}
  return result;
`,woe=it({opSnippet:boe,packedOpSnippet:xoe}),$oe={kernelName:rl,backendName:"webgl",kernelFunc:woe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const voe=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,Soe=it({opSnippet:voe}),Ioe={kernelName:al,backendName:"webgl",kernelFunc:Soe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _oe=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,koe=it({opSnippet:_oe}),Coe={kernelName:ul,backendName:"webgl",kernelFunc:koe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Toe=t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockShape:a,paddings:i}=s;O(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const o=a.reduce((y,b)=>y*b),u=[[0,0]];u.push(...i);for(let y=1+a.length;y<r.shape.length;++y)u.push([0,0]);const l=[],c=yA({inputs:{x:r},backend:n,attrs:{paddings:u,constantValue:0}}),d=Il(c.shape,a,o,!1),h=_l(d.length,a.length,!1),p=kl(c.shape,a,o,!1),f=me({inputs:{x:c},backend:n,attrs:{shape:d}}),m=Tn({inputs:{x:f},backend:n,attrs:{perm:h}}),g=me({inputs:{x:m},backend:n,attrs:{shape:p}});return l.push(c),l.push(f),l.push(m),l.forEach(y=>n.disposeIntermediateTensorInfo(y)),g},Noe={kernelName:gh,backendName:"webgl",kernelFunc:Toe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eoe(t){const{inputs:e,backend:n}=t,{indices:s,values:r,denseShape:a,defaultValue:i}=e;if(a.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${a.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${r.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);const o=n.readSync(s.dataId),u=n.readSync(r.dataId),l=n.readSync(a.dataId),c=n.readSync(i.dataId)[0],[d,h,p,f,m]=fJ(o,s.shape,s.dtype,u,r.dtype,l,c);return[n.makeTensorInfo(h,s.dtype,d),n.makeTensorInfo([h[0]],r.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),n.makeTensorInfo([m.length],s.dtype,new Int32Array(m))]}const Aoe={kernelName:cy,backendName:"webgl",kernelFunc:Eoe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Roe(t){const{inputs:e,backend:n}=t,{inputIndices:s,inputShape:r,newShape:a}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(n.readSync(r.dataId)),o=n.readSync(s.dataId),u=Array.from(n.readSync(a.dataId)),[l,c,d]=mJ(o,s.shape,s.dtype,i,u);return[n.makeTensorInfo(c,s.dtype,l),n.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}const Doe={kernelName:dy,backendName:"webgl",kernelFunc:Roe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ooe(t){const{inputs:e,backend:n}=t,{data:s,indices:r,segmentIds:a}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${r.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${a.shape}`);const i=n.readSync(s.dataId),o=n.readSync(r.dataId),u=n.readSync(a.dataId),[l,c]=WE(i,s.shape,s.dtype,o,u,!0);return n.makeTensorInfo(c,s.dtype,l)}const Foe={kernelName:hy,backendName:"webgl",kernelFunc:Ooe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zoe(t){const{inputs:e,backend:n}=t,{data:s,indices:r,segmentIds:a}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${r.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${a.shape}`);const i=n.readSync(s.dataId),o=n.readSync(r.dataId),u=n.readSync(a.dataId),[l,c]=WE(i,s.shape,s.dtype,o,u);return n.makeTensorInfo(c,s.dtype,l)}const Loe={kernelName:py,backendName:"webgl",kernelFunc:zoe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Poe(t){const{inputs:e,backend:n,attrs:s}=t,{sparseIndices:r,sparseValues:a,defaultValue:i}=e,{outputShape:o}=s,{sliceRank:u,numUpdates:l,sliceSize:c,strides:d,outputSize:h}=xi(a,r,o),p=!1;if(a.dtype==="string"){const y=n.bufferSync(r),b=n.bufferSync(a),$=sa(n.readSync(i.dataId)[0]),w=dJ(y,b,o,h,c,l,u,d,$,p);return n.makeTensorInfo(o,w.dtype,w.values)}const f=new I0(l,u,r.shape.length,a.shape.length,d,[h,1],p),m=n.runWebGLProgram(f,[a,r,i],a.dtype),g=me({inputs:{x:m},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(m),g}const Boe={kernelName:fy,backendName:"webgl",kernelFunc:Poe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Moe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{numOrSizeSplits:a,axis:i}=s,o=Ye(i,r.shape)[0],u=zb(r,a,o),l=r.shape.length,c=new Array(l).fill(0),d=r.shape.slice();return u.map(h=>{const p=[...d];p[o]=h;const f=Io({inputs:{x:r},backend:n,attrs:{begin:c,size:p}});return c[o]+=h,f})}const Voe={kernelName:yh,backendName:"webgl",kernelFunc:Moe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A$="return sqrt(x);",Woe=it({opSnippet:A$,packedOpSnippet:A$,cpuKernelImpl:gJ}),Uoe={kernelName:ll,backendName:"webgl",kernelFunc:Woe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Goe="return x * x;",Hoe=it({opSnippet:Goe}),qoe={kernelName:my,backendName:"webgl",kernelFunc:Hoe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R$="return (a - b) * (a - b);",joe=gn({opSnippet:R$,packedOpSnippet:R$}),Koe={kernelName:cl,backendName:"webgl",kernelFunc:joe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xoe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");const a=n.readSync(r.dataId),i=Dr(a),o=yJ(i,"string",s);return n.makeTensorInfo(r.shape,"string",o)}const Yoe={kernelName:xh,backendName:"webgl",kernelFunc:Xoe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zoe({inputs:t,attrs:e,backend:n}){const{x:s}=t,r=Cs+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,a=new lr(s.shape,r);return n.runWebGLProgram(a,[s],s.dtype)}const Qoe={kernelName:ml,backendName:"webgl",kernelFunc:Zoe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Joe{constructor(e,n,s){this.variableNames=["x"],this.outputShape=s;const r=s.length,a=yt(s.length),i=yt(s.length);let o="";if(r===1)o="coords * strides + begin";else{let u=0;o=s.map((l,c)=>(u++,s.length===1?`coords * strides[${c}] + begin[${c}]`:`coords[${u-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`
      ${a} begin = ${a}(${e});
      ${a} strides = ${a}(${n});

      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eue(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{begin:a,end:i,strides:o,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=s,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:$,strides:w}=bb(r.shape,a,i,o,u,l,c,d,h);let v;if(m)v=me({inputs:{x:r},backend:n,attrs:{shape:f}});else if(g||y){O(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const C=mb(b,$,w),N=Io({inputs:{x:r},backend:n,attrs:{begin:b,size:C}});v=me({inputs:{x:N},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(N)}else if(n.shouldExecuteOnCPU([r])){const N=n.readSync(r.dataId),A=qe(r.shape,r.dtype,N),I=bJ(p,A,w,b);v=n.makeTensorInfo(f,r.dtype,I.values)}else{const N=new Joe(b,w,p);v=n.runWebGLProgram(N,[r],r.dtype)}const k=me({inputs:{x:v},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(v),k}const tue={kernelName:gy,backendName:"webgl",kernelFunc:eue};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nue(t){const{inputs:e,backend:n,attrs:s}=t,{separator:r,nGramWidths:a,leftPad:i,rightPad:o,padWidth:u,preserveShortSequences:l}=s,{data:c,dataSplits:d}=e,h=n.readSync(c.dataId),p=n.readSync(d.dataId),[f,m]=xJ(h,p,r,a,i,o,u,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}const sue={kernelName:yy,backendName:"webgl",kernelFunc:nue};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rue(t){const{inputs:e,backend:n,attrs:s}=t,{skipEmpty:r}=s,{input:a,delimiter:i}=e;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(a.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.readSync(a.dataId),u=n.readSync(i.dataId)[0],[l,c,d]=wJ(o,u,r),h=c.length;return[n.makeTensorInfo([h,2],"int32",l),n.makeTensorInfo([h],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}const aue={kernelName:by,backendName:"webgl",kernelFunc:rue};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iue(t){const{inputs:e,backend:n,attrs:s}=t,{numBuckets:r}=s,{input:a}=e;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const i=n.readSync(a.dataId),o=$J(i,r);return n.makeTensorInfo(a.shape,"int32",o)}const oue={kernelName:xy,backendName:"webgl",kernelFunc:iue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uue="return tan(x);",lue=it({opSnippet:uue}),cue={kernelName:hl,backendName:"webgl",kernelFunc:lue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const due=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,hue=it({opSnippet:due}),pue={kernelName:pl,backendName:"webgl",kernelFunc:hue};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fue(t){const{inputs:e,backend:n,attrs:s}=t,{tensor:r,indices:a,updates:i}=e,{sliceRank:o,numUpdates:u,sliceSize:l,strides:c,outputSize:d}=xi(i,a,r.shape),h=[d/l,l];if(d===0)return n.makeTensorInfo(r.shape,a.dtype);const p=me({inputs:{x:a},backend:n,attrs:{shape:[u,o]}}),f=me({inputs:{x:i},backend:n,attrs:{shape:[u,l]}}),m=me({inputs:{x:r},backend:n,attrs:{shape:h}}),g=new I0(u,o,p.shape.length,f.shape.length,c,h,!1,!0),y=n.runWebGLProgram(g,[f,p,m],m.dtype),b=me({inputs:{x:y},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),b}const mue={kernelName:uy,backendName:"webgl",kernelFunc:fue};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gue{constructor(e,n){this.variableNames=["A"];const s=new Array(e.length);for(let i=0;i<s.length;i++)s[i]=e[i]*n[i];this.outputShape=s,this.rank=s.length;const r=yt(this.rank),a=yue(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${a}));
      }
    `}}function yue(t){const e=t.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${t[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let r=0;r<t.length;r++)s.push(`imod(${n[r]}, ${t[r]})`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xA(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{reps:a}=s;if(r.dtype==="string"||r.shape.length>5){const u=n.readSync(r.dataId),l=r.dtype==="string"?u.map(h=>sa(h)):u,c=qe(r.shape,r.dtype,l),d=SJ(c,a);return n.makeTensorInfo(d.shape,d.dtype,d.values)}const i=new gue(r.shape,a);return n.runWebGLProgram(i,[r],r.dtype)}const bue={kernelName:fl,backendName:"webgl",kernelFunc:xA};class xue{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class wue{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ra(t,e){e!==null&&t.disposeIntermediateTensorInfo(e)}function D$(t){let e=1;for(;e<t;)e*=2;return e}function $ue(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{k:a,sorted:i}=s,o=te().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=te().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),l=r.shape,c=l[l.length-1];if(n.shouldExecuteOnCPU([r])||c<o||a>u){const I=n.readSync(r.dataId),[E,z]=IJ(I,l,r.dtype,a,i);return[n.makeTensorInfo(E.shape,E.dtype,E.values),n.makeTensorInfo(z.shape,z.dtype,z.values)]}if(a===0)return l[l.length-1]=0,[n.makeTensorInfo(l,r.dtype,[]),n.makeTensorInfo(l,"int32",[])];if(c===1)return[r,Ml({attrs:{shape:l,dtype:"int32",value:0},backend:n})];const d=n.texData.get(r.dataId),h=d!==null&&d.isPacked,p=h?n.unpackTensor(r):r,m=se(l)/c,g=me({inputs:{x:p},attrs:{shape:[m,c]},backend:n});h&&Ra(n,p);const y=D$(a),b=D$(c);let $=null;const w=()=>$===null?[g,g]:[g,$],v=(I,E,z)=>{const P=w(),H=new xue(z),W=[[c],[$===null?1:0],[Number.NEGATIVE_INFINITY],[I],[E]],L=$;$=n.runWebGLProgram(H,P,"int32",W),Ra(n,L)};for(let I=1;I<y;I*=2){const E=I*2;for(let z=I;z>=1;z/=2)v(E,z,[m,b])}for(let I=b;I>y;I/=2){const E=w(),z=new wue([m,I/2]),H=[[c],[$===null?1:0],[y]],G=$;$=n.runWebGLProgram(z,E,"int32",H),Ra(n,G);const W=y/2,L=W*2;for(let B=W;B>=1;B/=2)v(L,B,$.shape)}let k=$;$=Io({inputs:{x:$},backend:n,attrs:{begin:0,size:[m,a]}}),Ra(n,k);let C=dA({inputs:{x:g,indices:$},backend:n,attrs:{axis:1,batchDims:1}});Ra(n,g);const N=l.slice(0,-1);N.push(a),k=$,$=me({inputs:{x:$},attrs:{shape:N},backend:n}),Ra(n,k);const A=C;return C=me({inputs:{x:C},attrs:{shape:N},backend:n}),Ra(n,A),[C,$]}const vue={kernelName:wy,backendName:"webgl",kernelFunc:$ue};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Sue{constructor(e,n,s,r,a,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const o=s==="nearest"?1:2;let u;switch(r){case"constant":u=1;break;case"reflect":u=2;break;case"wrap":u=3;break;case"nearest":u=4;break;default:u=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${u} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${n}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${a});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${a});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${n}));
                float mapY = mapCoord(inY, float(${e}));

                if (${o} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iue(t){const{inputs:e,backend:n,attrs:s}=t,{image:r,transforms:a}=e,{interpolation:i,fillMode:o,fillValue:u,outputShape:l}=s,[c,d,h,p]=r.shape,[f,m]=l??[d,h],g=[c,f,m,p],y=new Sue(d,h,i,o,u,g);return n.runWebGLProgram(y,[r,a],"float32")}const _ue={kernelName:$y,backendName:"webgl",kernelFunc:Iue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kue(t){const{inputs:e,attrs:n,backend:s}=t,{axis:r}=n,{x:a}=e;Ll(a,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=s.readSync(a.dataId),{outputValues:o,outputShape:u,indices:l}=_J(i,r,a.shape,a.dtype);return[s.makeTensorInfo(u,a.dtype,o),s.makeTensorInfo([l.length],"int32",l)]}const Cue={kernelName:vy,backendName:"webgl",kernelFunc:kue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tue(t){const{inputs:e,backend:n,attrs:s}=t,{value:r}=e;let{axis:a}=s;a<0&&(a+=r.shape.length);const i=r,o=i.shape.length,u=r.shape[a],l=new Array(o-1);let c=0;for(let m=0;m<o;m++)m!==a&&(l[c++]=i.shape[m]);const d=[],h=new Array(o).fill(0),p=i.shape.slice();p[a]=1;const f=new Array(u);for(let m=0;m<f.length;m++){h[a]=m;const g=Io({inputs:{x:i},backend:n,attrs:{begin:h,size:p}}),y=me({inputs:{x:g},backend:n,attrs:{shape:l}});f[m]=y,d.push(g)}return d.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}const Nue={kernelName:wh,backendName:"webgl",kernelFunc:Tue};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Eue{constructor(e,n){this.variableNames=["x","segmentIds"];const s=e.windowSize,r=e.batchSize,a=e.inSize,i=e.numSegments,o=i*Math.ceil(a/s);this.outputShape=[r,o];const u="0.0",l="sumValue",c=Math.floor(s/4)*4,d=s%4,h=`
        sumValue += dot(values, segFilter);
    `;let p="";a%s>0&&(p=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `);let f="";a%s>0&&(f=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${u};

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${f}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${i})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${i})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${h}
        }

        int inIdx = inOffset + ${c};
        if (${d===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${h}
        } else if (${d===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${h}
        } else if (${d===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${h}
        }
        setOutput(${l});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aue(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,segmentIds:a}=e,{numSegments:i}=s,o=r.shape.length,u=[];let l=0;const c=At([l],o);let d=r;c!=null&&(d=Tn({inputs:{x:r},backend:n,attrs:{perm:c}}),u.push(d),l=Pt(1,o)[0]);const h=Zk(d.shape,l,i),p=se([d.shape[l]]),f=me({inputs:{x:d},backend:n,attrs:{shape:[-1,p]}});u.push(f);const m=Iy(r.dtype),g=(w,v,k,C,N)=>{const A=w.shape[0],I=w.shape[1],E=Yk(I,N),z={windowSize:E,inSize:I,batchSize:A,numSegments:N},P=new Eue(z,v),H=n.compileAndRun(P,[w,k],C);if(u.push(H),H.shape[1]===N)return H;const G=bA({backend:n,attrs:{start:0,stop:N,step:1,dtype:"float32"}}),W=xA({inputs:{x:G},backend:n,attrs:{reps:[I/E]}});return u.push(G),u.push(W),g(H,v,W,C,N)},y=g(f,"unsortedSegmentSum",a,m,i),b=me({inputs:{x:y},backend:n,attrs:{shape:h}});let $=b;if(c!=null){u.push(b);const w=xa(c);$=Tn({inputs:{x:$},backend:n,attrs:{perm:w}})}return u.forEach(w=>n.disposeIntermediateTensorInfo(w)),$}const Rue={kernelName:$h,backendName:"webgl",kernelFunc:Aue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Due=[gee,bee,$ee,Iee,kee,Nee,Aee,Dee,Lee,Bee,Wee,Hee,Kee,Qee,tte,ste,ate,lte,dte,pte,yte,Ite,kte,Ete,Rte,Pte,Mte,Gte,JJ,jte,Qte,nne,une,dne,pne,mne,yne,$ne,Ine,Cne,Nne,Ane,Dne,zne,Pne,Wne,Gne,jne,Yne,Qne,nse,ise,cse,pse,gse,yse,xse,$se,Sse,_se,Cse,Ase,Ose,Lse,Bse,Wse,Hse,Xse,Jse,QJ,tre,Yte,rre,ore,cre,tee,fre,bre,wre,Ire,Cre,Are,Ore,Pre,Wre,Hre,jre,Zre,Jre,tae,aae,oae,lae,dae,pae,yae,$ae,_ae,Dae,ree,Lae,Mae,Uae,qae,Ote,Xae,Zae,Jae,nie,iie,see,uie,cie,hie,fie,mie,Fte,Nae,bie,vie,kie,iee,Eie,Die,Lie,Mie,Gie,qie,Xie,Qie,toe,roe,ooe,coe,foe,yoe,$oe,Ioe,vte,Aae,Coe,Noe,Aoe,Doe,Foe,Loe,Boe,Voe,Uoe,qoe,Koe,Yoe,Qoe,tue,sue,aue,oue,Eae,pee,cue,pue,mue,bue,vue,_ue,fee,Cue,Nue,Rue,Yae];for(const t of Due)$I(t);/*!
 * ONNX Runtime Web v1.23.0-dev.20250731-e753643480
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */var _0=Object.defineProperty,Oue=Object.getOwnPropertyDescriptor,Fue=Object.getOwnPropertyNames,zue=Object.prototype.hasOwnProperty,Lue=(t=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(t,{get:(e,n)=>(typeof require<"u"?require:e)[n]}):t)(function(t){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+t+'" is not supported')}),he=(t,e)=>()=>(t&&(e=t(t=0)),e),_o=(t,e)=>{for(var n in e)_0(t,n,{get:e[n],enumerable:!0})},Pue=(t,e,n,s)=>{if(e&&typeof e=="object"||typeof e=="function")for(let r of Fue(e))!zue.call(t,r)&&r!==n&&_0(t,r,{get:()=>e[r],enumerable:!(s=Oue(e,r))||s.enumerable});return t},bu=t=>Pue(_0({},"__esModule",{value:!0}),t),Do,qr,Li,O$,wA,$A=he(()=>{Do=new Map,qr=[],Li=(t,e,n)=>{if(e&&typeof e.init=="function"&&typeof e.createInferenceSessionHandler=="function"){let s=Do.get(t);if(s===void 0)Do.set(t,{backend:e,priority:n});else{if(s.priority>n)return;if(s.priority===n&&s.backend!==e)throw new Error(`cannot register backend "${t}" using priority ${n}`)}if(n>=0){let r=qr.indexOf(t);r!==-1&&qr.splice(r,1);for(let a=0;a<qr.length;a++)if(Do.get(qr[a]).priority<=n){qr.splice(a,0,t);return}qr.push(t)}return}throw new TypeError("not a valid backend")},O$=async t=>{let e=Do.get(t);if(!e)return"backend not found.";if(e.initialized)return e.backend;if(e.aborted)return e.error;{let n=!!e.initPromise;try{return n||(e.initPromise=e.backend.init(t)),await e.initPromise,e.initialized=!0,e.backend}catch(s){return n||(e.error=`${s}`,e.aborted=!0),e.error}finally{delete e.initPromise}}},wA=async t=>{let e=t.executionProviders||[],n=e.map(u=>typeof u=="string"?u:u.name),s=n.length===0?qr:n,r,a=[],i=new Set;for(let u of s){let l=await O$(u);typeof l=="string"?a.push({name:u,err:l}):(r||(r=l),r===l&&i.add(u))}if(!r)throw new Error(`no available backend found. ERR: ${a.map(u=>`[${u.name}] ${u.err}`).join(", ")}`);for(let{name:u,err:l}of a)n.includes(u)&&console.warn(`removing requested execution provider "${u}" from session options because it is not available: ${l}`);let o=e.filter(u=>i.has(typeof u=="string"?u:u.name));return[r,new Proxy(t,{get:(u,l)=>l==="executionProviders"?o:Reflect.get(u,l)})]}}),Bue=he(()=>{$A()}),vA,Mue=he(()=>{vA="1.23.0-dev.20250703-7fc6235861"}),af,on,SA=he(()=>{Mue(),af="warning",on={wasm:{},webgl:{},webgpu:{},versions:{common:vA},set logLevel(t){if(t!==void 0){if(typeof t!="string"||["verbose","info","warning","error","fatal"].indexOf(t)===-1)throw new Error(`Unsupported logging level: ${t}`);af=t}},get logLevel(){return af}},Object.defineProperty(on,"logLevel",{enumerable:!0})}),gt,Vue=he(()=>{SA(),gt=on}),IA,_A,Wue=he(()=>{IA=(t,e)=>{let n=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);n.width=t.dims[3],n.height=t.dims[2];let s=n.getContext("2d");if(s!=null){let r,a;(e==null?void 0:e.tensorLayout)!==void 0&&e.tensorLayout==="NHWC"?(r=t.dims[2],a=t.dims[3]):(r=t.dims[3],a=t.dims[2]);let i=(e==null?void 0:e.format)!==void 0?e.format:"RGB",o=e==null?void 0:e.norm,u,l;o===void 0||o.mean===void 0?u=[255,255,255,255]:typeof o.mean=="number"?u=[o.mean,o.mean,o.mean,o.mean]:(u=[o.mean[0],o.mean[1],o.mean[2],0],o.mean[3]!==void 0&&(u[3]=o.mean[3])),o===void 0||o.bias===void 0?l=[0,0,0,0]:typeof o.bias=="number"?l=[o.bias,o.bias,o.bias,o.bias]:(l=[o.bias[0],o.bias[1],o.bias[2],0],o.bias[3]!==void 0&&(l[3]=o.bias[3]));let c=a*r,d=0,h=c,p=c*2,f=-1;i==="RGBA"?(d=0,h=c,p=c*2,f=c*3):i==="RGB"?(d=0,h=c,p=c*2):i==="RBG"&&(d=0,p=c,h=c*2);for(let m=0;m<a;m++)for(let g=0;g<r;g++){let y=(t.data[d++]-l[0])*u[0],b=(t.data[h++]-l[1])*u[1],$=(t.data[p++]-l[2])*u[2],w=f===-1?255:(t.data[f++]-l[3])*u[3];s.fillStyle="rgba("+y+","+b+","+$+","+w+")",s.fillRect(g,m,1,1)}if("toDataURL"in n)return n.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},_A=(t,e)=>{let n=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),s;if(n!=null){let r,a,i;(e==null?void 0:e.tensorLayout)!==void 0&&e.tensorLayout==="NHWC"?(r=t.dims[2],a=t.dims[1],i=t.dims[3]):(r=t.dims[3],a=t.dims[2],i=t.dims[1]);let o=e!==void 0&&e.format!==void 0?e.format:"RGB",u=e==null?void 0:e.norm,l,c;u===void 0||u.mean===void 0?l=[255,255,255,255]:typeof u.mean=="number"?l=[u.mean,u.mean,u.mean,u.mean]:(l=[u.mean[0],u.mean[1],u.mean[2],255],u.mean[3]!==void 0&&(l[3]=u.mean[3])),u===void 0||u.bias===void 0?c=[0,0,0,0]:typeof u.bias=="number"?c=[u.bias,u.bias,u.bias,u.bias]:(c=[u.bias[0],u.bias[1],u.bias[2],0],u.bias[3]!==void 0&&(c[3]=u.bias[3]));let d=a*r;if(e!==void 0&&(e.format!==void 0&&i===4&&e.format!=="RGBA"||i===3&&e.format!=="RGB"&&e.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let h=4,p=0,f=1,m=2,g=3,y=0,b=d,$=d*2,w=-1;o==="RGBA"?(y=0,b=d,$=d*2,w=d*3):o==="RGB"?(y=0,b=d,$=d*2):o==="RBG"&&(y=0,$=d,b=d*2),s=n.createImageData(r,a);for(let v=0;v<a*r;p+=h,f+=h,m+=h,g+=h,v++)s.data[p]=(t.data[y++]-c[0])*l[0],s.data[f]=(t.data[b++]-c[1])*l[1],s.data[m]=(t.data[$++]-c[2])*l[2],s.data[g]=w===-1?255:(t.data[w++]-c[3])*l[3]}else throw new Error("Can not access image data");return s}}),dc,kA,CA,TA,NA,EA,Uue=he(()=>{k0(),dc=(t,e)=>{if(t===void 0)throw new Error("Image buffer must be defined");if(e.height===void 0||e.width===void 0)throw new Error("Image height and width must be defined");if(e.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:n,width:s}=e,r=e.norm??{mean:255,bias:0},a,i;typeof r.mean=="number"?a=[r.mean,r.mean,r.mean,r.mean]:a=[r.mean[0],r.mean[1],r.mean[2],r.mean[3]??255],typeof r.bias=="number"?i=[r.bias,r.bias,r.bias,r.bias]:i=[r.bias[0],r.bias[1],r.bias[2],r.bias[3]??0];let o=e.format!==void 0?e.format:"RGBA",u=e.tensorFormat!==void 0&&e.tensorFormat!==void 0?e.tensorFormat:"RGB",l=n*s,c=u==="RGBA"?new Float32Array(l*4):new Float32Array(l*3),d=4,h=0,p=1,f=2,m=3,g=0,y=l,b=l*2,$=-1;o==="RGB"&&(d=3,h=0,p=1,f=2,m=-1),u==="RGBA"?$=l*3:u==="RBG"?(g=0,b=l,y=l*2):u==="BGR"&&(b=0,y=l,g=l*2);for(let w=0;w<l;w++,h+=d,f+=d,p+=d,m+=d)c[g++]=(t[h]+i[0])/a[0],c[y++]=(t[p]+i[1])/a[1],c[b++]=(t[f]+i[2])/a[2],$!==-1&&m!==-1&&(c[$++]=(t[m]+i[3])/a[3]);return u==="RGBA"?new es("float32",c,[1,4,n,s]):new es("float32",c,[1,3,n,s])},kA=async(t,e)=>{let n=typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement,s=typeof ImageData<"u"&&t instanceof ImageData,r=typeof ImageBitmap<"u"&&t instanceof ImageBitmap,a=typeof t=="string",i,o=e??{},u=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},l=c=>typeof HTMLCanvasElement<"u"&&c instanceof HTMLCanvasElement||c instanceof OffscreenCanvas?c.getContext("2d"):null;if(n){let c=u();c.width=t.width,c.height=t.height;let d=l(c);if(d!=null){let h=t.height,p=t.width;if(e!==void 0&&e.resizedHeight!==void 0&&e.resizedWidth!==void 0&&(h=e.resizedHeight,p=e.resizedWidth),e!==void 0){if(o=e,e.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");o.tensorFormat="RGBA",o.height=h,o.width=p}else o.tensorFormat="RGBA",o.height=h,o.width=p;d.drawImage(t,0,0),i=d.getImageData(0,0,p,h).data}else throw new Error("Can not access image data")}else if(s){let c,d;if(e!==void 0&&e.resizedWidth!==void 0&&e.resizedHeight!==void 0?(c=e.resizedHeight,d=e.resizedWidth):(c=t.height,d=t.width),e!==void 0&&(o=e),o.format="RGBA",o.height=c,o.width=d,e!==void 0){let h=u();h.width=d,h.height=c;let p=l(h);if(p!=null)p.putImageData(t,0,0),i=p.getImageData(0,0,d,c).data;else throw new Error("Can not access image data")}else i=t.data}else if(r){if(e===void 0)throw new Error("Please provide image config with format for Imagebitmap");let c=u();c.width=t.width,c.height=t.height;let d=l(c);if(d!=null){let h=t.height,p=t.width;return d.drawImage(t,0,0,p,h),i=d.getImageData(0,0,p,h).data,o.height=h,o.width=p,dc(i,o)}else throw new Error("Can not access image data")}else{if(a)return new Promise((c,d)=>{let h=u(),p=l(h);if(!t||!p)return d();let f=new Image;f.crossOrigin="Anonymous",f.src=t,f.onload=()=>{h.width=f.width,h.height=f.height,p.drawImage(f,0,0,h.width,h.height);let m=p.getImageData(0,0,h.width,h.height);o.height=h.height,o.width=h.width,c(dc(m.data,o))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(i!==void 0)return dc(i,o);throw new Error("Input data provided is not supported - aborted tensor creation")},CA=(t,e)=>{let{width:n,height:s,download:r,dispose:a}=e,i=[1,s,n,4];return new es({location:"texture",type:"float32",texture:t,dims:i,download:r,dispose:a})},TA=(t,e)=>{let{dataType:n,dims:s,download:r,dispose:a}=e;return new es({location:"gpu-buffer",type:n??"float32",gpuBuffer:t,dims:s,download:r,dispose:a})},NA=(t,e)=>{let{dataType:n,dims:s,download:r,dispose:a}=e;return new es({location:"ml-tensor",type:n??"float32",mlTensor:t,dims:s,download:r,dispose:a})},EA=(t,e,n)=>new es({location:"cpu-pinned",type:t,data:e,dims:n??[e.length]})}),Wa,Yo,of,AA,Gue=he(()=>{Wa=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),Yo=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),of=!1,AA=()=>{if(!of){of=!0;let t=typeof BigInt64Array<"u"&&BigInt64Array.from,e=typeof BigUint64Array<"u"&&BigUint64Array.from,n=globalThis.Float16Array,s=typeof n<"u"&&n.from;t&&(Wa.set("int64",BigInt64Array),Yo.set(BigInt64Array,"int64")),e&&(Wa.set("uint64",BigUint64Array),Yo.set(BigUint64Array,"uint64")),s?(Wa.set("float16",n),Yo.set(n,"float16")):Wa.set("float16",Uint16Array)}}}),RA,DA,Hue=he(()=>{k0(),RA=t=>{let e=1;for(let n=0;n<t.length;n++){let s=t[n];if(typeof s!="number"||!Number.isSafeInteger(s))throw new TypeError(`dims[${n}] must be an integer, got: ${s}`);if(s<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${s}`);e*=s}return e},DA=(t,e)=>{switch(t.location){case"cpu":return new es(t.type,t.data,e);case"cpu-pinned":return new es({location:"cpu-pinned",data:t.data,type:t.type,dims:e});case"texture":return new es({location:"texture",texture:t.texture,type:t.type,dims:e});case"gpu-buffer":return new es({location:"gpu-buffer",gpuBuffer:t.gpuBuffer,type:t.type,dims:e});case"ml-tensor":return new es({location:"ml-tensor",mlTensor:t.mlTensor,type:t.type,dims:e});default:throw new Error(`tensorReshape: tensor location ${t.location} is not supported`)}}}),es,k0=he(()=>{Wue(),Uue(),Gue(),Hue(),es=class{constructor(t,e,n){AA();let s,r;if(typeof t=="object"&&"location"in t)switch(this.dataLocation=t.location,s=t.type,r=t.dims,t.location){case"cpu-pinned":{let i=Wa.get(s);if(!i)throw new TypeError(`unsupported type "${s}" to create tensor from pinned buffer`);if(!(t.data instanceof i))throw new TypeError(`buffer should be of type ${i.name}`);this.cpuData=t.data;break}case"texture":{if(s!=="float32")throw new TypeError(`unsupported type "${s}" to create tensor from texture`);this.gpuTextureData=t.texture,this.downloader=t.download,this.disposer=t.dispose;break}case"gpu-buffer":{if(s!=="float32"&&s!=="float16"&&s!=="int32"&&s!=="int64"&&s!=="uint32"&&s!=="uint8"&&s!=="bool"&&s!=="uint4"&&s!=="int4")throw new TypeError(`unsupported type "${s}" to create tensor from gpu buffer`);this.gpuBufferData=t.gpuBuffer,this.downloader=t.download,this.disposer=t.dispose;break}case"ml-tensor":{if(s!=="float32"&&s!=="float16"&&s!=="int32"&&s!=="int64"&&s!=="uint32"&&s!=="uint64"&&s!=="int8"&&s!=="uint8"&&s!=="bool"&&s!=="uint4"&&s!=="int4")throw new TypeError(`unsupported type "${s}" to create tensor from MLTensor`);this.mlTensorData=t.mlTensor,this.downloader=t.download,this.disposer=t.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let i,o;if(typeof t=="string")if(s=t,o=n,t==="string"){if(!Array.isArray(e))throw new TypeError("A string tensor's data must be a string array.");i=e}else{let u=Wa.get(t);if(u===void 0)throw new TypeError(`Unsupported tensor type: ${t}.`);if(Array.isArray(e)){if(t==="float16"&&u===Uint16Array||t==="uint4"||t==="int4")throw new TypeError(`Creating a ${t} tensor from number array is not supported. Please use ${u.name} as data.`);t==="uint64"||t==="int64"?i=u.from(e,BigInt):i=u.from(e)}else if(e instanceof u)i=e;else if(e instanceof Uint8ClampedArray)if(t==="uint8")i=Uint8Array.from(e);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else if(t==="float16"&&e instanceof Uint16Array&&u!==Uint16Array)i=new globalThis.Float16Array(e.buffer,e.byteOffset,e.length);else throw new TypeError(`A ${s} tensor's data must be type of ${u}`)}else if(o=e,Array.isArray(t)){if(t.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let u=typeof t[0];if(u==="string")s="string",i=t;else if(u==="boolean")s="bool",i=Uint8Array.from(t);else throw new TypeError(`Invalid element type of data array: ${u}.`)}else if(t instanceof Uint8ClampedArray)s="uint8",i=Uint8Array.from(t);else{let u=Yo.get(t.constructor);if(u===void 0)throw new TypeError(`Unsupported type for tensor data: ${t.constructor}.`);s=u,i=t}if(o===void 0)o=[i.length];else if(!Array.isArray(o))throw new TypeError("A tensor's dims must be a number array");r=o,this.cpuData=i,this.dataLocation="cpu"}let a=RA(r);if(this.cpuData&&a!==this.cpuData.length&&!((s==="uint4"||s==="int4")&&Math.ceil(a/2)===this.cpuData.length))throw new Error(`Tensor's size(${a}) does not match data length(${this.cpuData.length}).`);this.type=s,this.dims=r,this.size=a}static async fromImage(t,e){return kA(t,e)}static fromTexture(t,e){return CA(t,e)}static fromGpuBuffer(t,e){return TA(t,e)}static fromMLTensor(t,e){return NA(t,e)}static fromPinnedBuffer(t,e,n){return EA(t,e,n)}toDataURL(t){return IA(this,t)}toImageData(t){return _A(this,t)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(t){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let e=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=e,t&&this.disposer&&(this.disposer(),this.disposer=void 0),e}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(t){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return DA(this,t)}}}),Gs,OA=he(()=>{k0(),Gs=es}),hd,uf,br,js,Xa,Ya,FA=he(()=>{SA(),hd=(t,e)=>{(typeof on.trace>"u"?!on.wasm.trace:!on.trace)||console.timeStamp(`${t}::ORT::${e}`)},uf=(t,e)=>{var r;let n=((r=new Error().stack)==null?void 0:r.split(/\r\n|\r|\n/g))||[],s=!1;for(let a=0;a<n.length;a++){if(s&&!n[a].includes("TRACE_FUNC")){let i=`FUNC_${t}::${n[a].trim().split(" ")[1]}`;e&&(i+=`::${e}`),hd("CPU",i);return}n[a].includes("TRACE_FUNC")&&(s=!0)}},br=t=>{(typeof on.trace>"u"?!on.wasm.trace:!on.trace)||uf("BEGIN",t)},js=t=>{(typeof on.trace>"u"?!on.wasm.trace:!on.trace)||uf("END",t)},Xa=t=>{(typeof on.trace>"u"?!on.wasm.trace:!on.trace)||console.time(`ORT::${t}`)},Ya=t=>{(typeof on.trace>"u"?!on.wasm.trace:!on.trace)||console.timeEnd(`ORT::${t}`)}}),zA,que=he(()=>{$A(),OA(),FA(),zA=class LA{constructor(e){this.handler=e}async run(e,n,s){br(),Xa("InferenceSession.run");let r={},a={};if(typeof e!="object"||e===null||e instanceof Gs||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let i=!0;if(typeof n=="object"){if(n===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(n instanceof Gs)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(n)){if(n.length===0)throw new TypeError("'fetches' cannot be an empty array.");i=!1;for(let l of n){if(typeof l!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(l)===-1)throw new RangeError(`'fetches' contains invalid output name: ${l}.`);r[l]=null}if(typeof s=="object"&&s!==null)a=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else{let l=!1,c=Object.getOwnPropertyNames(n);for(let d of this.outputNames)if(c.indexOf(d)!==-1){let h=n[d];(h===null||h instanceof Gs)&&(l=!0,i=!1,r[d]=h)}if(l){if(typeof s=="object"&&s!==null)a=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else a=n}}else if(typeof n<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let l of this.inputNames)if(typeof e[l]>"u")throw new Error(`input '${l}' is missing in 'feeds'.`);if(i)for(let l of this.outputNames)r[l]=null;let o=await this.handler.run(e,r,a),u={};for(let l in o)if(Object.hasOwnProperty.call(o,l)){let c=o[l];c instanceof Gs?u[l]=c:u[l]=new Gs(c.type,c.data,c.dims)}return Ya("InferenceSession.run"),js(),u}async release(){return this.handler.dispose()}static async create(e,n,s,r){br(),Xa("InferenceSession.create");let a,i={};if(typeof e=="string"){if(a=e,typeof n=="object"&&n!==null)i=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(a=e,typeof n=="object"&&n!==null)i=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&e instanceof SharedArrayBuffer){let c=e,d=0,h=e.byteLength;if(typeof n=="object"&&n!==null)i=n;else if(typeof n=="number"){if(d=n,!Number.isSafeInteger(d))throw new RangeError("'byteOffset' must be an integer.");if(d<0||d>=c.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${c.byteLength}).`);if(h=e.byteLength-d,typeof s=="number"){if(h=s,!Number.isSafeInteger(h))throw new RangeError("'byteLength' must be an integer.");if(h<=0||d+h>c.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${c.byteLength-d}].`);if(typeof r=="object"&&r!==null)i=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(typeof s<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof n<"u")throw new TypeError("'options' must be an object.");a=new Uint8Array(c,d,h)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[o,u]=await wA(i),l=await o.createInferenceSessionHandler(a,u);return Ya("InferenceSession.create"),js(),new LA(l)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}get inputMetadata(){return this.handler.inputMetadata}get outputMetadata(){return this.handler.outputMetadata}}}),C0,jue=he(()=>{que(),C0=zA}),Kue=he(()=>{}),Xue=he(()=>{}),Yue=he(()=>{}),Zue=he(()=>{}),Que={};_o(Que,{InferenceSession:()=>C0,TRACE:()=>hd,TRACE_EVENT_BEGIN:()=>Xa,TRACE_EVENT_END:()=>Ya,TRACE_FUNC_BEGIN:()=>br,TRACE_FUNC_END:()=>js,Tensor:()=>Gs,env:()=>gt,registerBackend:()=>Li});var Ts=he(()=>{Bue(),Vue(),jue(),OA(),Kue(),Xue(),FA(),Yue(),Zue()}),T0=he(()=>{}),PA={};_o(PA,{default:()=>BA});var lf,cf,BA,Jue=he(()=>{var t;GO(),ki(),N0(),lf="ort-wasm-proxy-worker",cf=((t=globalThis.self)==null?void 0:t.name)===lf,cf&&(self.onmessage=e=>{let{type:n,in:s}=e.data;try{switch(n){case"init-wasm":E0(s.wasm).then(()=>{j0(s).then(()=>{postMessage({type:n})},r=>{postMessage({type:n,err:r})})},r=>{postMessage({type:n,err:r})});break;case"init-ep":{let{epName:r,env:a}=s;K0(a,r).then(()=>{postMessage({type:n})},i=>{postMessage({type:n,err:i})});break}case"copy-from":{let{buffer:r}=s,a=xd(r);postMessage({type:n,out:a});break}case"create":{let{model:r,options:a}=s;X0(r,a).then(i=>{postMessage({type:n,out:i})},i=>{postMessage({type:n,err:i})});break}case"release":Y0(s),postMessage({type:n});break;case"run":{let{sessionId:r,inputIndices:a,inputs:i,outputIndices:o,options:u}=s;Z0(r,a,i,o,new Array(o.length).fill(null),u).then(l=>{l.some(c=>c[3]!=="cpu")?postMessage({type:n,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:n,out:l},J0([...i,...l]))},l=>{postMessage({type:n,err:l})});break}case"end-profiling":Q0(s),postMessage({type:n});break;default:}}catch(r){postMessage({type:n,err:r})}}),BA=cf?null:e=>new Worker(e??Jn,{type:"module",name:lf})}),MA={};_o(MA,{default:()=>VA});async function F$(t={}){var Vw;var e=t,n=typeof window=="object",s=typeof WorkerGlobalScope<"u",r=s&&((Vw=self.name)==null?void 0:Vw.startsWith("em-pthread"));e.mountExternalData=(x,S)=>{x.startsWith("./")&&(x=x.substring(2)),(e.Zc||(e.Zc=new Map)).set(x,S)},e.unmountExternalData=()=>{delete e.Zc};var a=globalThis.SharedArrayBuffer??new WebAssembly.Memory({initial:0,maximum:0,be:!0}).buffer.constructor;let i=x=>async(...S)=>{var T;try{if(e.$c)throw Error("Session already started");let D=e.$c={Nd:S[0],errors:[]},R=await x(...S);if(e.$c!==D)throw Error("Session mismatch");(T=e.gd)==null||T.flush();let V=D.errors;if(0<V.length){let Q=await Promise.all(V);if(Q=Q.filter(ie=>ie),0<Q.length)throw Error(Q.join(`
`))}return R}finally{e.$c=null}};e.jsepInit=(x,S)=>{if(x==="webgpu"){[e.gd,e.Dd,e.Hd,e.jd,e.Gd,e.ac,e.Id,e.Kd,e.Ed,e.Fd,e.Jd]=S;let T=e.gd;e.jsepRegisterBuffer=(D,R,V,Q)=>T.registerBuffer(D,R,V,Q),e.jsepGetBuffer=D=>T.getBuffer(D),e.jsepCreateDownloader=(D,R,V)=>T.createDownloader(D,R,V),e.jsepOnCreateSession=D=>{T.onCreateSession(D)},e.jsepOnReleaseSession=D=>{T.onReleaseSession(D)},e.jsepOnRunStart=D=>T.onRunStart(D),e.Ld=(D,R)=>{T.upload(D,R)}}else if(x==="webnn"){let T=S[0];[e.$d,e.wd,e.webnnEnsureTensor,e.xd,e.webnnDownloadTensor,e.Zd,e.webnnEnableTraceEvent]=S.slice(1),e.webnnReleaseTensorId=e.wd,e.webnnUploadTensor=e.xd,e.webnnRegisterMLContext=e.Zd,e.webnnOnRunStart=D=>T.onRunStart(D),e.webnnOnRunEnd=T.onRunEnd.bind(T),e.webnnOnReleaseSession=D=>{T.onReleaseSession(D)},e.webnnCreateMLTensorDownloader=(D,R)=>T.createMLTensorDownloader(D,R),e.webnnRegisterMLTensor=(D,R,V,Q)=>T.registerMLTensor(D,R,V,Q),e.webnnCreateMLContext=D=>T.createMLContext(D),e.webnnRegisterMLConstant=(D,R,V,Q,ie,pe)=>T.registerMLConstant(D,R,V,Q,ie,e.Zc,pe),e.webnnRegisterGraphInput=T.registerGraphInput.bind(T),e.webnnIsGraphInput=T.isGraphInput.bind(T),e.webnnRegisterGraphOutput=T.registerGraphOutput.bind(T),e.webnnIsGraphOutput=T.isGraphOutput.bind(T),e.webnnCreateTemporaryTensor=T.createTemporaryTensor.bind(T),e.webnnIsGraphInputOutputTypeSupported=T.isGraphInputOutputTypeSupported.bind(T)}};let o=()=>{let x=S=>(...T)=>{let D=nr;return T=S(...T),nr!=D?new Promise((R,V)=>{_p={resolve:R,reject:V}}):T};(()=>{for(let S of["_OrtAppendExecutionProvider","_OrtCreateSession","_OrtRun","_OrtRunWithBinding","_OrtBindInput"])e[S]=x(e[S])})(),i!==void 0&&(e._OrtRun=i(e._OrtRun),e._OrtRunWithBinding=i(e._OrtRunWithBinding)),o=void 0};e.asyncInit=()=>{o==null||o()};var u,l,c=(x,S)=>{throw S},d=import.meta.url,h="";if(n||s){try{h=new URL(".",d).href}catch{}s&&(l=x=>{var S=new XMLHttpRequest;return S.open("GET",x,!1),S.responseType="arraybuffer",S.send(null),new Uint8Array(S.response)}),u=async x=>{if(A(x))return new Promise((T,D)=>{var R=new XMLHttpRequest;R.open("GET",x,!0),R.responseType="arraybuffer",R.onload=()=>{R.status==200||R.status==0&&R.response?T(R.response):D(R.status)},R.onerror=D,R.send(null)});var S=await fetch(x,{credentials:"same-origin"});if(S.ok)return S.arrayBuffer();throw Error(S.status+" : "+S.url)}}var p,f,m,g,y,b,$,w=console.log.bind(console),v=console.error.bind(console),k=w,C=v,N=!1,A=x=>x.startsWith("file://");function I(){z.buffer!=P.buffer&&oe()}if(r){let x=function(S){try{var T=S.data,D=T.Vc;if(D==="load"){let R=[];self.onmessage=V=>R.push(V),$=()=>{postMessage({Vc:"loaded"});for(let V of R)x(V);self.onmessage=x};for(let V of T.Ad)e[V]&&!e[V].proxy||(e[V]=(...Q)=>{postMessage({Vc:"callHandler",zd:V,args:Q})},V=="print"&&(k=e[V]),V=="printErr"&&(C=e[V]));z=T.Wd,oe(),b(T.Xd)}else if(D==="run"){(function(R){var V=(I(),B)[R+52>>>2>>>0];R=(I(),B)[R+56>>>2>>>0],Xx(V,V-R),Ge(V)})(T.Tc),Rp(T.Tc,0,0,1,0,0),Ns(),Sp(T.Tc),E||(Ux(),E=!0);try{Ca(T.Pd,T.dd)}catch(R){if(R!="unwind")throw R}}else T.target!=="setimmediate"&&(D==="checkMailbox"?E&&Ul():D&&(C(`worker: received unknown command ${D}`),C(T)))}catch(R){throw Gx(),R}};var E=!1;self.onunhandledrejection=S=>{throw S.reason||S},self.onmessage=x}var z,P,H,G,W,L,B,Y,ne,M,Z,J=!1;function oe(){var x=z.buffer;e.HEAP8=P=new Int8Array(x),G=new Int16Array(x),e.HEAPU8=H=new Uint8Array(x),W=new Uint16Array(x),e.HEAP32=L=new Int32Array(x),e.HEAPU32=B=new Uint32Array(x),Y=new Float32Array(x),ne=new Float64Array(x),M=new BigInt64Array(x),Z=new BigUint64Array(x)}function de(){J=!0,r?$():Gr.tb()}var fe,xe=0,Ne=null;function $e(){if(--xe==0&&Ne){var x=Ne;Ne=null,x()}}function Ee(x){throw C(x="Aborted("+x+")"),N=!0,x=new WebAssembly.RuntimeError(x+". Build with -sASSERTIONS for more info."),y==null||y(x),x}function ze(){return{a:{ma:wF,ib:xF,g:fp,J:mp,f:n3,m:s3,h:r3,ha:a3,b:i3,T:o3,Ja:nx,n:u3,_:ix,Za:ox,Fa:ux,Ha:lx,_a:cx,Xa:dx,Qa:hx,Wa:px,ka:fx,Ga:mx,Da:gx,Ya:yx,Ea:bx,db:l3,ea:c3,ya:d3,wa:p3,da:m3,O:g3,I:y3,xa:b3,Z:_3,za:k3,Ta:C3,Ba:T3,Ka:N3,ua:E3,fa:A3,Sa:Sp,ab:R3,S:z3,p:V3,c:wp,jb:W3,y:U3,N:G3,C:H3,s:q3,r:kx,kb:kx,K:j3,R:K3,j:X3,v:Y3,q:Z3,l:Q3,Na:J3,Oa:eF,Pa:tF,La:Ex,Ma:Ax,va:Rx,fb:sF,cb:aF,u:iF,aa:oF,ga:uF,bb:rF,V:lF,$a:cF,Ca:dF,F:nF,U:hF,la:Kl,Aa:pF,hb:fF,gb:mF,Ua:zx,Va:Lx,Ia:Ft,$:Px,ja:Bx,Ra:Mx,ia:Vx,mb:sz,oa:XF,nb:nz,pa:KF,G:VF,d:IF,o:vF,w:$F,B:FF,rb:GF,L:PF,x:CF,qa:qF,X:YF,ba:UF,ob:ez,pb:JF,qb:HF,ra:WF,P:BF,na:tz,Y:jF,e:kF,z:_F,k:SF,lb:rz,t:TF,A:NF,D:EF,E:OF,M:zF,sb:MF,Q:ZF,ca:LF,W:QF,sa:RF,ta:AF,H:DF,i:yF,a:z,eb:ft}}}class Oe{constructor(S){Ln(this,"name","ExitStatus");this.message=`Program terminated with exit(${S})`,this.status=S}}var Fe=x=>{x.terminate(),x.onmessage=()=>{}},Je=[],ct=x=>{yn.length==0&&(As(),Es(yn[0]));var S=yn.pop();if(!S)return 6;Qt.push(S),Jt[x.Tc]=S,S.Tc=x.Tc;var T={Vc:"run",Pd:x.Od,dd:x.dd,Tc:x.Tc};return S.postMessage(T,x.vd),0},Ke=0,Le=(x,S,...T)=>{for(var D=2*T.length,R=je(),V=Op(8*D),Q=V>>>3,ie=0;ie<T.length;ie++){var pe=T[ie];typeof pe=="bigint"?((I(),M)[Q+2*ie>>>0]=1n,(I(),M)[Q+2*ie+1>>>0]=pe):((I(),M)[Q+2*ie>>>0]=0n,(I(),ne)[Q+2*ie+1>>>0]=pe)}return x=Hx(x,0,D,V,S),Ge(R),x};function ft(x){if(r)return Le(0,1,x);if(m=x,!(0<Ke)){for(var S of Qt)Fe(S);for(S of yn)Fe(S);yn=[],Qt=[],Jt={},N=!0}c(0,new Oe(x))}function us(x){if(r)return Le(1,0,x);Ft(x)}var Ft=x=>{if(m=x,r)throw us(x),"unwind";ft(x)},yn=[],Qt=[],er=[],Jt={},ls=x=>{var S=x.Tc;delete Jt[S],yn.push(x),Qt.splice(Qt.indexOf(x),1),x.Tc=0,qx(S)};function Ns(){er.forEach(x=>x())}var Es=x=>new Promise(S=>{x.onmessage=R=>{var V=(R=R.data).Vc;if(R.ad&&R.ad!=Ap()){var Q=Jt[R.ad];Q?Q.postMessage(R,R.vd):C(`Internal error! Worker sent a message "${V}" to target pthread ${R.ad}, but that thread no longer exists!`)}else V==="checkMailbox"?Ul():V==="spawnThread"?ct(R):V==="cleanupThread"?ls(Jt[R.Qd]):V==="loaded"?(x.loaded=!0,S(x)):R.target==="setimmediate"?x.postMessage(R):V==="callHandler"?e[R.zd](...R.args):V&&C(`worker sent an unknown command ${V}`)},x.onerror=R=>{throw C(`worker sent an error! ${R.filename}:${R.lineno}: ${R.message}`),R};var T,D=[];for(T of[])e.propertyIsEnumerable(T)&&D.push(T);x.postMessage({Vc:"load",Ad:D,Wd:z,Xd:f})});function As(){var x=new Worker((()=>{let S=URL;return import.meta.url>"file:"&&import.meta.url<"file;"?new S("ort.bundle.min.mjs",import.meta.url):new URL(import.meta.url)})(),{type:"module",workerData:"em-pthread",name:"em-pthread"});yn.push(x)}var Ca=(x,S)=>{Ke=0,x=Fp(x,S),0<Ke?m=x:Dp(x)},Mr=[],Vr=0;function fp(x){var S=new gp(x>>>=0);return(I(),P)[S.Uc+12>>>0]==0&&(Vl(S,!0),Vr--),ex(S,!1),Mr.push(S),Zx(x),Jx(x)}var Rs=0,mp=()=>{Xe(0,0);var x=Mr.pop();Yx(x.ed),Rs=0};function Vl(x,S){S=S?1:0,(I(),P)[x.Uc+12>>>0]=S}function ex(x,S){S=S?1:0,(I(),P)[x.Uc+13>>>0]=S}class gp{constructor(S){this.ed=S,this.Uc=S-24}}var yp=x=>{var S=Rs;if(!S)return To(0),0;var T=new gp(S);(I(),B)[T.Uc+16>>>2>>>0]=S;var D=(I(),B)[T.Uc+4>>>2>>>0];if(!D)return To(0),S;for(var R of x){if(R===0||R===D)break;if(Qx(R,D,T.Uc+16))return To(R),S}return To(D),S};function n3(){return yp([])}function s3(x){return yp([x>>>0])}function r3(x,S,T,D){return yp([x>>>0,S>>>0,T>>>0,D>>>0])}var a3=()=>{var x=Mr.pop();x||Ee("no exception to throw");var S=x.ed;throw(I(),P)[x.Uc+13>>>0]==0&&(Mr.push(x),ex(x,!0),Vl(x,!1),Vr++),Rs=S};function i3(x,S,T){var D=new gp(x>>>=0);throw S>>>=0,T>>>=0,(I(),B)[D.Uc+16>>>2>>>0]=0,(I(),B)[D.Uc+4>>>2>>>0]=S,(I(),B)[D.Uc+8>>>2>>>0]=T,Vr++,Rs=x}var o3=()=>Vr;function tx(x,S,T,D){return r?Le(2,1,x,S,T,D):nx(x,S,T,D)}function nx(x,S,T,D){if(x>>>=0,T>>>=0,D>>>=0,a===void 0)return 6;var R=[];return r&&R.length===0?tx(x,S>>>=0,T,D):(x={Od:T,Tc:x,dd:D,vd:R},r?(x.Vc="spawnThread",postMessage(x,R),0):ct(x))}function u3(x){throw Rs||(Rs=x>>>0),Rs}var sx=typeof TextDecoder<"u"?new TextDecoder:void 0,rx=(x,S,T,D)=>{if(T=S+T,D)return T;for(;x[S]&&!(S>=T);)++S;return S},ax=(x,S=0,T,D)=>{if(16<(T=rx(x,S>>>=0,T,D))-S&&x.buffer&&sx)return sx.decode(x.buffer instanceof ArrayBuffer?x.subarray(S,T):x.slice(S,T));for(D="";S<T;){var R=x[S++];if(128&R){var V=63&x[S++];if((224&R)==192)D+=String.fromCharCode((31&R)<<6|V);else{var Q=63&x[S++];65536>(R=(240&R)==224?(15&R)<<12|V<<6|Q:(7&R)<<18|V<<12|Q<<6|63&x[S++])?D+=String.fromCharCode(R):(R-=65536,D+=String.fromCharCode(55296|R>>10,56320|1023&R))}}else D+=String.fromCharCode(R)}return D},Vt=(x,S,T)=>(x>>>=0)?ax((I(),H),x,S,T):"";function ix(x,S,T){return r?Le(3,1,x,S,T):0}function ox(x,S){if(r)return Le(4,1,x,S)}function ux(x,S){if(r)return Le(5,1,x,S)}function lx(x,S,T){if(r)return Le(6,1,x,S,T)}function cx(x,S,T){return r?Le(7,1,x,S,T):0}function dx(x,S){if(r)return Le(8,1,x,S)}function hx(x,S,T){if(r)return Le(9,1,x,S,T)}function px(x,S,T,D){if(r)return Le(10,1,x,S,T,D)}function fx(x,S,T,D){if(r)return Le(11,1,x,S,T,D)}function mx(x,S,T,D){if(r)return Le(12,1,x,S,T,D)}function gx(x){if(r)return Le(13,1,x)}function yx(x,S){if(r)return Le(14,1,x,S)}function bx(x,S,T){if(r)return Le(15,1,x,S,T)}var l3=()=>Ee(""),tr=x=>{x>>>=0;for(var S="";;){var T=(I(),H)[x++>>>0];if(!T)return S;S+=String.fromCharCode(T)}},bp={},xp={},Ti=class extends Error{constructor(x){super(x),this.name="BindingError"}};function $r(x,S,T={}){return function(D,R,V={}){var Q=R.name;if(!D)throw new Ti(`type "${Q}" must have a positive integer typeid pointer`);if(xp.hasOwnProperty(D)){if(V.Bd)return;throw new Ti(`Cannot register type '${Q}' twice`)}xp[D]=R,bp.hasOwnProperty(D)&&(R=bp[D],delete bp[D],R.forEach(ie=>ie()))}(x,S,T)}var xx=(x,S,T)=>{switch(S){case 1:return T?D=>(I(),P)[D>>>0]:D=>(I(),H)[D>>>0];case 2:return T?D=>(I(),G)[D>>>1>>>0]:D=>(I(),W)[D>>>1>>>0];case 4:return T?D=>(I(),L)[D>>>2>>>0]:D=>(I(),B)[D>>>2>>>0];case 8:return T?D=>(I(),M)[D>>>3>>>0]:D=>(I(),Z)[D>>>3>>>0];default:throw new TypeError(`invalid integer width (${S}): ${x}`)}};function c3(x,S,T,D,R){x>>>=0,T>>>=0,S=tr(S>>>0);let V=Q=>Q;if(D=D===0n){let Q=8*T;V=ie=>BigInt.asUintN(Q,ie),R=V(R)}$r(x,{name:S,Pc:V,Xc:(Q,ie)=>(typeof ie=="number"&&(ie=BigInt(ie)),ie),Wc:xx(S,T,!D),Yc:null})}function d3(x,S,T,D){$r(x>>>=0,{name:S=tr(S>>>0),Pc:function(R){return!!R},Xc:function(R,V){return V?T:D},Wc:function(R){return this.Pc((I(),H)[R>>>0])},Yc:null})}var wx=[],Ta=[0,1,,1,null,1,!0,1,!1,1];function wp(x){9<(x>>>=0)&&--Ta[x+1]==0&&(Ta[x]=void 0,wx.push(x))}var cs=x=>{if(!x)throw new Ti(`Cannot use deleted val. handle = ${x}`);return Ta[x]},Ds=x=>{switch(x){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let S=wx.pop()||Ta.length;return Ta[S]=x,Ta[S+1]=1,S}};function $p(x){return this.Pc((I(),B)[x>>>2>>>0])}var h3={name:"emscripten::val",Pc:x=>{var S=cs(x);return wp(x),S},Xc:(x,S)=>Ds(S),Wc:$p,Yc:null};function p3(x){return $r(x>>>0,h3)}var f3=(x,S)=>{switch(S){case 4:return function(T){return this.Pc((I(),Y)[T>>>2>>>0])};case 8:return function(T){return this.Pc((I(),ne)[T>>>3>>>0])};default:throw new TypeError(`invalid float width (${S}): ${x}`)}};function m3(x,S,T){T>>>=0,$r(x>>>=0,{name:S=tr(S>>>0),Pc:D=>D,Xc:(D,R)=>R,Wc:f3(S,T),Yc:null})}function g3(x,S,T,D,R){x>>>=0,T>>>=0,S=tr(S>>>0);let V=ie=>ie;if(D===0){var Q=32-8*T;V=ie=>ie<<Q>>>Q,R=V(R)}$r(x,{name:S,Pc:V,Xc:(ie,pe)=>pe,Wc:xx(S,T,D!==0),Yc:null})}function y3(x,S,T){function D(V){var Q=(I(),B)[V>>>2>>>0];return V=(I(),B)[V+4>>>2>>>0],new R((I(),P).buffer,V,Q)}var R=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][S];$r(x>>>=0,{name:T=tr(T>>>0),Pc:D,Wc:D},{Bd:!0})}var Wr=(x,S,T)=>{var D=(I(),H);if(S>>>=0,0<T){var R=S;T=S+T-1;for(var V=0;V<x.length;++V){var Q=x.codePointAt(V);if(127>=Q){if(S>=T)break;D[S++>>>0]=Q}else if(2047>=Q){if(S+1>=T)break;D[S++>>>0]=192|Q>>6,D[S++>>>0]=128|63&Q}else if(65535>=Q){if(S+2>=T)break;D[S++>>>0]=224|Q>>12,D[S++>>>0]=128|Q>>6&63,D[S++>>>0]=128|63&Q}else{if(S+3>=T)break;D[S++>>>0]=240|Q>>18,D[S++>>>0]=128|Q>>12&63,D[S++>>>0]=128|Q>>6&63,D[S++>>>0]=128|63&Q,V++}}D[S>>>0]=0,x=S-R}else x=0;return x},Wl=x=>{for(var S=0,T=0;T<x.length;++T){var D=x.charCodeAt(T);127>=D?S++:2047>=D?S+=2:55296<=D&&57343>=D?(S+=4,++T):S+=3}return S};function b3(x,S){$r(x>>>=0,{name:S=tr(S>>>0),Pc(T){var D=(I(),B)[T>>>2>>>0];return D=Vt(T+4,D,!0),sr(T),D},Xc(T,D){D instanceof ArrayBuffer&&(D=new Uint8Array(D));var R=typeof D=="string";if(!(R||ArrayBuffer.isView(D)&&D.BYTES_PER_ELEMENT==1))throw new Ti("Cannot pass non-string to std::string");var V=R?Wl(D):D.length,Q=Co(4+V+1),ie=Q+4;return(I(),B)[Q>>>2>>>0]=V,R?Wr(D,ie,V+1):(I(),H).set(D,ie>>>0),T!==null&&T.push(sr,Q),Q},Wc:$p,Yc(T){sr(T)}})}var $x=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,x3=(x,S,T)=>{if(x>>>=1,16<(S=rx((I(),W),x,S/2,T))-x&&$x)return $x.decode((I(),W).buffer instanceof ArrayBuffer?(I(),W).subarray(x>>>0,S>>>0):(I(),W).slice(x,S));for(T="";x<S;++x){var D=(I(),W)[x>>>0];T+=String.fromCharCode(D)}return T},w3=(x,S,T)=>{if(T??(T=2147483647),2>T)return 0;var D=S;T=(T-=2)<2*x.length?T/2:x.length;for(var R=0;R<T;++R){var V=x.charCodeAt(R);(I(),G)[S>>>1>>>0]=V,S+=2}return(I(),G)[S>>>1>>>0]=0,S-D},$3=x=>2*x.length,v3=(x,S,T)=>{var D="";x>>>=2;for(var R=0;!(R>=S/4);R++){var V=(I(),B)[x+R>>>0];if(!V&&!T)break;D+=String.fromCodePoint(V)}return D},S3=(x,S,T)=>{if(S>>>=0,T??(T=2147483647),4>T)return 0;var D=S;T=D+T-4;for(var R=0;R<x.length;++R){var V=x.codePointAt(R);if(65535<V&&R++,(I(),L)[S>>>2>>>0]=V,(S+=4)+4>T)break}return(I(),L)[S>>>2>>>0]=0,S-D},I3=x=>{for(var S=0,T=0;T<x.length;++T)65535<x.codePointAt(T)&&T++,S+=4;return S};function _3(x,S,T){if(x>>>=0,S>>>=0,T=tr(T>>>=0),S===2)var D=x3,R=w3,V=$3;else D=v3,R=S3,V=I3;$r(x,{name:T,Pc:Q=>{var ie=(I(),B)[Q>>>2>>>0];return ie=D(Q+4,ie*S,!0),sr(Q),ie},Xc:(Q,ie)=>{if(typeof ie!="string")throw new Ti(`Cannot pass non-string to C++ string type ${T}`);var pe=V(ie),ye=Co(4+pe+S);return(I(),B)[ye>>>2>>>0]=pe/S,R(ie,ye+4,pe+S),Q!==null&&Q.push(sr,ye),ye},Wc:$p,Yc(Q){sr(Q)}})}function k3(x,S){$r(x>>>=0,{Cd:!0,name:S=tr(S>>>0),Pc:()=>{},Xc:()=>{}})}function C3(x){Rp(x>>>0,!s,1,!n,131072,!1),Ns()}var vp=x=>{if(!N)try{if(x(),!(0<Ke))try{r?Dp(m):Ft(m)}catch(S){S instanceof Oe||S=="unwind"||c(0,S)}}catch(S){S instanceof Oe||S=="unwind"||c(0,S)}};function Sp(x){x>>>=0,typeof Atomics.Vd=="function"&&(Atomics.Vd((I(),L),x>>>2,x).value.then(Ul),x+=128,Atomics.store((I(),L),x>>>2,1))}var Ul=()=>{var x=Ap();x&&(Sp(x),vp(Kx))};function T3(x,S){(x>>>=0)==S>>>0?setTimeout(Ul):r?postMessage({ad:x,Vc:"checkMailbox"}):(x=Jt[x])&&x.postMessage({Vc:"checkMailbox"})}var Gl=[];function N3(x,S,T,D,R){for(S>>>=0,D/=2,Gl.length=D,T=R>>>0>>>3,R=0;R<D;R++)(I(),M)[T+2*R>>>0]?Gl[R]=(I(),M)[T+2*R+1>>>0]:Gl[R]=(I(),ne)[T+2*R+1>>>0];return(S?Ep[S]:bF[x])(...Gl)}var E3=()=>{Ke=0};function A3(x){x>>>=0,r?postMessage({Vc:"cleanupThread",Qd:x}):ls(Jt[x])}function R3(x){}var Hl=x=>{try{x()}catch(S){Ee(S)}};function D3(x){var S=(...T)=>{ql.push(x);try{return x(...T)}finally{N||(ql.pop(),nr&&Ur===1&&ql.length===0&&(Ur=0,Ke+=1,Hl(Pw),typeof Fibers<"u"&&Fibers.de()))}};return Ix.set(x,S),S}var Ur=0,nr=null,vx=0,ql=[],Ip=new Map,Sx=new Map,Ix=new Map,O3=0,_p=null,F3=[],_x=x=>function(S){if(!N){if(Ur===0){var T=!1,D=!1;S((R=0)=>{if(!N&&(vx=R,T=!0,D)){Ur=2,Hl(()=>Bw(nr)),typeof MainLoop<"u"&&MainLoop.yd&&MainLoop.resume(),R=!1;try{var V=function(){var pe=(I(),L)[nr+8>>>2>>>0];return pe=Sx.get(pe),pe=Ix.get(pe),--Ke,pe()}()}catch(pe){V=pe,R=!0}var Q=!1;if(!nr){var ie=_p;ie&&(_p=null,(R?ie.reject:ie.resolve)(V),Q=!0)}if(R&&!Q)throw V}}),D=!0,T||(Ur=1,nr=function(){var R=Co(65548),V=R+12;if((I(),B)[R>>>2>>>0]=V,(I(),B)[R+4>>>2>>>0]=V+65536,V=ql[0],!Ip.has(V)){var Q=O3++;Ip.set(V,Q),Sx.set(Q,V)}return V=Ip.get(V),(I(),L)[R+8>>>2>>>0]=V,R}(),typeof MainLoop<"u"&&MainLoop.yd&&MainLoop.pause(),Hl(()=>Lw(nr)))}else Ur===2?(Ur=0,Hl(Mw),sr(nr),nr=null,F3.forEach(vp)):Ee(`invalid state: ${Ur}`);return vx}}(S=>{x().then(S)});function z3(x){return x>>>=0,_x(async()=>{var S=await cs(x);return Ds(S)})}var kp=[],L3=x=>{var S=kp.length;return kp.push(x),S},P3=(x,S)=>{for(var T=Array(x),D=0;D<x;++D){var R=D,V=(I(),B)[S+4*D>>>2>>>0],Q=xp[V];if(Q===void 0)throw x=`parameter ${D}`,V=Wx(V),S=tr(V),sr(V),new Ti(`${x} has unknown type ${S}`);T[R]=Q}return T},B3=(x,S,T)=>{var D=[];return x=x(D,T),D.length&&((I(),B)[S>>>2>>>0]=Ds(D)),x},M3={},jl=x=>{var S=M3[x];return S===void 0?tr(x):S};function V3(x,S,T){var[D,...R]=P3(x,S>>>0);S=D.Xc.bind(D);var V=R.map(pe=>pe.Wc.bind(pe));x--;var Q={toValue:cs};switch(x=V.map((pe,ye)=>{var Ue=`argFromPtr${ye}`;return Q[Ue]=pe,`${Ue}(args${ye?"+"+8*ye:""})`}),T){case 0:var ie="toValue(handle)";break;case 2:ie="new (toValue(handle))";break;case 3:ie="";break;case 1:Q.getStringOrSymbol=jl,ie="toValue(handle)[getStringOrSymbol(methodName)]"}return ie+=`(${x})`,D.Cd||(Q.toReturnWire=S,Q.emval_returnValue=B3,ie=`return emval_returnValue(toReturnWire, destructorsRef, ${ie})`),ie=`return function (handle, methodName, destructorsRef, args) {
  ${ie}
  }`,T=new Function(Object.keys(Q),ie)(...Object.values(Q)),ie=`methodCaller<(${R.map(pe=>pe.name)}) => ${D.name}>`,L3(Object.defineProperty(T,"name",{value:ie}))}function W3(x,S){return S>>>=0,(x=cs(x>>>0))==cs(S)}function U3(x){return(x>>>=0)==0?Ds(globalThis):(x=jl(x),Ds(globalThis[x]))}function G3(x){return x=jl(x>>>0),Ds(e[x])}function H3(x,S){return S>>>=0,x=cs(x>>>0),S=cs(S),Ds(x[S])}function q3(x){9<(x>>>=0)&&(Ta[x+1]+=1)}function kx(x,S,T,D,R){return kp[x>>>0](S>>>0,T>>>0,D>>>0,R>>>0)}function j3(){return Ds([])}function K3(x){x=cs(x>>>0);for(var S=Array(x.length),T=0;T<x.length;T++)S[T]=x[T];return Ds(S)}function X3(x){return Ds(jl(x>>>0))}function Y3(){return Ds({})}function Z3(x){for(var S=cs(x>>>=0);S.length;){var T=S.pop();S.pop()(T)}wp(x)}function Q3(x,S,T){S>>>=0,T>>>=0,x=cs(x>>>0),S=cs(S),T=cs(T),x[S]=T}function J3(x,S){x=-9007199254740992>x||9007199254740992<x?NaN:Number(x),S>>>=0,x=new Date(1e3*x),(I(),L)[S>>>2>>>0]=x.getUTCSeconds(),(I(),L)[S+4>>>2>>>0]=x.getUTCMinutes(),(I(),L)[S+8>>>2>>>0]=x.getUTCHours(),(I(),L)[S+12>>>2>>>0]=x.getUTCDate(),(I(),L)[S+16>>>2>>>0]=x.getUTCMonth(),(I(),L)[S+20>>>2>>>0]=x.getUTCFullYear()-1900,(I(),L)[S+24>>>2>>>0]=x.getUTCDay(),x=(x.getTime()-Date.UTC(x.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,(I(),L)[S+28>>>2>>>0]=x}var Cx=x=>x%4==0&&(x%100!=0||x%400==0),Tx=[0,31,60,91,121,152,182,213,244,274,305,335],Nx=[0,31,59,90,120,151,181,212,243,273,304,334];function eF(x,S){x=-9007199254740992>x||9007199254740992<x?NaN:Number(x),S>>>=0,x=new Date(1e3*x),(I(),L)[S>>>2>>>0]=x.getSeconds(),(I(),L)[S+4>>>2>>>0]=x.getMinutes(),(I(),L)[S+8>>>2>>>0]=x.getHours(),(I(),L)[S+12>>>2>>>0]=x.getDate(),(I(),L)[S+16>>>2>>>0]=x.getMonth(),(I(),L)[S+20>>>2>>>0]=x.getFullYear()-1900,(I(),L)[S+24>>>2>>>0]=x.getDay();var T=(Cx(x.getFullYear())?Tx:Nx)[x.getMonth()]+x.getDate()-1|0;(I(),L)[S+28>>>2>>>0]=T,(I(),L)[S+36>>>2>>>0]=-60*x.getTimezoneOffset(),T=new Date(x.getFullYear(),6,1).getTimezoneOffset();var D=new Date(x.getFullYear(),0,1).getTimezoneOffset();x=0|(T!=D&&x.getTimezoneOffset()==Math.min(D,T)),(I(),L)[S+32>>>2>>>0]=x}function tF(x){x>>>=0;var S=new Date((I(),L)[x+20>>>2>>>0]+1900,(I(),L)[x+16>>>2>>>0],(I(),L)[x+12>>>2>>>0],(I(),L)[x+8>>>2>>>0],(I(),L)[x+4>>>2>>>0],(I(),L)[x>>>2>>>0],0),T=(I(),L)[x+32>>>2>>>0],D=S.getTimezoneOffset(),R=new Date(S.getFullYear(),6,1).getTimezoneOffset(),V=new Date(S.getFullYear(),0,1).getTimezoneOffset(),Q=Math.min(V,R);return 0>T?(I(),L)[x+32>>>2>>>0]=+(R!=V&&Q==D):0<T!=(Q==D)&&(R=Math.max(V,R),S.setTime(S.getTime()+6e4*((0<T?Q:R)-D))),(I(),L)[x+24>>>2>>>0]=S.getDay(),T=(Cx(S.getFullYear())?Tx:Nx)[S.getMonth()]+S.getDate()-1|0,(I(),L)[x+28>>>2>>>0]=T,(I(),L)[x>>>2>>>0]=S.getSeconds(),(I(),L)[x+4>>>2>>>0]=S.getMinutes(),(I(),L)[x+8>>>2>>>0]=S.getHours(),(I(),L)[x+12>>>2>>>0]=S.getDate(),(I(),L)[x+16>>>2>>>0]=S.getMonth(),(I(),L)[x+20>>>2>>>0]=S.getYear(),x=S.getTime(),BigInt(isNaN(x)?-1:x/1e3)}function Ex(x,S,T,D,R,V,Q){return r?Le(16,1,x,S,T,D,R,V,Q):-52}function Ax(x,S,T,D,R,V){if(r)return Le(17,1,x,S,T,D,R,V)}var ko={},nF=()=>performance.timeOrigin+performance.now();function Rx(x,S){if(r)return Le(18,1,x,S);if(ko[x]&&(clearTimeout(ko[x].id),delete ko[x]),!S)return 0;var T=setTimeout(()=>{delete ko[x],vp(()=>jx(x,performance.timeOrigin+performance.now()))},S);return ko[x]={id:T,ce:S},0}function sF(x,S,T,D){x>>>=0,S>>>=0,T>>>=0,D>>>=0;var R=new Date().getFullYear(),V=new Date(R,0,1).getTimezoneOffset();R=new Date(R,6,1).getTimezoneOffset();var Q=Math.max(V,R);(I(),B)[x>>>2>>>0]=60*Q,(I(),L)[S>>>2>>>0]=+(V!=R),x=(S=ie=>{var pe=Math.abs(ie);return`UTC${0<=ie?"-":"+"}${String(Math.floor(pe/60)).padStart(2,"0")}${String(pe%60).padStart(2,"0")}`})(V),S=S(R),R<V?(Wr(x,T,17),Wr(S,D,17)):(Wr(x,D,17),Wr(S,T,17))}var rF=()=>Date.now();function aF(x,S,T){return T>>>=0,0<=x&&3>=x?(x===0?x=Date.now():x=performance.timeOrigin+performance.now(),x=Math.round(1e6*x),(I(),M)[T>>>3>>>0]=BigInt(x),0):28}var Cp=[],Dx=(x,S)=>{Cp.length=0;for(var T;T=(I(),H)[x++>>>0];){var D=T!=105;S+=(D&=T!=112)&&S%8?4:0,Cp.push(T==112?(I(),B)[S>>>2>>>0]:T==106?(I(),M)[S>>>3>>>0]:T==105?(I(),L)[S>>>2>>>0]:(I(),ne)[S>>>3>>>0]),S+=D?8:4}return Cp};function iF(x,S,T){return x>>>=0,S=Dx(S>>>0,T>>>0),Ep[x](...S)}function oF(x,S,T){return x>>>=0,S=Dx(S>>>0,T>>>0),Ep[x](...S)}var uF=()=>{};function lF(x,S){return C(Vt(x>>>0,S>>>0))}var cF=()=>{throw Ke+=1,"unwind"};function dF(){return 4294901760}var hF=()=>navigator.hardwareConcurrency,Na={};function Kl(x){if(!(2147483648&(x>>>=0)))return Ee("Cannot use emscripten_pc_get_function on native functions without -sUSE_OFFSET_CONVERTER"),0;if(!(x=Na[x]))return 0;var S;if(S=/^\s+at (.*) \(.*\)$/.exec(x))x=S[1];else{if(!(S=/^(.+?)@/.exec(x)))return 0;x=S[1]}sr(Kl.ud??0),S=Wl(x)+1;var T=Co(S);return T&&Wr(x,T,S),Kl.ud=T,Kl.ud}function pF(x){x>>>=0;var S=(I(),H).length;if(x<=S||4294901760<x)return!1;for(var T=1;4>=T;T*=2){var D=S*(1+.2/T);D=Math.min(D,x+100663296);e:{D=(Math.min(4294901760,65536*Math.ceil(Math.max(x,D)/65536))-z.buffer.byteLength+65535)/65536|0;try{z.grow(D),oe();var R=1;break e}catch{}R=void 0}if(R)return!0}return!1}var Xl=x=>{var S;if(S=/\bwasm-function\[\d+\]:(0x[0-9a-f]+)/.exec(x))return+S[1];if(/\bwasm-function\[(\d+)\]:(\d+)/.exec(x))Ee("Legacy backtrace format detected but -sUSE_OFFSET_CONVERTER not present.");else if(S=/:(\d+):\d+(?:\)|$)/.exec(x))return 2147483648|+S[1];return 0},Ox=x=>{x.forEach(S=>{var T=Xl(S);T&&(Na[T]=S)})};function fF(){var x=Error().stack.toString().split(`
`);return x[0]=="Error"&&x.shift(),Ox(x),Na.td=Xl(x[3]),Na.Md=x,Na.td}function mF(x,S,T){if(x>>>=0,S>>>=0,Na.td==x)var D=Na.Md;else(D=Error().stack.toString().split(`
`))[0]=="Error"&&D.shift(),Ox(D);for(var R=3;D[R]&&Xl(D[R])!=x;)++R;for(x=0;x<T&&D[x+R];++x)(I(),L)[S+4*x>>>2>>>0]=Xl(D[x+R]);return x}var Tp,Np={},Fx=()=>{if(!Tp){var x,S={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.language||"C").replace("-","_")+".UTF-8",_:"./this.program"};for(x in Np)Np[x]===void 0?delete S[x]:S[x]=Np[x];var T=[];for(x in S)T.push(`${x}=${S[x]}`);Tp=T}return Tp};function zx(x,S){if(r)return Le(19,1,x,S);x>>>=0,S>>>=0;var T,D=0,R=0;for(T of Fx()){var V=S+D;(I(),B)[x+R>>>2>>>0]=V,D+=Wr(T,V,1/0)+1,R+=4}return 0}function Lx(x,S){if(r)return Le(20,1,x,S);x>>>=0,S>>>=0;var T=Fx();for(var D of((I(),B)[x>>>2>>>0]=T.length,x=0,T))x+=Wl(D)+1;return(I(),B)[S>>>2>>>0]=x,0}function Px(x){return r?Le(21,1,x):52}function Bx(x,S,T,D){return r?Le(22,1,x,S,T,D):52}function Mx(x,S,T,D){return r?Le(23,1,x,S,T,D):70}var gF=[null,[],[]];function Vx(x,S,T,D){if(r)return Le(24,1,x,S,T,D);S>>>=0,T>>>=0,D>>>=0;for(var R=0,V=0;V<T;V++){var Q=(I(),B)[S>>>2>>>0],ie=(I(),B)[S+4>>>2>>>0];S+=8;for(var pe=0;pe<ie;pe++){var ye=x,Ue=(I(),H)[Q+pe>>>0],at=gF[ye];Ue===0||Ue===10?((ye===1?k:C)(ax(at)),at.length=0):at.push(Ue)}R+=ie}return(I(),B)[D>>>2>>>0]=R,0}function yF(x){return x>>>0}r||function(){for(var x=e.numThreads-1;x--;)As();Je.push(()=>{xe++,function(S){r?S():Promise.all(yn.map(Es)).then(S)}(()=>$e())})}(),r||(z=new WebAssembly.Memory({initial:256,maximum:65536,shared:!0}),oe()),e.wasmBinary&&(p=e.wasmBinary),e.stackSave=()=>je(),e.stackRestore=x=>Ge(x),e.stackAlloc=x=>Op(x),e.setValue=function(x,S,T="i8"){switch(T.endsWith("*")&&(T="*"),T){case"i1":case"i8":(I(),P)[x>>>0]=S;break;case"i16":(I(),G)[x>>>1>>>0]=S;break;case"i32":(I(),L)[x>>>2>>>0]=S;break;case"i64":(I(),M)[x>>>3>>>0]=BigInt(S);break;case"float":(I(),Y)[x>>>2>>>0]=S;break;case"double":(I(),ne)[x>>>3>>>0]=S;break;case"*":(I(),B)[x>>>2>>>0]=S;break;default:Ee(`invalid type for setValue: ${T}`)}},e.getValue=function(x,S="i8"){switch(S.endsWith("*")&&(S="*"),S){case"i1":case"i8":return(I(),P)[x>>>0];case"i16":return(I(),G)[x>>>1>>>0];case"i32":return(I(),L)[x>>>2>>>0];case"i64":return(I(),M)[x>>>3>>>0];case"float":return(I(),Y)[x>>>2>>>0];case"double":return(I(),ne)[x>>>3>>>0];case"*":return(I(),B)[x>>>2>>>0];default:Ee(`invalid type for getValue: ${S}`)}},e.UTF8ToString=Vt,e.stringToUTF8=Wr,e.lengthBytesUTF8=Wl;var bF=[ft,us,tx,ix,ox,ux,lx,cx,dx,hx,px,fx,mx,gx,yx,bx,Ex,Ax,Rx,zx,Lx,Px,Bx,Mx,Vx],Ep={891356:(x,S,T,D,R)=>{if(e===void 0||!e.Zc)return 1;if((x=Vt(Number(x>>>0))).startsWith("./")&&(x=x.substring(2)),!(x=e.Zc.get(x)))return 2;if(S=Number(S>>>0),T=Number(T>>>0),D=Number(D>>>0),S+T>x.byteLength)return 3;try{let V=x.subarray(S,S+T);switch(R){case 0:(I(),H).set(V,D>>>0);break;case 1:e.Yd?e.Yd(D,V):e.Ld(D,V);break;default:return 4}return 0}catch{return 4}},892180:(x,S,T)=>{e.xd(x,(I(),H).subarray(S>>>0,S+T>>>0))},892244:()=>e.$d(),892286:x=>{e.wd(x)},892323:()=>{e.Ed()},892354:()=>{e.Fd()},892383:()=>{e.Jd()},892408:x=>e.Dd(x),892441:x=>e.Hd(x),892473:(x,S,T)=>{e.jd(Number(x),Number(S),Number(T),!0)},892536:(x,S,T)=>{e.jd(Number(x),Number(S),Number(T))},892593:()=>typeof wasmOffsetConverter<"u",892650:x=>{e.ac("Abs",x,void 0)},892701:x=>{e.ac("Neg",x,void 0)},892752:x=>{e.ac("Floor",x,void 0)},892805:x=>{e.ac("Ceil",x,void 0)},892857:x=>{e.ac("Reciprocal",x,void 0)},892915:x=>{e.ac("Sqrt",x,void 0)},892967:x=>{e.ac("Exp",x,void 0)},893018:x=>{e.ac("Erf",x,void 0)},893069:x=>{e.ac("Sigmoid",x,void 0)},893124:(x,S,T)=>{e.ac("HardSigmoid",x,{alpha:S,beta:T})},893203:x=>{e.ac("Log",x,void 0)},893254:x=>{e.ac("Sin",x,void 0)},893305:x=>{e.ac("Cos",x,void 0)},893356:x=>{e.ac("Tan",x,void 0)},893407:x=>{e.ac("Asin",x,void 0)},893459:x=>{e.ac("Acos",x,void 0)},893511:x=>{e.ac("Atan",x,void 0)},893563:x=>{e.ac("Sinh",x,void 0)},893615:x=>{e.ac("Cosh",x,void 0)},893667:x=>{e.ac("Asinh",x,void 0)},893720:x=>{e.ac("Acosh",x,void 0)},893773:x=>{e.ac("Atanh",x,void 0)},893826:x=>{e.ac("Tanh",x,void 0)},893878:x=>{e.ac("Not",x,void 0)},893929:(x,S,T)=>{e.ac("Clip",x,{min:S,max:T})},893998:x=>{e.ac("Clip",x,void 0)},894050:(x,S)=>{e.ac("Elu",x,{alpha:S})},894108:x=>{e.ac("Gelu",x,void 0)},894160:x=>{e.ac("Relu",x,void 0)},894212:(x,S)=>{e.ac("LeakyRelu",x,{alpha:S})},894276:(x,S)=>{e.ac("ThresholdedRelu",x,{alpha:S})},894346:(x,S)=>{e.ac("Cast",x,{to:S})},894404:x=>{e.ac("Add",x,void 0)},894455:x=>{e.ac("Sub",x,void 0)},894506:x=>{e.ac("Mul",x,void 0)},894557:x=>{e.ac("Div",x,void 0)},894608:x=>{e.ac("Pow",x,void 0)},894659:x=>{e.ac("Equal",x,void 0)},894712:x=>{e.ac("Greater",x,void 0)},894767:x=>{e.ac("GreaterOrEqual",x,void 0)},894829:x=>{e.ac("Less",x,void 0)},894881:x=>{e.ac("LessOrEqual",x,void 0)},894940:(x,S,T,D,R)=>{e.ac("ReduceMean",x,{keepDims:!!S,noopWithEmptyAxes:!!T,axes:D?Array.from((I(),L).subarray(Number(D)>>>0,Number(R)>>>0)):[]})},895115:(x,S,T,D,R)=>{e.ac("ReduceMax",x,{keepDims:!!S,noopWithEmptyAxes:!!T,axes:D?Array.from((I(),L).subarray(Number(D)>>>0,Number(R)>>>0)):[]})},895289:(x,S,T,D,R)=>{e.ac("ReduceMin",x,{keepDims:!!S,noopWithEmptyAxes:!!T,axes:D?Array.from((I(),L).subarray(Number(D)>>>0,Number(R)>>>0)):[]})},895463:(x,S,T,D,R)=>{e.ac("ReduceProd",x,{keepDims:!!S,noopWithEmptyAxes:!!T,axes:D?Array.from((I(),L).subarray(Number(D)>>>0,Number(R)>>>0)):[]})},895638:(x,S,T,D,R)=>{e.ac("ReduceSum",x,{keepDims:!!S,noopWithEmptyAxes:!!T,axes:D?Array.from((I(),L).subarray(Number(D)>>>0,Number(R)>>>0)):[]})},895812:(x,S,T,D,R)=>{e.ac("ReduceL1",x,{keepDims:!!S,noopWithEmptyAxes:!!T,axes:D?Array.from((I(),L).subarray(Number(D)>>>0,Number(R)>>>0)):[]})},895985:(x,S,T,D,R)=>{e.ac("ReduceL2",x,{keepDims:!!S,noopWithEmptyAxes:!!T,axes:D?Array.from((I(),L).subarray(Number(D)>>>0,Number(R)>>>0)):[]})},896158:(x,S,T,D,R)=>{e.ac("ReduceLogSum",x,{keepDims:!!S,noopWithEmptyAxes:!!T,axes:D?Array.from((I(),L).subarray(Number(D)>>>0,Number(R)>>>0)):[]})},896335:(x,S,T,D,R)=>{e.ac("ReduceSumSquare",x,{keepDims:!!S,noopWithEmptyAxes:!!T,axes:D?Array.from((I(),L).subarray(Number(D)>>>0,Number(R)>>>0)):[]})},896515:(x,S,T,D,R)=>{e.ac("ReduceLogSumExp",x,{keepDims:!!S,noopWithEmptyAxes:!!T,axes:D?Array.from((I(),L).subarray(Number(D)>>>0,Number(R)>>>0)):[]})},896695:x=>{e.ac("Where",x,void 0)},896748:(x,S,T)=>{e.ac("Transpose",x,{perm:S?Array.from((I(),L).subarray(Number(S)>>>0,Number(T)>>>0)):[]})},896872:(x,S,T,D)=>{e.ac("DepthToSpace",x,{blocksize:S,mode:Vt(T),format:D?"NHWC":"NCHW"})},897005:(x,S,T,D)=>{e.ac("DepthToSpace",x,{blocksize:S,mode:Vt(T),format:D?"NHWC":"NCHW"})},897138:(x,S,T,D,R,V,Q,ie,pe,ye,Ue,at,mt,$t,Hr)=>{e.ac("ConvTranspose",x,{format:pe?"NHWC":"NCHW",autoPad:S,dilations:[T],group:D,kernelShape:[R],pads:[V,Q],strides:[ie],wIsConst:()=>!!(I(),P)[ye>>>0],outputPadding:Ue?Array.from((I(),L).subarray(Number(Ue)>>>0,Number(at)>>>0)):[],outputShape:mt?Array.from((I(),L).subarray(Number(mt)>>>0,Number($t)>>>0)):[],activation:Vt(Hr)})},897571:(x,S,T,D,R,V,Q,ie,pe,ye,Ue,at,mt,$t)=>{e.ac("ConvTranspose",x,{format:ie?"NHWC":"NCHW",autoPad:S,dilations:Array.from((I(),L).subarray(Number(T)>>>0,2+(Number(T)>>>0)>>>0)),group:D,kernelShape:Array.from((I(),L).subarray(Number(R)>>>0,2+(Number(R)>>>0)>>>0)),pads:Array.from((I(),L).subarray(Number(V)>>>0,4+(Number(V)>>>0)>>>0)),strides:Array.from((I(),L).subarray(Number(Q)>>>0,2+(Number(Q)>>>0)>>>0)),wIsConst:()=>!!(I(),P)[pe>>>0],outputPadding:ye?Array.from((I(),L).subarray(Number(ye)>>>0,Number(Ue)>>>0)):[],outputShape:at?Array.from((I(),L).subarray(Number(at)>>>0,Number(mt)>>>0)):[],activation:Vt($t)})},898232:(x,S,T,D,R,V,Q,ie,pe,ye,Ue,at,mt,$t,Hr)=>{e.ac("ConvTranspose",x,{format:pe?"NHWC":"NCHW",autoPad:S,dilations:[T],group:D,kernelShape:[R],pads:[V,Q],strides:[ie],wIsConst:()=>!!(I(),P)[ye>>>0],outputPadding:Ue?Array.from((I(),L).subarray(Number(Ue)>>>0,Number(at)>>>0)):[],outputShape:mt?Array.from((I(),L).subarray(Number(mt)>>>0,Number($t)>>>0)):[],activation:Vt(Hr)})},898665:(x,S,T,D,R,V,Q,ie,pe,ye,Ue,at,mt,$t)=>{e.ac("ConvTranspose",x,{format:ie?"NHWC":"NCHW",autoPad:S,dilations:Array.from((I(),L).subarray(Number(T)>>>0,2+(Number(T)>>>0)>>>0)),group:D,kernelShape:Array.from((I(),L).subarray(Number(R)>>>0,2+(Number(R)>>>0)>>>0)),pads:Array.from((I(),L).subarray(Number(V)>>>0,4+(Number(V)>>>0)>>>0)),strides:Array.from((I(),L).subarray(Number(Q)>>>0,2+(Number(Q)>>>0)>>>0)),wIsConst:()=>!!(I(),P)[pe>>>0],outputPadding:ye?Array.from((I(),L).subarray(Number(ye)>>>0,Number(Ue)>>>0)):[],outputShape:at?Array.from((I(),L).subarray(Number(at)>>>0,Number(mt)>>>0)):[],activation:Vt($t)})},899326:(x,S)=>{e.ac("GlobalAveragePool",x,{format:S?"NHWC":"NCHW"})},899417:(x,S,T,D,R,V,Q,ie,pe,ye,Ue,at,mt,$t)=>{e.ac("AveragePool",x,{format:$t?"NHWC":"NCHW",auto_pad:S,ceil_mode:T,count_include_pad:D,storage_order:R,dilations:V?Array.from((I(),L).subarray(Number(V)>>>0,Number(Q)>>>0)):[],kernel_shape:ie?Array.from((I(),L).subarray(Number(ie)>>>0,Number(pe)>>>0)):[],pads:ye?Array.from((I(),L).subarray(Number(ye)>>>0,Number(Ue)>>>0)):[],strides:at?Array.from((I(),L).subarray(Number(at)>>>0,Number(mt)>>>0)):[]})},899896:(x,S)=>{e.ac("GlobalAveragePool",x,{format:S?"NHWC":"NCHW"})},899987:(x,S,T,D,R,V,Q,ie,pe,ye,Ue,at,mt,$t)=>{e.ac("AveragePool",x,{format:$t?"NHWC":"NCHW",auto_pad:S,ceil_mode:T,count_include_pad:D,storage_order:R,dilations:V?Array.from((I(),L).subarray(Number(V)>>>0,Number(Q)>>>0)):[],kernel_shape:ie?Array.from((I(),L).subarray(Number(ie)>>>0,Number(pe)>>>0)):[],pads:ye?Array.from((I(),L).subarray(Number(ye)>>>0,Number(Ue)>>>0)):[],strides:at?Array.from((I(),L).subarray(Number(at)>>>0,Number(mt)>>>0)):[]})},900466:(x,S)=>{e.ac("GlobalMaxPool",x,{format:S?"NHWC":"NCHW"})},900553:(x,S,T,D,R,V,Q,ie,pe,ye,Ue,at,mt,$t)=>{e.ac("MaxPool",x,{format:$t?"NHWC":"NCHW",auto_pad:S,ceil_mode:T,count_include_pad:D,storage_order:R,dilations:V?Array.from((I(),L).subarray(Number(V)>>>0,Number(Q)>>>0)):[],kernel_shape:ie?Array.from((I(),L).subarray(Number(ie)>>>0,Number(pe)>>>0)):[],pads:ye?Array.from((I(),L).subarray(Number(ye)>>>0,Number(Ue)>>>0)):[],strides:at?Array.from((I(),L).subarray(Number(at)>>>0,Number(mt)>>>0)):[]})},901028:(x,S)=>{e.ac("GlobalMaxPool",x,{format:S?"NHWC":"NCHW"})},901115:(x,S,T,D,R,V,Q,ie,pe,ye,Ue,at,mt,$t)=>{e.ac("MaxPool",x,{format:$t?"NHWC":"NCHW",auto_pad:S,ceil_mode:T,count_include_pad:D,storage_order:R,dilations:V?Array.from((I(),L).subarray(Number(V)>>>0,Number(Q)>>>0)):[],kernel_shape:ie?Array.from((I(),L).subarray(Number(ie)>>>0,Number(pe)>>>0)):[],pads:ye?Array.from((I(),L).subarray(Number(ye)>>>0,Number(Ue)>>>0)):[],strides:at?Array.from((I(),L).subarray(Number(at)>>>0,Number(mt)>>>0)):[]})},901590:(x,S,T,D,R)=>{e.ac("Gemm",x,{alpha:S,beta:T,transA:D,transB:R})},901694:x=>{e.ac("MatMul",x,void 0)},901748:(x,S,T,D)=>{e.ac("ArgMax",x,{keepDims:!!S,selectLastIndex:!!T,axis:D})},901856:(x,S,T,D)=>{e.ac("ArgMin",x,{keepDims:!!S,selectLastIndex:!!T,axis:D})},901964:(x,S)=>{e.ac("Softmax",x,{axis:S})},902027:(x,S)=>{e.ac("Concat",x,{axis:S})},902087:(x,S,T,D,R)=>{e.ac("Split",x,{axis:S,numOutputs:T,splitSizes:D?Array.from((I(),L).subarray(Number(D)>>>0,Number(R)>>>0)):[]})},902243:x=>{e.ac("Expand",x,void 0)},902297:(x,S)=>{e.ac("Gather",x,{axis:Number(S)})},902368:(x,S)=>{e.ac("GatherElements",x,{axis:Number(S)})},902447:(x,S)=>{e.ac("GatherND",x,{batch_dims:Number(S)})},902526:(x,S,T,D,R,V,Q,ie,pe,ye,Ue)=>{e.ac("Resize",x,{antialias:S,axes:T?Array.from((I(),L).subarray(Number(T)>>>0,Number(D)>>>0)):[],coordinateTransformMode:Vt(R),cubicCoeffA:V,excludeOutside:Q,extrapolationValue:ie,keepAspectRatioPolicy:Vt(pe),mode:Vt(ye),nearestMode:Vt(Ue)})},902888:(x,S,T,D,R,V,Q)=>{e.ac("Slice",x,{starts:S?Array.from((I(),L).subarray(Number(S)>>>0,Number(T)>>>0)):[],ends:D?Array.from((I(),L).subarray(Number(D)>>>0,Number(R)>>>0)):[],axes:V?Array.from((I(),L).subarray(Number(V)>>>0,Number(Q)>>>0)):[]})},903152:x=>{e.ac("Tile",x,void 0)},903204:(x,S,T)=>{e.ac("InstanceNormalization",x,{epsilon:S,format:T?"NHWC":"NCHW"})},903318:(x,S,T)=>{e.ac("InstanceNormalization",x,{epsilon:S,format:T?"NHWC":"NCHW"})},903432:x=>{e.ac("Range",x,void 0)},903485:(x,S)=>{e.ac("Einsum",x,{equation:Vt(S)})},903566:(x,S,T,D,R)=>{e.ac("Pad",x,{mode:S,value:T,pads:D?Array.from((I(),L).subarray(Number(D)>>>0,Number(R)>>>0)):[]})},903709:(x,S,T,D,R,V)=>{e.ac("BatchNormalization",x,{epsilon:S,momentum:T,spatial:!!R,trainingMode:!!D,format:V?"NHWC":"NCHW"})},903878:(x,S,T,D,R,V)=>{e.ac("BatchNormalization",x,{epsilon:S,momentum:T,spatial:!!R,trainingMode:!!D,format:V?"NHWC":"NCHW"})},904047:(x,S,T)=>{e.ac("CumSum",x,{exclusive:Number(S),reverse:Number(T)})},904144:(x,S,T)=>{e.ac("DequantizeLinear",x,{axis:S,blockSize:T})},904234:(x,S,T,D,R)=>{e.ac("GridSample",x,{align_corners:S,mode:Vt(T),padding_mode:Vt(D),format:R?"NHWC":"NCHW"})},904404:(x,S,T,D,R)=>{e.ac("GridSample",x,{align_corners:S,mode:Vt(T),padding_mode:Vt(D),format:R?"NHWC":"NCHW"})},904574:(x,S)=>{e.ac("ScatterND",x,{reduction:Vt(S)})},904659:(x,S,T,D,R,V,Q,ie,pe)=>{e.ac("Attention",x,{numHeads:S,isUnidirectional:T,maskFilterValue:D,scale:R,doRotary:V,qkvHiddenSizes:Q?Array.from((I(),L).subarray(Number(ie)>>>0,Number(ie)+Q>>>0)):[],pastPresentShareBuffer:!!pe})},904931:x=>{e.ac("BiasAdd",x,void 0)},904986:x=>{e.ac("BiasSplitGelu",x,void 0)},905047:x=>{e.ac("FastGelu",x,void 0)},905103:(x,S,T,D,R,V,Q,ie,pe,ye,Ue,at,mt,$t,Hr,zp)=>{e.ac("Conv",x,{format:at?"NHWC":"NCHW",auto_pad:S,dilations:T?Array.from((I(),L).subarray(Number(T)>>>0,Number(D)>>>0)):[],group:R,kernel_shape:V?Array.from((I(),L).subarray(Number(V)>>>0,Number(Q)>>>0)):[],pads:ie?Array.from((I(),L).subarray(Number(ie)>>>0,Number(pe)>>>0)):[],strides:ye?Array.from((I(),L).subarray(Number(ye)>>>0,Number(Ue)>>>0)):[],w_is_const:()=>!!(I(),P)[Number(mt)>>>0],activation:Vt($t),activation_params:Hr?Array.from((I(),Y).subarray(Number(Hr)>>>0,Number(zp)>>>0)):[]})},905687:x=>{e.ac("Gelu",x,void 0)},905739:(x,S,T,D,R,V,Q,ie,pe)=>{e.ac("GroupQueryAttention",x,{numHeads:S,kvNumHeads:T,scale:D,softcap:R,doRotary:V,rotaryInterleaved:Q,smoothSoftmax:ie,localWindowSize:pe})},905956:(x,S,T,D)=>{e.ac("LayerNormalization",x,{axis:S,epsilon:T,simplified:!!D})},906067:(x,S,T,D)=>{e.ac("LayerNormalization",x,{axis:S,epsilon:T,simplified:!!D})},906178:(x,S,T,D,R,V)=>{e.ac("MatMulNBits",x,{k:S,n:T,accuracyLevel:D,bits:R,blockSize:V})},906305:(x,S,T,D,R,V)=>{e.ac("MultiHeadAttention",x,{numHeads:S,isUnidirectional:T,maskFilterValue:D,scale:R,doRotary:V})},906464:(x,S)=>{e.ac("QuickGelu",x,{alpha:S})},906528:(x,S,T,D,R)=>{e.ac("RotaryEmbedding",x,{interleaved:!!S,numHeads:T,rotaryEmbeddingDim:D,scale:R})},906667:(x,S,T)=>{e.ac("SkipLayerNormalization",x,{epsilon:S,simplified:!!T})},906769:(x,S,T)=>{e.ac("SkipLayerNormalization",x,{epsilon:S,simplified:!!T})},906871:(x,S,T,D)=>{e.ac("GatherBlockQuantized",x,{gatherAxis:S,quantizeAxis:T,blockSize:D})},906992:x=>{e.Id(x)},907026:(x,S)=>e.Kd(Number(x),Number(S),e.$c.Nd,e.$c.errors)};function xF(x,S,T){return _x(async()=>{await e.Gd(Number(x),Number(S),Number(T))})}function wF(){return typeof wasmOffsetConverter<"u"}var Wx,Ux,Ap,sr,Co,Rp,Gx,Hx,qx,Dp,jx,Kx,Xe,To,Xx,Ge,Op,je,Yx,Zx,Qx,Jx,ew,tw,nw,Fp,sw,rw,aw,iw,ow,uw,lw,cw,dw,hw,pw,fw,mw,gw,yw,bw,xw,ww,$w,vw,Sw,Iw,_w,kw,Cw,Tw,Nw,Ew,Aw,Rw,Dw,Ow,Fw,zw,Lw,Pw,Bw,Mw,Gr=await async function(){function x(D,R){var V=Gr=D.exports;D={};for(let[Q,ie]of Object.entries(V))typeof ie=="function"?(V=D3(ie),D[Q]=V):D[Q]=ie;return Gr=D,Gr=function(){var Q=Gr,ie=ye=>Ue=>ye(Ue)>>>0,pe=ye=>()=>ye()>>>0;return(Q=Object.assign({},Q)).ub=ie(Q.ub),Q.Yb=pe(Q.Yb),Q._b=ie(Q._b),Q.mc=ie(Q.mc),Q.nc=pe(Q.nc),Q.rc=ie(Q.rc),Q}(),er.push(Gr.$b),f=R,Wx=(R=Gr).ub,Ux=R.vb,e._OrtInit=R.wb,e._OrtGetLastError=R.xb,e._OrtCreateSessionOptions=R.yb,e._OrtAppendExecutionProvider=R.zb,e._OrtAddFreeDimensionOverride=R.Ab,e._OrtAddSessionConfigEntry=R.Bb,e._OrtReleaseSessionOptions=R.Cb,e._OrtCreateSession=R.Db,e._OrtReleaseSession=R.Eb,e._OrtGetInputOutputCount=R.Fb,e._OrtGetInputOutputMetadata=R.Gb,e._OrtFree=R.Hb,e._OrtCreateTensor=R.Ib,e._OrtGetTensorData=R.Jb,e._OrtReleaseTensor=R.Kb,e._OrtCreateRunOptions=R.Lb,e._OrtAddRunConfigEntry=R.Mb,e._OrtReleaseRunOptions=R.Nb,e._OrtCreateBinding=R.Ob,e._OrtBindInput=R.Pb,e._OrtBindOutput=R.Qb,e._OrtClearBoundOutputs=R.Rb,e._OrtReleaseBinding=R.Sb,e._OrtRunWithBinding=R.Tb,e._OrtRun=R.Ub,e._OrtEndProfiling=R.Vb,e._JsepOutput=R.Wb,e._JsepGetNodeName=R.Xb,Ap=R.Yb,e._free=sr=R.Zb,e._malloc=Co=R._b,Rp=R.bc,Gx=R.cc,Hx=R.dc,qx=R.ec,Dp=R.fc,jx=R.gc,Kx=R.hc,Xe=R.ic,To=R.jc,Xx=R.kc,Ge=R.lc,Op=R.mc,je=R.nc,Yx=R.oc,Zx=R.pc,Qx=R.qc,Jx=R.rc,ew=R.sc,tw=R.tc,nw=R.uc,Fp=R.vc,sw=R.wc,rw=R.xc,aw=R.yc,iw=R.zc,ow=R.Ac,uw=R.Bc,lw=R.Cc,cw=R.Dc,dw=R.Ec,hw=R.Fc,pw=R.Gc,fw=R.Hc,mw=R.Ic,gw=R.Jc,yw=R.Kc,bw=R.Lc,xw=R.Mc,ww=R.Nc,$w=R.Oc,vw=R.Qc,Sw=R.Rc,Iw=R.Sc,_w=R.bd,kw=R.cd,Cw=R.hd,Tw=R.kd,Nw=R.ld,Ew=R.md,Aw=R.nd,Rw=R.od,Dw=R.pd,Ow=R.qd,Fw=R.rd,zw=R.sd,Lw=R.Rd,Pw=R.Sd,Bw=R.Td,Mw=R.Ud,$e(),Gr}xe++;var S,T=ze();return e.instantiateWasm?new Promise(D=>{e.instantiateWasm(T,(R,V)=>{D(x(R,V))})}):r?new Promise(D=>{b=R=>{var V=new WebAssembly.Instance(R,ze());D(x(V,R))}}):(fe??(fe=e.locateFile?e.locateFile?e.locateFile("ort-wasm-simd-threaded.jsep.wasm",h):h+"ort-wasm-simd-threaded.jsep.wasm":new URL(""+new URL("ort-wasm-simd-threaded.jsep-Bvhpdk4G.wasm",import.meta.url).href,import.meta.url).href),S=await async function(D){var R=fe;if(!p&&typeof WebAssembly.instantiateStreaming=="function"&&!A(R))try{var V=fetch(R,{credentials:"same-origin"});return await WebAssembly.instantiateStreaming(V,D)}catch(Q){C(`wasm streaming compile failed: ${Q}`),C("falling back to ArrayBuffer instantiation")}return async function(Q,ie){try{var pe=await async function(ye){if(!p)try{var Ue=await u(ye);return new Uint8Array(Ue)}catch{}if(ye==fe&&p)ye=new Uint8Array(p);else{if(!l)throw"both async and sync fetching of the wasm failed";ye=l(ye)}return ye}(Q);return await WebAssembly.instantiate(pe,ie)}catch(ye){C(`failed to asynchronously prepare wasm: ${ye}`),Ee(ye)}}(R,D)}(T),x(S.instance,S.module))}();function $F(x,S,T,D){var R=je();try{return tw(x,S,T,D)}catch(V){if(Ge(R),V!==V+0)throw V;Xe(1,0)}}function vF(x,S,T){var D=je();try{return nw(x,S,T)}catch(R){if(Ge(D),R!==R+0)throw R;Xe(1,0)}}function SF(x,S,T){var D=je();try{ew(x,S,T)}catch(R){if(Ge(D),R!==R+0)throw R;Xe(1,0)}}function IF(x,S){var T=je();try{return Fp(x,S)}catch(D){if(Ge(T),D!==D+0)throw D;Xe(1,0)}}function _F(x,S){var T=je();try{rw(x,S)}catch(D){if(Ge(T),D!==D+0)throw D;Xe(1,0)}}function kF(x){var S=je();try{aw(x)}catch(T){if(Ge(S),T!==T+0)throw T;Xe(1,0)}}function CF(x,S,T,D,R,V,Q){var ie=je();try{return sw(x,S,T,D,R,V,Q)}catch(pe){if(Ge(ie),pe!==pe+0)throw pe;Xe(1,0)}}function TF(x,S,T,D){var R=je();try{iw(x,S,T,D)}catch(V){if(Ge(R),V!==V+0)throw V;Xe(1,0)}}function NF(x,S,T,D,R){var V=je();try{ow(x,S,T,D,R)}catch(Q){if(Ge(V),Q!==Q+0)throw Q;Xe(1,0)}}function EF(x,S,T,D,R,V){var Q=je();try{uw(x,S,T,D,R,V)}catch(ie){if(Ge(Q),ie!==ie+0)throw ie;Xe(1,0)}}function AF(x,S,T,D,R,V,Q){var ie=je();try{lw(x,S,T,D,R,V,Q)}catch(pe){if(Ge(ie),pe!==pe+0)throw pe;Xe(1,0)}}function RF(x,S,T,D,R,V,Q,ie){var pe=je();try{cw(x,S,T,D,R,V,Q,ie)}catch(ye){if(Ge(pe),ye!==ye+0)throw ye;Xe(1,0)}}function DF(x,S,T,D){var R=je();try{dw(x,S,T,D)}catch(V){if(Ge(R),V!==V+0)throw V;Xe(1,0)}}function OF(x,S,T,D,R,V,Q){var ie=je();try{hw(x,S,T,D,R,V,Q)}catch(pe){if(Ge(ie),pe!==pe+0)throw pe;Xe(1,0)}}function FF(x,S,T,D,R){var V=je();try{return pw(x,S,T,D,R)}catch(Q){if(Ge(V),Q!==Q+0)throw Q;Xe(1,0)}}function zF(x,S,T,D,R,V,Q,ie){var pe=je();try{fw(x,S,T,D,R,V,Q,ie)}catch(ye){if(Ge(pe),ye!==ye+0)throw ye;Xe(1,0)}}function LF(x,S,T,D,R,V,Q,ie,pe,ye,Ue,at){var mt=je();try{mw(x,S,T,D,R,V,Q,ie,pe,ye,Ue,at)}catch($t){if(Ge(mt),$t!==$t+0)throw $t;Xe(1,0)}}function PF(x,S,T,D,R,V){var Q=je();try{return gw(x,S,T,D,R,V)}catch(ie){if(Ge(Q),ie!==ie+0)throw ie;Xe(1,0)}}function BF(x,S){var T=je();try{return yw(x,S)}catch(D){if(Ge(T),D!==D+0)throw D;return Xe(1,0),0n}}function MF(x,S,T,D,R,V,Q,ie,pe){var ye=je();try{bw(x,S,T,D,R,V,Q,ie,pe)}catch(Ue){if(Ge(ye),Ue!==Ue+0)throw Ue;Xe(1,0)}}function VF(x){var S=je();try{return xw(x)}catch(T){if(Ge(S),T!==T+0)throw T;Xe(1,0)}}function WF(x){var S=je();try{return $w(x)}catch(T){if(Ge(S),T!==T+0)throw T;return Xe(1,0),0n}}function UF(x,S,T,D,R,V){var Q=je();try{return Tw(x,S,T,D,R,V)}catch(ie){if(Ge(Q),ie!==ie+0)throw ie;Xe(1,0)}}function GF(x,S,T,D,R,V){var Q=je();try{return Nw(x,S,T,D,R,V)}catch(ie){if(Ge(Q),ie!==ie+0)throw ie;Xe(1,0)}}function HF(x,S,T){var D=je();try{return Ew(x,S,T)}catch(R){if(Ge(D),R!==R+0)throw R;Xe(1,0)}}function qF(x,S,T,D,R,V,Q,ie){var pe=je();try{return ww(x,S,T,D,R,V,Q,ie)}catch(ye){if(Ge(pe),ye!==ye+0)throw ye;Xe(1,0)}}function jF(x,S,T,D,R){var V=je();try{return Aw(x,S,T,D,R)}catch(Q){if(Ge(V),Q!==Q+0)throw Q;return Xe(1,0),0n}}function KF(x,S,T,D){var R=je();try{return Rw(x,S,T,D)}catch(V){if(Ge(R),V!==V+0)throw V;Xe(1,0)}}function XF(x,S,T,D){var R=je();try{return Dw(x,S,T,D)}catch(V){if(Ge(R),V!==V+0)throw V;Xe(1,0)}}function YF(x,S,T,D,R,V,Q,ie,pe,ye,Ue,at){var mt=je();try{return Ow(x,S,T,D,R,V,Q,ie,pe,ye,Ue,at)}catch($t){if(Ge(mt),$t!==$t+0)throw $t;Xe(1,0)}}function ZF(x,S,T,D,R,V,Q,ie,pe,ye,Ue){var at=je();try{kw(x,S,T,D,R,V,Q,ie,pe,ye,Ue)}catch(mt){if(Ge(at),mt!==mt+0)throw mt;Xe(1,0)}}function QF(x,S,T,D,R,V,Q,ie,pe,ye,Ue,at,mt,$t,Hr,zp){var az=je();try{Cw(x,S,T,D,R,V,Q,ie,pe,ye,Ue,at,mt,$t,Hr,zp)}catch(Lp){if(Ge(az),Lp!==Lp+0)throw Lp;Xe(1,0)}}function JF(x,S,T,D){var R=je();try{return Fw(x,S,T,D)}catch(V){if(Ge(R),V!==V+0)throw V;Xe(1,0)}}function ez(x,S,T,D,R){var V=je();try{return zw(x,S,T,D,R)}catch(Q){if(Ge(V),Q!==Q+0)throw Q;Xe(1,0)}}function tz(x,S,T){var D=je();try{return Sw(x,S,T)}catch(R){if(Ge(D),R!==R+0)throw R;return Xe(1,0),0n}}function nz(x,S,T){var D=je();try{return vw(x,S,T)}catch(R){if(Ge(D),R!==R+0)throw R;Xe(1,0)}}function sz(x,S,T){var D=je();try{return Iw(x,S,T)}catch(R){if(Ge(D),R!==R+0)throw R;Xe(1,0)}}function rz(x,S,T,D){var R=je();try{_w(x,S,T,D)}catch(V){if(Ge(R),V!==V+0)throw V;Xe(1,0)}}return function x(){if(0<xe)Ne=x;else if(r)g==null||g(e),de();else{for(;0<Je.length;)Je.shift()(e);0<xe?Ne=x:(e.calledRun=!0,N||(de(),g==null||g(e)))}}(),e.PTR_SIZE=4,J?e:new Promise((x,S)=>{g=x,y=S})}var VA,z$,ele=he(()=>{var t,e;VA=F$,z$=(e=(t=globalThis.self)==null?void 0:t.name)==null?void 0:e.startsWith("em-pthread"),z$&&F$()}),df,eg,L$,Jn,WA,hc,P$,B$,hf,M$,pf,UA,ff,GA,N0=he(()=>{T0(),df=typeof location>"u"?void 0:location.origin,eg=import.meta.url>"file:"&&import.meta.url<"file;",L$=()=>{{if(eg){let t=URL;return new URL(new t("ort.bundle.min.mjs",import.meta.url).href,df).href}return import.meta.url}},Jn=L$(),WA=()=>{if(Jn&&!Jn.startsWith("blob:"))return Jn.substring(0,Jn.lastIndexOf("/")+1)},hc=(t,e)=>{try{let n=e??Jn;return(n?new URL(t,n):new URL(t)).origin===df}catch{return!1}},P$=(t,e)=>{let n=e??Jn;try{return(n?new URL(t,n):new URL(t)).href}catch{return}},B$=(t,e)=>`${e??"./"}${t}`,hf=async t=>{let e=await(await fetch(t,{credentials:"same-origin"})).blob();return URL.createObjectURL(e)},M$=async t=>(await import(t)).default,pf=(Jue(),bu(PA)).default,UA=async()=>{if(!Jn)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(hc(Jn))return[void 0,pf()];let t=await hf(Jn);return[t,pf(t)]},ff=(ele(),bu(MA)).default,GA=async(t,e,n,s)=>{let r=ff&&!(t||e);if(r)if(Jn)r=hc(Jn);else if(s&&!n)r=!0;else throw new Error("cannot determine the script source URL.");if(r)return[void 0,ff];{let a="ort-wasm-simd-threaded.jsep.mjs",i=t??P$(a,e),o=n&&i&&!hc(i,e),u=o?await hf(i):i??B$(a,e);return[o?u:void 0,await M$(u)]}}}),mf,pc,Oo,gf,V$,W$,U$,E0,bt,ki=he(()=>{N0(),pc=!1,Oo=!1,gf=!1,V$=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},W$=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},U$=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,5,1,96,0,1,123,3,2,1,0,10,19,1,17,0,65,1,253,15,65,2,253,15,65,3,253,15,253,147,2,11]))}catch{return!1}},E0=async t=>{if(pc)return Promise.resolve();if(Oo)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(gf)throw new Error("previous call to 'initializeWebAssembly()' failed.");Oo=!0;let e=t.initTimeout,n=t.numThreads;if(t.simd!==!1){if(t.simd==="relaxed"){if(!U$())throw new Error("Relaxed WebAssembly SIMD is not supported in the current environment.")}else if(!W$())throw new Error("WebAssembly SIMD is not supported in the current environment.")}let s=V$();n>1&&!s&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+n+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),t.numThreads=n=1);let r=t.wasmPaths,a=typeof r=="string"?r:void 0,i=r==null?void 0:r.mjs,o=(i==null?void 0:i.href)??i,u=r==null?void 0:r.wasm,l=(u==null?void 0:u.href)??u,c=t.wasmBinary,[d,h]=await GA(o,a,n>1,!!c||!!l),p=!1,f=[];if(e>0&&f.push(new Promise(m=>{setTimeout(()=>{p=!0,m()},e)})),f.push(new Promise((m,g)=>{let y={numThreads:n};if(c)y.wasmBinary=c;else if(l||a)y.locateFile=b=>l??a+b;else if(o&&o.indexOf("blob:")!==0)y.locateFile=b=>new URL(b,o).href;else if(d){let b=WA();b&&(y.locateFile=$=>b+$)}h(y).then(b=>{Oo=!1,pc=!0,mf=b,m(),d&&URL.revokeObjectURL(d)},b=>{Oo=!1,gf=!0,g(b)})})),await Promise.race(f),p)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},bt=()=>{if(pc&&mf)return mf;throw new Error("WebAssembly is not initialized yet.")}}),Us,pd,dt,A0=he(()=>{ki(),Us=(t,e)=>{let n=bt(),s=n.lengthBytesUTF8(t)+1,r=n._malloc(s);return n.stringToUTF8(t,r,s),e.push(r),r},pd=(t,e,n,s)=>{if(typeof t=="object"&&t!==null){if(n.has(t))throw new Error("Circular reference in options");n.add(t)}Object.entries(t).forEach(([r,a])=>{let i=e?e+r:r;if(typeof a=="object")pd(a,i+".",n,s);else if(typeof a=="string"||typeof a=="number")s(i,a.toString());else if(typeof a=="boolean")s(i,a?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof a}`)})},dt=t=>{let e=bt(),n=e.stackSave();try{let s=e.PTR_SIZE,r=e.stackAlloc(2*s);e._OrtGetLastError(r,r+s);let a=Number(e.getValue(r,s===4?"i32":"i64")),i=e.getValue(r+s,"*"),o=i?e.UTF8ToString(i):"";throw new Error(`${t} ERROR_CODE: ${a}, ERROR_MESSAGE: ${o}`)}finally{e.stackRestore(n)}}}),HA,tle=he(()=>{ki(),A0(),HA=t=>{let e=bt(),n=0,s=[],r=t||{};try{if((t==null?void 0:t.logSeverityLevel)===void 0)r.logSeverityLevel=2;else if(typeof t.logSeverityLevel!="number"||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log severity level is not valid: ${t.logSeverityLevel}`);if((t==null?void 0:t.logVerbosityLevel)===void 0)r.logVerbosityLevel=0;else if(typeof t.logVerbosityLevel!="number"||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);(t==null?void 0:t.terminate)===void 0&&(r.terminate=!1);let a=0;return(t==null?void 0:t.tag)!==void 0&&(a=Us(t.tag,s)),n=e._OrtCreateRunOptions(r.logSeverityLevel,r.logVerbosityLevel,!!r.terminate,a),n===0&&dt("Can't create run options."),(t==null?void 0:t.extra)!==void 0&&pd(t.extra,"",new WeakSet,(i,o)=>{let u=Us(i,s),l=Us(o,s);e._OrtAddRunConfigEntry(n,u,l)!==0&&dt(`Can't set a run config entry: ${i} - ${o}.`)}),[n,s]}catch(a){throw n!==0&&e._OrtReleaseRunOptions(n),s.forEach(i=>e._free(i)),a}}}),G$,H$,q$,Fo,j$,qA,nle=he(()=>{ki(),A0(),G$=t=>{switch(t){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"layout":return 3;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}},H$=t=>{switch(t){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}},q$=t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});let e=t.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1"),t.executionProviders&&t.executionProviders.some(n=>(typeof n=="string"?n:n.name)==="webgpu")&&(t.enableMemPattern=!1)},Fo=(t,e,n,s)=>{let r=Us(e,s),a=Us(n,s);bt()._OrtAddSessionConfigEntry(t,r,a)!==0&&dt(`Can't set a session config entry: ${e} - ${n}.`)},j$=async(t,e,n)=>{for(let s of e){let r=typeof s=="string"?s:s.name,a=[];switch(r){case"webnn":if(r="WEBNN",typeof s!="string"){let c=s==null?void 0:s.deviceType;c&&Fo(t,"deviceType",c,n)}break;case"webgpu":if(r="JS",typeof s!="string"){let c=s;if(c!=null&&c.preferredLayout){if(c.preferredLayout!=="NCHW"&&c.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${c.preferredLayout}`);Fo(t,"preferredLayout",c.preferredLayout,n)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${r}`)}let i=Us(r,n),o=a.length,u=0,l=0;if(o>0){u=bt()._malloc(o*bt().PTR_SIZE),n.push(u),l=bt()._malloc(o*bt().PTR_SIZE),n.push(l);for(let c=0;c<o;c++)bt().setValue(u+c*bt().PTR_SIZE,a[c][0],"*"),bt().setValue(l+c*bt().PTR_SIZE,a[c][1],"*")}await bt()._OrtAppendExecutionProvider(t,i,u,l,o)!==0&&dt(`Can't append execution provider: ${r}.`)}},qA=async t=>{let e=bt(),n=0,s=[],r=t||{};q$(r);try{let a=G$(r.graphOptimizationLevel??"all"),i=H$(r.executionMode??"sequential"),o=typeof r.logId=="string"?Us(r.logId,s):0,u=r.logSeverityLevel??2;if(!Number.isInteger(u)||u<0||u>4)throw new Error(`log severity level is not valid: ${u}`);let l=r.logVerbosityLevel??0;if(!Number.isInteger(l)||l<0||l>4)throw new Error(`log verbosity level is not valid: ${l}`);let c=typeof r.optimizedModelFilePath=="string"?Us(r.optimizedModelFilePath,s):0;if(n=e._OrtCreateSessionOptions(a,!!r.enableCpuMemArena,!!r.enableMemPattern,i,!!r.enableProfiling,0,o,u,l,c),n===0&&dt("Can't create session options."),r.executionProviders&&await j$(n,r.executionProviders,s),r.enableGraphCapture!==void 0){if(typeof r.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${r.enableGraphCapture}`);Fo(n,"enableGraphCapture",r.enableGraphCapture.toString(),s)}if(r.freeDimensionOverrides)for(let[d,h]of Object.entries(r.freeDimensionOverrides)){if(typeof d!="string")throw new Error(`free dimension override name must be a string: ${d}`);if(typeof h!="number"||!Number.isInteger(h)||h<0)throw new Error(`free dimension override value must be a non-negative integer: ${h}`);let p=Us(d,s);e._OrtAddFreeDimensionOverride(n,p,h)!==0&&dt(`Can't set a free dimension override: ${d} - ${h}.`)}return r.extra!==void 0&&pd(r.extra,"",new WeakSet,(d,h)=>{Fo(n,d,h,s)}),[n,s]}catch(a){throw n!==0&&e._OrtReleaseSessionOptions(n)!==0&&dt("Can't release session options."),s.forEach(i=>e._free(i)),a}}}),Ua,Cr,Ga,pp,fd,R0,D0,tg,De=he(()=>{Ua=t=>{switch(t){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${t}`)}},Cr=t=>{switch(t){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${t}`)}},Ga=(t,e)=>{let n=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][t],s=typeof e=="number"?e:e.reduce((r,a)=>r*a,1);return n>0?Math.ceil(s*n):void 0},pp=t=>{switch(t){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}},fd=t=>{switch(t){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${t}`)}},R0=t=>t==="float32"||t==="float16"||t==="int32"||t==="int64"||t==="uint32"||t==="uint8"||t==="bool"||t==="uint4"||t==="int4",D0=t=>t==="float32"||t==="float16"||t==="int32"||t==="int64"||t==="uint32"||t==="uint64"||t==="int8"||t==="uint8"||t==="bool"||t==="uint4"||t==="int4",tg=t=>{switch(t){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${t}`)}}}),O0,jA=he(()=>{T0(),O0=async t=>{if(typeof t=="string"){let e=await fetch(t);if(!e.ok)throw new Error(`failed to load external data file: ${t}`);let n=e.headers.get("Content-Length"),s=n?parseInt(n,10):0;if(s<1073741824)return new Uint8Array(await e.arrayBuffer());{if(!e.body)throw new Error(`failed to load external data file: ${t}, no response body.`);let r=e.body.getReader(),a;try{a=new ArrayBuffer(s)}catch(o){if(o instanceof RangeError){let u=Math.ceil(s/65536);a=new WebAssembly.Memory({initial:u,maximum:u}).buffer}else throw o}let i=0;for(;;){let{done:o,value:u}=await r.read();if(o)break;let l=u.byteLength;new Uint8Array(a,i,l).set(u),i+=l}return new Uint8Array(a,0,s)}}else return t instanceof Blob?new Uint8Array(await t.arrayBuffer()):t instanceof Uint8Array?t:new Uint8Array(t)}}),K$,X$,Y$,Z$,F0,Q$,et,Br=he(()=>{De(),K$=["V","I","W","E","F"],X$=(t,e)=>{console.log(`[${K$[t]},${new Date().toISOString()}]${e}`)},F0=(t,e)=>{Y$=t,Z$=e},Q$=(t,e)=>{let n=fd(t),s=fd(Y$);n>=s&&X$(n,typeof e=="function"?e():e)},et=(...t)=>{Z$&&Q$(...t)}}),J$,ro,re,md,KA,XA,YA,Be=he(()=>{J$=class{static calcMatMulShape(t,e){return t[1]!==e[0]?void 0:[t[0],e[1]]}},ro=class{static calcShape(t,e,n=!1){let s=t.length,r=e.length;if(s===0)return e;if(r===0)return t;let a=Math.max(t.length,e.length),i=new Array(a);if(n){if(s<2||r<2)return;let o=J$.calcMatMulShape([t[s-2],t[s-1]],[e[r-2],e[r-1]]);if(o===void 0)return;[i[a-2],i[a-1]]=o}for(let o=n?3:1;o<=a;o++){let u=s-o<0?1:t[s-o],l=r-o<0?1:e[r-o];if(u!==l&&u>1&&l>1)return;let c=Math.max(u,l);if(u&&l)i[a-o]=Math.max(u,l);else{if(c>1)return;i[a-o]=0}}return i}static isValidBroadcast(t,e){let n=t.length,s=e.length;if(n>s)return!1;for(let r=1;r<=n;r++)if(t[n-r]!==1&&t[n-r]!==e[s-r])return!1;return!0}},re=class Fc{static size(e){return Fc.getSizeFromDimensionRange(e,0,e.length)}static convertShape(e,n=4){let s=e.length;if(s===0)return[];let r=new Array(s),a=s-1;for(;a>=0;){if(e[a]%n===0){r[a]=e[a]/n;break}if(n%e[a]!==0)throw new Error("cannot convert shape");r[a]=1,n/=e[a],a--}for(a--;a>=0;a--)r[a]=e[a];return r}static sizeFromDimension(e,n){if(n<0||n>e.length)throw new Error(`invalid dimension of ${n} for sizeFromDimension as Tensor has ${e.length} dimensions.`);return Fc.getSizeFromDimensionRange(e,n,e.length)}static sizeToDimension(e,n){if(n<0||n>e.length)throw new Error(`invalid dimension of ${n} for sizeToDimension as Tensor has ${e.length} dimensions.`);return Fc.getSizeFromDimensionRange(e,0,n)}static getSizeFromDimensionRange(e,n,s){let r=1;for(let a=n;a<s;a++){if(e[a]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");r*=Number(e[a])}return r}static computeStrides(e){let n=e.length;if(n===0)return[];if(n===1)return[1];let s=new Array(n);s[n-1]=1,s[n-2]=e[n-1];for(let r=n-3;r>=0;--r)s[r]=s[r+1]*e[r+1];return s}static normalizeAxis(e,n){if(e<-n&&e>=n)throw new Error("unsupported axis for this operation.");return e<0?e+n:e}static normalizeAxes(e,n){return e.map(s=>this.normalizeAxis(s,n??e.length))}static sortBasedOnPerm(e,n){return n?n.map(s=>e[s]):e.slice().reverse()}static padShape(e,n){let s=e.length;return e.map((r,a)=>r+n[a]+n[a+s])}static areEqual(e,n){return e.length!==n.length?!1:e.every((s,r)=>s===n[r])}},md=class Zo{static adjustPoolAttributes(e,n,s,r,a,i){if(!e&&s.length!==n.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let o=0;o<n.length-2;o++)o>=s.length?s.push(n[o+2]):s[o]=n[o+2];for(let o=0;o<s.length;o++)if(o<r.length){if(r[o]<0)throw new Error("strides should be greater than or equal to 1")}else r.push(1);for(let o=0;o<s.length;o++)if(o<a.length){if(a[o]<0)throw new Error("dilations should be greater than or equal to 1")}else a.push(1);for(let o=0;o<s.length*2;o++)if(o<i.length){if(i[o]<0)throw new Error("pad should be greater than or equal to 1")}else i.push(0);for(let o=0;o<s.length;o++){if(s[o]<=0)throw new Error("kernel shapes need to be greater than 0");if(i[o]>=s[o]||i[o+s.length]>=s[o])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(e,n,s,r,a,i,o){if(o){if(a.length!==2*(e.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(n.length!==e.length-2)throw new Error("length of strides should be the length of data dimensions");if(r.length!==e.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let u=0;u<e.length-2;u++)Zo.adjustPadAndReturnShape(e[u+(i?1:2)],n[u],s[u],r[u],a,u,u+e.length-2,o)}}static computePoolOutputShape(e,n,s,r,a,i,o){if(n.length<=0)throw new Error("input shape must be of size greater than 0");let u=[n[0],n[1]];return Zo.computeShapeHelper(e,n,u,s,r,a,i,o),u}static computeConvOutputShape(e,n,s,r,a,i,o){if(e.length<=0||n.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let u=[e[0],n[0]];return Zo.computeShapeHelper(!1,e,u,s,r,a,i,o),u}static computeShapeHelper(e,n,s,r,a,i,o,u){if(e)for(let l=0;l<n.length-2;l++)s.push(1);else for(let l=0;l<n.length-2;l++)s.push(Zo.adjustPadAndReturnShape(n[l+2],r[l],a[l],i[l],o,l,l+n.length-2,u))}static adjustPadAndReturnShape(e,n,s,r,a,i,o,u){let l=s*(r-1)+1;if(u&&u!=="NOTSET")switch(u){case"VALID":return a[i]=0,a[o]=0,Math.floor((e-l)/n+1);case"SAME_LOWER":case"SAME_UPPER":if(s!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let c=((e+n-1)/n-1)*n+r-e;return a[i]=Math.floor(u==="SAME_LOWER"?(c+1)/2:c/2),a[o]=c-a[i],Math.floor((e+c-r)/n+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((e+a[i]+a[o]-l)/n+1)}},KA=class{static getShapeOfGemmResult(t,e,n,s,r){if(t.length!==2||n.length!==2)throw new Error("shape need to be of size 2");let a,i,o;e?(a=t[1],i=t[0]):(a=t[0],i=t[1]);let u=-1;if(s?(o=n[0],u=1):(o=n[1],u=0),n[u]!==i)throw new Error("dimension mismatch");if(a<=0||o<=0||i<=0)throw new Error("invalid shape specified");if(r&&!ro.isValidBroadcast(r,[a,o]))throw new Error("gemm: invalid bias shape for broadcast");return[a,o,i]}},XA=-34028234663852886e22,YA=34028234663852886e22}),z0,ZA=he(()=>{De(),z0=(t,e)=>new(pp(e))(t)}),yf,ng,bf,ev,xf,tv,wf,$f,vf,nv,QA,sle=he(()=>{De(),Br(),yf=new Map([["float32",32],["float16",16],["int32",32],["uint32",32],["int64",64],["uint64",64],["int8",8],["uint8",8],["int4",4],["uint4",4]]),ng=(t,e)=>{if(e==="int32")return t;let n=yf.get(e);if(!n)throw new Error(`WebNN backend does not support data type: ${e}`);let s=n/8;if(t.byteLength%s!==0)throw new Error(`Invalid Uint8Array length - must be a multiple of ${s}.`);let r=t.byteLength/s,a=new(pp(e))(t.buffer,t.byteOffset,r);switch(e){case"int64":case"uint64":{let i=new Int32Array(r);for(let o=0;o<r;o++){let u=a[o];if(u>2147483647n||u<-2147483648n)throw new Error("Can not convert int64 data to int32 - value out of range.");i[o]=Number(u)}return new Uint8Array(i.buffer)}case"int8":case"uint8":case"uint32":{if(e==="uint32"&&a.some(o=>o>2147483647))throw new Error("Can not convert uint32 data to int32 - value out of range.");let i=Int32Array.from(a,Number);return new Uint8Array(i.buffer)}default:throw new Error(`Unsupported data conversion from ${e} to 'int32'`)}},bf=(t,e)=>{if(e==="int32")return t;if(t.byteLength%4!==0)throw new Error("Invalid Uint8Array length - must be a multiple of 4 (int32).");let n=t.byteLength/4,s=new Int32Array(t.buffer,t.byteOffset,n);switch(e){case"int64":{let r=BigInt64Array.from(s,BigInt);return new Uint8Array(r.buffer)}case"uint64":{if(s.some(a=>a<0))throw new Error("Can not convert int32 data to uin64 - negative value found.");let r=BigUint64Array.from(s,BigInt);return new Uint8Array(r.buffer)}case"int8":{if(s.some(a=>a<-128||a>127))throw new Error("Can not convert int32 data to int8 - value out of range.");let r=Int8Array.from(s,Number);return new Uint8Array(r.buffer)}case"uint8":{if(s.some(r=>r<0||r>255))throw new Error("Can not convert int32 data to uint8 - value out of range.");return Uint8Array.from(s,Number)}case"uint32":{if(s.some(a=>a<0))throw new Error("Can not convert int32 data to uint32 - negative value found.");let r=Uint32Array.from(s,Number);return new Uint8Array(r.buffer)}default:throw new Error(`Unsupported data conversion from 'int32' to ${e}`)}},ev=1,xf=()=>ev++,tv=new Map([["int8","int32"],["uint8","int32"],["uint32","int32"],["int64","int32"]]),wf=(t,e)=>{let n=yf.get(t);if(!n)throw new Error(`WebNN backend does not support data type: ${t}`);return e.length>0?Math.ceil(e.reduce((s,r)=>s*r)*n/8):0},$f=class{constructor(t){this.isDataConverted=!1;let{sessionId:e,context:n,tensor:s,dataType:r,shape:a,fallbackDataType:i}=t;this.sessionId=e,this.mlContext=n,this.mlTensor=s,this.dataType=r,this.tensorShape=a,this.fallbackDataType=i}get tensor(){return this.mlTensor}get type(){return this.dataType}get fallbackType(){return this.fallbackDataType}get shape(){return this.tensorShape}get byteLength(){return wf(this.dataType,this.tensorShape)}destroy(){et("verbose",()=>"[WebNN] TensorWrapper.destroy"),this.mlTensor.destroy()}write(t){this.mlContext.writeTensor(this.mlTensor,t)}async read(t){if(this.fallbackDataType){let e=await this.mlContext.readTensor(this.mlTensor),n=bf(new Uint8Array(e),this.dataType);if(t){(t instanceof ArrayBuffer?new Uint8Array(t):new Uint8Array(t.buffer,t.byteOffset,t.byteLength)).set(n);return}else return n.buffer}else return t?this.mlContext.readTensor(this.mlTensor,t):this.mlContext.readTensor(this.mlTensor)}canReuseTensor(t,e,n){return this.mlContext===t&&this.dataType===e&&this.tensorShape.length===n.length&&this.tensorShape.every((s,r)=>s===n[r])}setIsDataConverted(t){this.isDataConverted=t}},vf=class{constructor(t,e){this.tensorManager=t,this.wrapper=e}get tensorWrapper(){return this.wrapper}releaseTensor(){this.tensorWrapper&&(this.tensorManager.releaseTensor(this.tensorWrapper),this.wrapper=void 0)}async ensureTensor(t,e,n,s){let r=this.tensorManager.getMLContext(t),a;if(!r.opSupportLimits().input.dataTypes.includes(e)){if(a=tv.get(e),!a||!r.opSupportLimits().input.dataTypes.includes(a))throw new Error(`WebNN backend does not support data type: ${e}`);et("verbose",()=>`[WebNN] TensorIdTracker.ensureTensor: fallback dataType from ${e} to ${a}`)}if(this.wrapper){if(this.wrapper.canReuseTensor(r,e,n))return this.wrapper.tensor;if(s){if(this.wrapper.byteLength!==wf(e,n))throw new Error("Unable to copy data to tensor with different size.");this.activeUpload=new Uint8Array(await this.wrapper.read())}this.tensorManager.releaseTensor(this.wrapper)}let i=typeof MLTensorUsage>"u"?void 0:MLTensorUsage.READ|MLTensorUsage.WRITE;return this.wrapper=await this.tensorManager.getCachedTensor(t,e,n,i,!0,!0,a),s&&this.activeUpload&&(this.wrapper.write(this.activeUpload),this.activeUpload=void 0),this.wrapper.tensor}upload(t){let e=t;if(this.wrapper){if(this.wrapper.fallbackType)if(this.wrapper.fallbackType==="int32")e=ng(t,this.wrapper.type),this.wrapper.setIsDataConverted(!0);else throw new Error(`Unsupported fallback data type: ${this.wrapper.fallbackType}`);if(t.byteLength===this.wrapper.byteLength){this.wrapper.write(e);return}else et("verbose",()=>"Data size does not match tensor size. Releasing tensor."),this.releaseTensor()}this.activeUpload?this.activeUpload.set(e):this.activeUpload=new Uint8Array(e)}async download(t){var e,n;if(this.activeUpload){let s=(e=this.wrapper)!=null&&e.isDataConverted?bf(this.activeUpload,(n=this.wrapper)==null?void 0:n.type):this.activeUpload;if(t){t instanceof ArrayBuffer?new Uint8Array(t).set(s):new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(s);return}else return s.buffer}if(!this.wrapper)throw new Error("Tensor has not been created.");return t?this.wrapper.read(t):this.wrapper.read()}},nv=class{constructor(t){this.backend=t,this.tensorTrackersById=new Map,this.freeTensors=[],this.externalTensors=new Set}getMLContext(t){let e=this.backend.getMLContext(t);if(!e)throw new Error("MLContext not found for session.");return e}reserveTensorId(){let t=xf();return this.tensorTrackersById.set(t,new vf(this)),t}releaseTensorId(t){let e=this.tensorTrackersById.get(t);e&&(this.tensorTrackersById.delete(t),e.tensorWrapper&&this.releaseTensor(e.tensorWrapper))}async ensureTensor(t,e,n,s,r){et("verbose",()=>`[WebNN] TensorManager.ensureTensor {tensorId: ${e}, dataType: ${n}, shape: ${s}, copyOld: ${r}}`);let a=this.tensorTrackersById.get(e);if(!a)throw new Error("Tensor not found.");return a.ensureTensor(t,n,s,r)}upload(t,e){let n=this.tensorTrackersById.get(t);if(!n)throw new Error("Tensor not found.");n.upload(e)}async download(t,e){et("verbose",()=>`[WebNN] TensorManager.download {tensorId: ${t}, dstBuffer: ${e==null?void 0:e.byteLength}}`);let n=this.tensorTrackersById.get(t);if(!n)throw new Error("Tensor not found.");return n.download(e)}releaseTensorsForSession(t){for(let e of this.freeTensors)e.sessionId===t&&e.destroy();this.freeTensors=this.freeTensors.filter(e=>e.sessionId!==t)}registerTensor(t,e,n,s){let r=this.getMLContext(t),a=xf(),i=new $f({sessionId:t,context:r,tensor:e,dataType:n,shape:s});return this.tensorTrackersById.set(a,new vf(this,i)),this.externalTensors.add(i),a}async getCachedTensor(t,e,n,s,r,a,i){let o=this.getMLContext(t);for(let[l,c]of this.freeTensors.entries())if(c.canReuseTensor(o,e,n)){et("verbose",()=>`[WebNN] Reusing tensor {dataType: ${e}, ${i?`fallbackDataType: ${i},`:""} shape: ${n}`);let d=this.freeTensors.splice(l,1)[0];return d.sessionId=t,d}et("verbose",()=>`[WebNN] MLContext.createTensor {dataType: ${e}, ${i?`fallbackDataType: ${i},`:""} shape: ${n}}`);let u=await o.createTensor({dataType:i??e,shape:n,dimensions:n,usage:s,writable:r,readable:a});return new $f({sessionId:t,context:o,tensor:u,dataType:e,shape:n,fallbackDataType:i})}releaseTensor(t){this.externalTensors.has(t)&&this.externalTensors.delete(t),this.freeTensors.push(t)}},QA=(...t)=>new nv(...t)}),zo,sv,JA,rle=he(()=>{De(),ki(),ZA(),sle(),Br(),zo=new Map([[1,"float32"],[10,"float16"],[6,"int32"],[12,"uint32"],[7,"int64"],[13,"uint64"],[22,"int4"],[21,"uint4"],[3,"int8"],[2,"uint8"],[9,"uint8"]]),sv=(t,e)=>{if(t===e)return!0;if(t===void 0||e===void 0)return!1;let n=Object.keys(t).sort(),s=Object.keys(e).sort();return n.length===s.length&&n.every((r,a)=>r===s[a]&&t[r]===e[r])},JA=class{constructor(t){this.tensorManager=QA(this),this.mlContextBySessionId=new Map,this.sessionIdsByMLContext=new Map,this.mlContextCache=[],this.sessionGraphInputs=new Map,this.sessionGraphOutputs=new Map,this.temporaryGraphInputs=[],this.temporaryGraphOutputs=[],this.temporarySessionTensorIds=new Map,F0(t.logLevel,!!t.debug)}get currentSessionId(){if(this.activeSessionId===void 0)throw new Error("No active session");return this.activeSessionId}onRunStart(t){et("verbose",()=>`[WebNN] onRunStart {sessionId: ${t}}`),this.activeSessionId=t}onRunEnd(t){et("verbose",()=>`[WebNN] onRunEnd {sessionId: ${t}}`);let e=this.temporarySessionTensorIds.get(t);if(e){for(let n of e)et("verbose",()=>`[WebNN] releasing temporary tensor {tensorId: ${n}}`),this.tensorManager.releaseTensorId(n);this.temporarySessionTensorIds.delete(t),this.activeSessionId=void 0}}async createMLContext(t){if(t instanceof GPUDevice){let n=this.mlContextCache.findIndex(s=>s.gpuDevice===t);if(n!==-1)return this.mlContextCache[n].mlContext;{let s=await navigator.ml.createContext(t);return this.mlContextCache.push({gpuDevice:t,mlContext:s}),s}}else if(t===void 0){let n=this.mlContextCache.findIndex(s=>s.options===void 0&&s.gpuDevice===void 0);if(n!==-1)return this.mlContextCache[n].mlContext;{let s=await navigator.ml.createContext();return this.mlContextCache.push({mlContext:s}),s}}let e=this.mlContextCache.findIndex(n=>sv(n.options,t));if(e!==-1)return this.mlContextCache[e].mlContext;{let n=await navigator.ml.createContext(t);return this.mlContextCache.push({options:t,mlContext:n}),n}}registerMLContext(t,e){this.mlContextBySessionId.set(t,e);let n=this.sessionIdsByMLContext.get(e);n||(n=new Set,this.sessionIdsByMLContext.set(e,n)),n.add(t),this.temporaryGraphInputs.length>0&&(this.sessionGraphInputs.set(t,this.temporaryGraphInputs),this.temporaryGraphInputs=[]),this.temporaryGraphOutputs.length>0&&(this.sessionGraphOutputs.set(t,this.temporaryGraphOutputs),this.temporaryGraphOutputs=[])}onReleaseSession(t){this.sessionGraphInputs.delete(t),this.sessionGraphOutputs.delete(t);let e=this.mlContextBySessionId.get(t);if(!e)return;this.tensorManager.releaseTensorsForSession(t),this.mlContextBySessionId.delete(t);let n=this.sessionIdsByMLContext.get(e);if(n.delete(t),n.size===0){this.sessionIdsByMLContext.delete(e);let s=this.mlContextCache.findIndex(r=>r.mlContext===e);s!==-1&&this.mlContextCache.splice(s,1)}}getMLContext(t){return this.mlContextBySessionId.get(t)}reserveTensorId(){return this.tensorManager.reserveTensorId()}releaseTensorId(t){et("verbose",()=>`[WebNN] releaseTensorId {tensorId: ${t}}`),this.tensorManager.releaseTensorId(t)}async ensureTensor(t,e,n,s,r){let a=zo.get(n);if(!a)throw new Error(`Unsupported ONNX data type: ${n}`);return this.tensorManager.ensureTensor(t??this.currentSessionId,e,a,s,r)}async createTemporaryTensor(t,e,n){et("verbose",()=>`[WebNN] createTemporaryTensor {onnxDataType: ${e}, shape: ${n}}`);let s=zo.get(e);if(!s)throw new Error(`Unsupported ONNX data type: ${e}`);let r=this.tensorManager.reserveTensorId();await this.tensorManager.ensureTensor(t,r,s,n,!1);let a=this.temporarySessionTensorIds.get(t);return a?a.push(r):this.temporarySessionTensorIds.set(t,[r]),r}uploadTensor(t,e){if(!bt().shouldTransferToMLTensor)throw new Error("Trying to upload to a MLTensor while shouldTransferToMLTensor is false");et("verbose",()=>`[WebNN] uploadTensor {tensorId: ${t}, data: ${e.byteLength}}`),this.tensorManager.upload(t,e)}async downloadTensor(t,e){return this.tensorManager.download(t,e)}createMLTensorDownloader(t,e){return async()=>{let n=await this.tensorManager.download(t);return z0(n,e)}}registerMLTensor(t,e,n,s){let r=zo.get(n);if(!r)throw new Error(`Unsupported ONNX data type: ${n}`);let a=this.tensorManager.registerTensor(t,e,r,s);return et("verbose",()=>`[WebNN] registerMLTensor {tensor: ${e}, dataType: ${r}, dimensions: ${s}} -> {tensorId: ${a}}`),a}registerMLConstant(t,e,n,s,r,a,i=!1){if(!a)throw new Error("External mounted files are not available.");let o=t;t.startsWith("./")&&(o=t.substring(2));let u=a.get(o);if(!u)throw new Error(`File with name ${o} not found in preloaded files.`);if(e+n>u.byteLength)throw new Error("Out of bounds: data offset and length exceed the external file data size.");let l=u.slice(e,e+n).buffer,c;switch(r.dataType){case"float32":c=new Float32Array(l);break;case"float16":c=typeof Float16Array<"u"&&Float16Array.from?new Float16Array(l):new Uint16Array(l);break;case"int32":c=new Int32Array(l);break;case"uint32":c=new Uint32Array(l);break;case"int64":if(i){let d=ng(new Uint8Array(l),"int64");c=new Int32Array(d.buffer),r.dataType="int32"}else c=new BigInt64Array(l);break;case"uint64":c=new BigUint64Array(l);break;case"int8":c=new Int8Array(l);break;case"int4":case"uint4":case"uint8":c=new Uint8Array(l);break;default:throw new Error(`Unsupported data type: ${r.dataType} in creating WebNN Constant from external data.`)}return et("verbose",()=>`[WebNN] registerMLConstant {dataType: ${r.dataType}, shape: ${r.shape}}} ${i?"(Note: it was int64 data type and registered to int32 as workaround)":""}`),s.constant(r,c)}registerGraphInput(t){this.temporaryGraphInputs.push(t)}registerGraphOutput(t){this.temporaryGraphOutputs.push(t)}isGraphInput(t,e){let n=this.sessionGraphInputs.get(t);return n?n.includes(e):!1}isGraphOutput(t,e){let n=this.sessionGraphOutputs.get(t);return n?n.includes(e):!1}isGraphInputOutputTypeSupported(t,e,n=!0){let s=this.mlContextBySessionId.get(t),r=zo.get(Ua(e));return typeof r>"u"?!1:n?!!(s!=null&&s.opSupportLimits().input.dataTypes.includes(r)):!!(s!=null&&s.opSupportLimits().output.dataTypes.includes(r))}flush(){}}}),L0=he(()=>{}),Sf,fc,mc,rv,av,If,sg,iv,eR,ale=he(()=>{Br(),L0(),Sf=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),fc=[],mc=t=>Math.ceil(Number(t)/16)*16,rv=t=>{for(let e=0;e<fc.length;e++){let n=fc[e];if(t<=n)return n}return Math.ceil(t/16)*16},av=1,If=()=>av++,sg=async(t,e,n,s)=>{let r=mc(n),a=t.device.createBuffer({size:r,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let i=t.getCommandEncoder();t.endComputePass(),i.copyBufferToBuffer(e,0,a,0,r),t.flush(),await a.mapAsync(GPUMapMode.READ);let o=a.getMappedRange();if(s){let u=s();return u.set(new Uint8Array(o,0,n)),u}else return new Uint8Array(o.slice(0,n))}finally{a.destroy()}},iv=class{constructor(t){this.backend=t,this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersPending=[],this.capturedPendingBuffers=new Map;for(let[e]of Sf)fc.push(e),this.freeBuffers.set(e,[]),this.freeUniformBuffers.set(e,[]);this.sessionCount=0}upload(t,e){let n=e.buffer,s=e.byteOffset,r=e.byteLength,a=mc(r),i=this.storageCache.get(t);if(!i)throw new Error("gpu data for uploading does not exist");if(Number(i.originalSize)!==r)throw new Error(`inconsistent data size. gpu data size=${i.originalSize}, data size=${r}`);let o=this.backend.device.createBuffer({mappedAtCreation:!0,size:a,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),u=o.getMappedRange();new Uint8Array(u).set(new Uint8Array(n,s,r)),o.unmap();let l=this.backend.device.createCommandEncoder();l.copyBufferToBuffer(o,0,i.gpuData.buffer,0,a),this.backend.device.queue.submit([l.finish()]),o.destroy(),et("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${t})`)}memcpy(t,e){let n=this.storageCache.get(t);if(!n)throw new Error("source gpu data for memcpy does not exist");let s=this.storageCache.get(e);if(!s)throw new Error("destination gpu data for memcpy does not exist");if(n.originalSize!==s.originalSize)throw new Error("inconsistent source and destination gpu data size");let r=mc(n.originalSize),a=this.backend.getCommandEncoder();this.backend.endComputePass(),a.copyBufferToBuffer(n.gpuData.buffer,0,s.gpuData.buffer,0,r)}registerExternalBuffer(t,e,n){let s;if(n){if(s=n[0],t===n[1])return et("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${e}) => id=${s}, buffer is the same, skip.`),s;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.
             Please use the previous external buffer!`)}else s=If();return this.storageCache.set(s,{gpuData:{id:s,type:0,buffer:t},originalSize:e}),et("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${e}) => id=${s}, registered.`),s}unregisterExternalBuffer(t){t!==void 0&&(this.storageCache.delete(t),et("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${t}`))}create(t,e=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let n=rv(t),s,r=(e&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,a=(e&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(r||a){let o=(r?this.freeBuffers:this.freeUniformBuffers).get(n);o?o.length>0?s=o.pop():s=this.backend.device.createBuffer({size:n,usage:e}):s=this.backend.device.createBuffer({size:n,usage:e})}else s=this.backend.device.createBuffer({size:n,usage:e});let i={id:If(),type:0,buffer:s};return this.storageCache.set(i.id,{gpuData:i,originalSize:Number(t)}),et("verbose",()=>`[WebGPU] GpuDataManager.create(size=${t}) => id=${i.id}`),i}get(t){var e;return(e=this.storageCache.get(t))==null?void 0:e.gpuData}release(t){let e=typeof t=="bigint"?Number(t):t,n=this.storageCache.get(e);if(!n){if(this.storageCache.size===0)return 0;throw new Error("releasing data does not exist")}return et("verbose",()=>`[WebGPU] GpuDataManager.release(id=${e}), gpuDataId=${n.gpuData.id}`),this.storageCache.delete(e),this.buffersPending.push(n.gpuData.buffer),n.originalSize}async download(t,e){let n=this.storageCache.get(Number(t));if(!n)throw new Error("data does not exist");await sg(this.backend,n.gpuData.buffer,n.originalSize,e)}refreshPendingBuffers(){if(this.buffersPending.length!==0)if(this.backend.sessionStatus==="default"){for(let t of this.buffersPending){let e=Sf.get(t.size);if((t.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let n=this.freeBuffers.get(t.size)||[];e===void 0||n.length>=e?t.destroy():n.push(t)}else if((t.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let n=this.freeUniformBuffers.get(t.size)||[];e===void 0||n.length>=e?t.destroy():n.push(t)}else t.destroy()}this.buffersPending=[]}else{let t=this.capturedPendingBuffers.get(this.backend.currentSessionId);t||(t=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,t));for(let e of this.buffersPending)t.push(e);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach(t=>{t.forEach(e=>{e.destroy()})}),this.freeUniformBuffers.forEach(t=>{t.forEach(e=>{e.destroy()})}),this.storageCache.forEach(t=>{t.gpuData.buffer.destroy()}),this.capturedPendingBuffers.forEach(t=>{t.forEach(e=>{e.destroy()})}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onCreateSession(){this.sessionCount+=1}onReleaseSession(t){let e=this.capturedPendingBuffers.get(t);e&&(e.forEach(n=>{n.destroy()}),this.capturedPendingBuffers.delete(t)),this.sessionCount-=1,this.sessionCount===0&&(et("warning",()=>"[WebGPU] Clearing webgpu buffer cache"),this.storageCache.forEach(n=>{n.gpuData.buffer.destroy()}),this.storageCache=new Map)}},eR=(...t)=>new iv(...t)}),ov,lt,Ot=he(()=>{ov=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(t=>`${this[t]}`).join(";")),this.key}},lt=t=>new ov(t)}),ao,gc,sn,vn,Ce,Nt,rg,Pi,pa,Se,Lo,ue,ve,tR,P0,uv,nR,Me=he(()=>{De(),Be(),ao=64,gc=(t,e)=>{if(e===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(Number(t)){case 10:return e>1?`vec${e}<f16>`:"f16";case 1:return e>1?`vec${e}<f32>`:"f32";case 6:return e>1?`vec${e}<i32>`:"i32";case 12:return e>1?`vec${e}<u32>`:"u32";case 7:if(e>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(e>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(e!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];case 22:return"i32";case 21:return"u32";default:throw new Error(`Unknown data type: ${t}`)}},sn=(t,e=1)=>{let n=gc(t,e);return typeof n=="string"?n:n[0]},vn=(t,e=1)=>{let n=gc(t,e);return typeof n=="string"?n:n[1]},Ce=(...t)=>{let e=[];return t.forEach(n=>{n.length!==0&&e.push({type:12,data:n},{type:12,data:re.computeStrides(n)})}),e},Nt=t=>t%4===0?4:t%2===0?2:1,rg=(t="f32",e,n="0")=>!e||e===1?`${t}(${n})`:`vec${e}<${t}>(${n})`,Pi=(t,e,n)=>t==="f32"?n:e===1?`f32(${n})`:`vec${e}<f32>(${n})`,pa=(t,e)=>e===4?`(${t}.x + ${t}.y + ${t}.z + ${t}.w)`:e===2?`(${t}.x + ${t}.y)`:e===3?`(${t}.x + ${t}.y + ${t}.z)`:t,Se=(t,e,n,s)=>t.startsWith("uniforms.")&&n>4?typeof e=="string"?s==="f16"?`${t}[(${e}) / 8][(${e}) % 8 / 4][(${e}) % 8 % 4]`:`${t}[(${e}) / 4][(${e}) % 4]`:s==="f16"?`${t}[${Math.floor(e/8)}][${Math.floor(e%8/4)}][${e%8%4}]`:`${t}[${Math.floor(e/4)}][${e%4}]`:n>1?`${t}[${e}]`:t,Lo=(t,e,n,s,r)=>{let a=typeof n=="number",i=a?n:n.length,o=[...new Array(i).keys()],u=i<2?"u32":i<=4?`vec${i}<u32>`:`array<u32, ${i}>`,l=gc(e,r),c=typeof l=="string"?l:l[1],d=typeof l=="string"?l:l[0],h={indices:u,value:c,storage:d,tensor:e},p=M=>typeof M=="string"?M:`${M}u`,f={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},m=a?"uniforms.":"",g=`${m}${t}_shape`,y=`${m}${t}_strides`,b="";for(let M=0;M<i-1;M++)b+=`
    let dim${M} = current / ${Se(y,M,i)};
    let rest${M} = current % ${Se(y,M,i)};
    indices[${M}] = dim${M};
    current = rest${M};
    `;b+=`indices[${i-1}] = current;`;let $=i<2?"":`
  fn o2i_${t}(offset: u32) -> ${h.indices} {
    var indices: ${h.indices};
    var current = offset;
    ${b}
    return indices;
  }`,w=M=>(f.offsetToIndices=!0,i<2?M:`o2i_${t}(${M})`),v=[];if(i>=2)for(let M=i-1;M>=0;M--)v.push(`${Se(y,M,i)} * (indices[${M}])`);let k=i<2?"":`
  fn i2o_${t}(indices: ${h.indices}) -> u32 {
    return ${v.join("+")};
  }`,C=M=>(f.indicesToOffset=!0,i<2?M:`i2o_${t}(${M})`),N=(...M)=>i===0?"0u":`${h.indices}(${M.map(p).join(",")})`,A=(M,Z)=>i<2?`${M}`:`${Se(M,Z,i)}`,I=(M,Z,J)=>i<2?`${M}=${J};`:`${Se(M,Z,i)}=${J};`,E={},z=(M,Z)=>{f.broadcastedIndicesToOffset=!0;let J=`${Z.name}broadcastedIndicesTo${t}Offset`;if(J in E)return`${J}(${M})`;let oe=[];for(let de=i-1;de>=0;de--){let fe=Z.indicesGet("outputIndices",de+Z.rank-i);oe.push(`${A(y,de)} * (${fe} % ${A(g,de)})`)}return E[J]=`fn ${J}(outputIndices: ${Z.type.indices}) -> u32 {
             return ${oe.length>0?oe.join("+"):"0u"};
           }`,`${J}(${M})`},P=(M,Z)=>(()=>{if(h.storage===h.value)return`${t}[${M}]=${Z};`;if(h.storage==="vec2<u32>"&&h.value==="i32")return`${t}[${M}]=vec2<u32>(u32(${Z}), select(0u, 0xFFFFFFFFu, ${Z} < 0));`;if(h.storage==="vec2<u32>"&&h.value==="u32")return`${t}[${M}]=vec2<u32>(u32(${Z}), 0u);`;if(h.storage==="u32"&&h.value==="vec4<bool>")return`${t}[${M}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${Z}));`;throw new Error(`not supported combination of storage type ${h.storage} and value type ${h.value} yet`)})(),H=M=>(()=>{if(h.storage===h.value)return`${t}[${M}]`;if(h.storage==="vec2<u32>"&&h.value==="i32")return`i32(${t}[${M}].x)`;if(h.storage==="vec2<u32>"&&h.value==="u32")return`u32(${t}[${M}].x)`;if(h.storage==="u32"&&h.value==="vec4<bool>")return`vec4<bool>(bool(${t}[${M}] & 0xFFu), bool(${t}[${M}] & 0xFF00u), bool(${t}[${M}] & 0xFF0000u), bool(${t}[${M}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${h.storage} and value type ${h.value} yet`)})(),G=i<2?"":`
  fn get_${t}ByIndices(indices: ${h.indices}) -> ${c} {
    return ${H(`i2o_${t}(indices)`)};
  }`,W=i<2?"":(()=>{let M=o.map(J=>`d${J}: u32`).join(", "),Z=o.map(J=>`d${J}`).join(", ");return`
  fn get_${t}(${M}) -> ${c} {
    return get_${t}ByIndices(${N(Z)});
  }`})(),L=(...M)=>{if(M.length!==i)throw new Error(`indices length must be ${i}`);let Z=M.map(p).join(",");return i===0?H("0u"):i===1?H(Z[0]):(f.get=!0,f.getByIndices=!0,f.indicesToOffset=!0,`get_${t}(${Z})`)},B=M=>i<2?H(M):(f.getByIndices=!0,f.indicesToOffset=!0,`get_${t}ByIndices(${M})`),Y=i<2?"":`
  fn set_${t}ByIndices(indices: ${h.indices}, value: ${c}) {
    ${P(`i2o_${t}(indices)`,"value")}
  }`,ne=i<2?"":(()=>{let M=o.map(J=>`d${J}: u32`).join(", "),Z=o.map(J=>`d${J}`).join(", ");return`
  fn set_${t}(${M}, value: ${c}) {
    set_${t}ByIndices(${N(Z)}, value);
  }`})();return{impl:()=>{let M=[],Z=!1;return f.offsetToIndices&&(M.push($),Z=!0),f.indicesToOffset&&(M.push(k),Z=!0),f.broadcastedIndicesToOffset&&(Object.values(E).forEach(J=>M.push(J)),Z=!0),f.set&&(M.push(ne),Z=!0),f.setByIndices&&(M.push(Y),Z=!0),f.get&&(M.push(W),Z=!0),f.getByIndices&&(M.push(G),Z=!0),!a&&Z&&M.unshift(`const ${g} = ${h.indices}(${n.join(",")});`,`const ${y} = ${h.indices}(${re.computeStrides(n).join(",")});`),M.join(`
`)},type:h,offsetToIndices:w,indicesToOffset:C,broadcastedIndicesToOffset:z,indices:N,indicesGet:A,indicesSet:I,set:(...M)=>{if(M.length!==i+1)throw new Error(`indices length must be ${i}`);let Z=M[i];if(typeof Z!="string")throw new Error("value must be string");let J=M.slice(0,i).map(p).join(",");return i===0?P("0u",Z):i===1?P(J[0],Z):(f.set=!0,f.setByIndices=!0,f.indicesToOffset=!0,`set_${t}(${J}, ${Z})`)},setByOffset:P,setByIndices:(M,Z)=>i<2?P(M,Z):(f.setByIndices=!0,f.indicesToOffset=!0,`set_${t}ByIndices(${M}, ${Z});`),get:L,getByOffset:H,getByIndices:B,usage:s,name:t,strides:y,shape:g,rank:i}},ue=(t,e,n,s=1)=>Lo(t,e,n,"input",s),ve=(t,e,n,s=1)=>Lo(t,e,n,"output",s),tR=(t,e,n)=>Lo(t,e,n,"atomicOutput",1),P0=(t,e,n,s=1)=>Lo(t,e,n,"internal",s),uv=class{constructor(t,e){this.normalizedDispatchGroup=t,this.limits=e,this.internalVariables=[],this.variables=[],this.uniforms=[],this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(t){return`if (global_idx >= ${typeof t=="number"?`${t}u`:t}) { return; }`}mainStart(t=ao){let e=typeof t=="number"?t:t[0],n=typeof t=="number"?1:t[1],s=typeof t=="number"?1:t[2];if(e>this.limits.maxComputeWorkgroupSizeX||n>this.limits.maxComputeWorkgroupSizeY||s>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${e}, ${n}, ${s}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(e*n*s>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${e}, ${n}, ${s}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let r=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,a=r?`@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(global_invocation_id) global_id : vec3<u32>,
                                             @builtin(local_invocation_id) local_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`,i=r?`let global_idx = global_id.x;
         let workgroup_index = workgroup_id.x;`:`let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
             workgroup_id.y * num_workgroups[0] + workgroup_id.x;
         let global_idx = workgroup_index * ${e*n*s}u + local_idx;`;return`@compute @workgroup_size(${e}, ${n}, ${s})
  fn main(${a}) {
    ${i}
  `}appendVariableUniforms(t){t.rank!==0&&(t.shape.startsWith("uniforms.")&&this.uniforms.push({name:t.shape.replace("uniforms.",""),type:"u32",length:t.rank}),t.strides.startsWith("uniforms.")&&this.uniforms.push({name:t.strides.replace("uniforms.",""),type:"u32",length:t.rank}))}declareVariable(t,e){if(t.usage==="internal")throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(t),this.appendVariableUniforms(t);let n=t.usage==="input"?"read":"read_write",s=t.usage==="atomicOutput"?"atomic<i32>":t.type.storage;return`@group(0) @binding(${e}) var<storage, ${n}> ${t.name}: array<${s}>;`}declareVariables(...t){return t.map(e=>this.declareVariable(e,this.variableIndex++)).join(`
`)}registerInternalVariable(t){if(t.usage!=="internal")throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(t),this.appendVariableUniforms(t)}registerInternalVariables(...t){return t.forEach(e=>this.registerInternalVariable(e)),this}registerUniform(t,e,n=1){return this.uniforms.push({name:t,type:e,length:n}),this}registerUniforms(t){return this.uniforms=this.uniforms.concat(t),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let t=[];for(let{name:e,type:n,length:s}of this.uniforms)if(s&&s>4)n==="f16"?t.push(`@align(16) ${e}:array<mat2x4<${n}>, ${Math.ceil(s/8)}>`):t.push(`${e}:array<vec4<${n}>, ${Math.ceil(s/4)}>`);else{let r=s==null||s===1?n:`vec${s}<${n}>`;t.push(`${e}:${r}`)}return`
      struct Uniforms { ${t.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(t=>t.impl()).join(`
`)+this.internalVariables.map(t=>t.impl()).join(`
`)}get variablesInfo(){if(this.uniforms.length===0)return;let t=e=>[12,10,1,6][["u32","f16","f32","i32"].indexOf(e)];return this.uniforms.map(e=>[t(e.type),e.length??1])}},nR=(t,e)=>new uv(t,e)}),lv,_f,cv,dv,hv,pv,ss,sR,rR,ka=he(()=>{De(),Be(),Ot(),Me(),lv=(t,e)=>{if(!t||t.length!==1)throw new Error("Transpose requires 1 input.");if(e.length!==0&&e.length!==t[0].dims.length)throw new Error(`perm size ${e.length} does not match input rank ${t[0].dims.length}`)},_f=(t,e)=>e.length!==0?e:[...new Array(t).keys()].reverse(),cv=(t,e)=>re.sortBasedOnPerm(t,_f(t.length,e)),dv=(t,e,n,s)=>{let r=`fn perm(i: ${s.type.indices}) -> ${n.type.indices} {
    var a: ${n.type.indices};`;for(let a=0;a<e;++a)r+=`a[${t[a]}]=i[${a}];`;return r+="return a;}"},hv=(t,e)=>{let n=[],s=[];for(let r=0;r<t.length;++r)t[r]!==1&&n.push(t[r]),t[e[r]]!==1&&s.push(e[r]);return{newShape:n,newPerm:s}},pv=(t,e)=>{let n=0;for(let s=0;s<t.length;++s)if(e[t[s]]!==1){if(t[s]<n)return!1;n=t[s]}return!0},ss=(t,e)=>{let n=t.dataType,s=t.dims.length,r=_f(s,e),a=cv(t.dims,r),i=t.dims,o=a,u=s<2||pv(r,t.dims),l;if(u)return l=f=>{let m=ue("input",n,i,4),g=ve("output",n,o,4);return`
  ${f.registerUniform("output_size","u32").declareVariables(m,g)}
  ${f.mainStart()}
    ${f.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    output[global_idx] = input[global_idx];
  }`},{name:"TransposeCopy",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let f=re.size(a);return{outputs:[{dims:a,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(f/64/4)},programUniforms:[{type:12,data:Math.ceil(f/4)}]}},getShaderSource:l};let{newShape:c,newPerm:d}=hv(t.dims,r),h=re.areEqual(d,[2,3,1]),p=re.areEqual(d,[3,1,2]);if(c.length===2||h||p){i=h?[c[0],c[1]*c[2]]:p?[c[0]*c[1],c[2]]:c,o=[i[1],i[0]];let f=16;return l=m=>{let g=ue("a",n,i.length),y=ve("output",n,o.length);return`
  ${m.registerUniform("output_size","u32").declareVariables(g,y)}
  var<workgroup> tile : array<array<${y.type.value}, ${f+1}>, ${f}>;
  ${m.mainStart([f,f,1])}
    let stride = (uniforms.output_shape[1] - 1) / ${f} + 1;
    let workgroup_id_x = workgroup_index % stride;
    let workgroup_id_y = workgroup_index / stride;
    let input_col = workgroup_id_y * ${f}u + local_id.x;
    let input_row = workgroup_id_x * ${f}u + local_id.y;
    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {
      tile[local_id.y][local_id.x] = ${g.getByIndices(`${g.type.indices}(input_row, input_col)`)};
    }
    workgroupBarrier();

    let output_col = workgroup_id_x * ${f}u + local_id.x;
    let output_row = workgroup_id_y * ${f}u + local_id.y;
    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {
      ${y.setByIndices(`${y.type.indices}(output_row, output_col)`,"tile[local_id.x][local_id.y]")}
    }
  }`},{name:"TransposeShared",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let m=re.size(a);return{outputs:[{dims:a,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(o[1]/f),y:Math.ceil(o[0]/f)},programUniforms:[{type:12,data:m},...Ce(i,o)]}},getShaderSource:l}}return l=f=>{let m=ue("a",n,i.length),g=ve("output",n,o.length);return`
  ${f.registerUniform("output_size","u32").declareVariables(m,g)}

  ${dv(r,s,m,g)}

  ${f.mainStart()}
    ${f.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${g.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${g.setByOffset("global_idx",m.getByIndices("aIndices"))}
  }`},{name:"Transpose",shaderCache:{hint:`${e}`,inputDependencies:["rank"]},getRunData:()=>{let f=re.size(a);return{outputs:[{dims:a,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:[{type:12,data:f},...Ce(i,o)]}},getShaderSource:l}},sR=(t,e)=>{lv(t.inputs,e.perm),t.compute(ss(t.inputs[0],e.perm))},rR=t=>lt({perm:t.perm})}),fv,mv,gv,yv,bv,xv,wv,$v,vv,Sv,Fs,aR,iR,oR,uR,lR,cR,dR,hR,pR,fR,ile=he(()=>{De(),Be(),Me(),B0(),ka(),fv={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},mv={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},gv={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},yv={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},bv=(t,e)=>{let n=[];for(let s=e-t;s<e;++s)n.push(s);return n},xv=(t,e)=>{let n=[],s=t.length;for(let a=0;a<s;a++)e.indexOf(a)===-1&&n.push(t[a]);let r=e.map(a=>t[a]);return[n,r]},wv=(t,e)=>{let n=t.length+e.length,s=[],r=0;for(let a=0;a<n;a++)e.indexOf(a)===-1?s.push(t[r++]):s.push(1);return s},$v=(t,e)=>{for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0},vv=(t,e)=>{let n=[];if(!$v(t,e)){for(let s=0;s<e;++s)t.indexOf(s)===-1&&n.push(s);t.forEach(s=>n.push(s))}return n},Sv=(t,e,n,s,r,a,i)=>{let o=n[0].dims,u=re.size(a),l=re.size(i),c=ue("_A",n[0].dataType,o),d=ve("output",r,a),h=64;u===1&&(h=256);let p=`
          var<workgroup> aBestValues : array<f32, ${h}>;
       `,f=m=>`
        ${m.registerUniform("reduceSize","u32").declareVariables(c,d)}
        ${p}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${m.mainStart(h)}

          let outputIndex = global_idx / ${h};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = f32(${gv[s]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${h}) {
           let candidate = f32(${c.getByOffset("offset + k")});
           bestValue = ${fv[s]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${h}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${mv[s]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${d.setByOffset("outputIndex",`${s==="mean"?`${d.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${d.type.storage}(${yv[s]})`}`)};
         }
        }`;return{name:t,shaderCache:{hint:`${e};${h}`,inputDependencies:["type"]},getShaderSource:f,getRunData:()=>({outputs:[{dims:a,dataType:r}],dispatchGroup:{x:u},programUniforms:[{type:12,data:l}]})}},Fs=(t,e,n,s)=>{let r=t.inputs.length===1?n:ag(t.inputs,n),a=r.axes;a.length===0&&!r.noopWithEmptyAxes&&(a=t.inputs[0].dims.map((p,f)=>f));let i=re.normalizeAxes(a,t.inputs[0].dims.length),o=i,u=t.inputs[0],l=vv(o,t.inputs[0].dims.length);l.length>0&&(u=t.compute(ss(t.inputs[0],l),{inputs:[0],outputs:[-1]})[0],o=bv(o.length,u.dims.length));let[c,d]=xv(u.dims,o),h=c;r.keepDims&&(h=wv(c,i)),t.compute(Sv(e,r.cacheKey,[u],s,t.inputs[0].dataType,h,d),{inputs:[u]})},aR=(t,e)=>{Fs(t,"ReduceMeanShared",e,"mean")},iR=(t,e)=>{Fs(t,"ReduceL1Shared",e,"l1")},oR=(t,e)=>{Fs(t,"ReduceL2Shared",e,"l2")},uR=(t,e)=>{Fs(t,"ReduceLogSumExpShared",e,"logSumExp")},lR=(t,e)=>{Fs(t,"ReduceMaxShared",e,"max")},cR=(t,e)=>{Fs(t,"ReduceMinShared",e,"min")},dR=(t,e)=>{Fs(t,"ReduceProdShared",e,"prod")},hR=(t,e)=>{Fs(t,"ReduceSumShared",e,"sum")},pR=(t,e)=>{Fs(t,"ReduceSumSquareShared",e,"sumSquare")},fR=(t,e)=>{Fs(t,"ReduceLogSumShared",e,"logSum")}}),zs,Iv,gd,ag,Ls,_v,kv,Cv,Tv,Nv,Ev,Av,Rv,Dv,Ov,Ps,mR,gR,yR,bR,xR,wR,$R,vR,SR,IR,B0=he(()=>{De(),Be(),Ot(),Me(),ile(),zs=t=>{if(!t||t.length===0||t.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(t.length===2&&t[1].dims.length!==1)throw new Error("Invalid axes input dims.")},Iv=t=>["","",`var value = ${t.getByIndices("input_indices")};`,""],gd=(t,e,n,s,r,a,i=!1,o=!1)=>{let u=[],l=n[0].dims,c=l.length,d=re.normalizeAxes(r,c),h=!o&&d.length===0;l.forEach((m,g)=>{h||d.indexOf(g)>=0?i&&u.push(1):u.push(m)});let p=u.length,f=re.size(u);return{name:t,shaderCache:e,getShaderSource:m=>{let g=[],y=ue("_A",n[0].dataType,c),b=ve("output",a,p),$=s(y,b,d),w=$[2];for(let v=0,k=0;v<c;v++)h||d.indexOf(v)>=0?(i&&k++,w=`for(var j${v}: u32 = 0; j${v} < ${l[v]}; j${v}++) {
                  ${$[2].includes("last_index")?`let last_index = j${v};`:""}
                  ${y.indicesSet("input_indices",v,`j${v}`)}
                  ${w}
                }`):(g.push(`${y.indicesSet("input_indices",v,b.indicesGet("output_indices",k))};`),k++);return`

        ${m.registerUniform("output_size","u32").declareVariables(y,b)}

        ${m.mainStart()}
          ${m.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var input_indices: ${y.type.indices};
          let output_indices = ${b.offsetToIndices("global_idx")};

          ${g.join(`
`)}
          ${$[0]}       // init ops for reduce max/min
          ${$[1]}
          ${w}
          ${$[3]}
          ${$.length===4?b.setByOffset("global_idx","value"):$.slice(4).join(`
`)}
        }`},getRunData:()=>({outputs:[{dims:u,dataType:a}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:[{type:12,data:f},...Ce(l,u)]})}},ag=(t,e)=>{let n=[];return t[1].dims[0]>0&&t[1].getBigInt64Array().forEach(s=>n.push(Number(s))),lt({axes:n,keepDims:e.keepDims,noopWithEmptyAxes:e.noopWithEmptyAxes})},Ls=(t,e,n,s)=>{let r=t.inputs,a=r.length===1?n:ag(r,n);t.compute(gd(e,{hint:a.cacheKey,inputDependencies:["rank"]},[r[0]],a.noopWithEmptyAxes&&a.axes.length===0?Iv:s,a.axes,r[0].dataType,a.keepDims,a.noopWithEmptyAxes),{inputs:[0]})},_v=(t,e)=>{zs(t.inputs),Ls(t,"ReduceLogSum",e,(n,s)=>[`var value = ${s.type.storage}(0);`,"",`value += ${n.getByIndices("input_indices")};`,"value = log(value);"])},kv=(t,e)=>{zs(t.inputs),Ls(t,"ReduceL1",e,(n,s)=>[`var value = ${s.type.storage}(0);`,"",`value += abs(${n.getByIndices("input_indices")});`,""])},Cv=(t,e)=>{zs(t.inputs),Ls(t,"ReduceL2",e,(n,s)=>[`var t = ${s.type.value}(0); var value = ${s.type.value}(0);`,"",`t = ${n.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"])},Tv=(t,e)=>{zs(t.inputs),Ls(t,"ReduceLogSumExp",e,(n,s)=>[`var value = ${s.type.storage}(0);`,"",`value += exp(${n.getByIndices("input_indices")});`,"value = log(value);"])},Nv=(t,e)=>{zs(t.inputs),Ls(t,"ReduceMax",e,(n,s,r)=>{let a=[];for(let i=0;i<n.rank;i++)(r.indexOf(i)>=0||r.length===0)&&a.push(n.indicesSet("input_indices",i,0));return[`${a.join(`
`)}`,`var value = ${n.getByIndices("input_indices")};`,`value = max(value, ${n.getByIndices("input_indices")});`,""]})},Ev=(t,e)=>{zs(t.inputs),Ls(t,"ReduceMean",e,(n,s,r)=>{let a=1;for(let i=0;i<n.rank;i++)(r.indexOf(i)>=0||r.length===0)&&(a*=t.inputs[0].dims[i]);return["var sum = f32(0);","",`sum += f32(${n.getByIndices("input_indices")});`,`let value = ${s.type.value}(sum / ${a});`]})},Av=(t,e)=>{zs(t.inputs),Ls(t,"ReduceMin",e,(n,s,r)=>{let a=[];for(let i=0;i<n.rank;i++)(r.indexOf(i)>=0||r.length===0)&&a.push(`input_indices[${i}] = 0;`);return[`${a.join(`
`)}`,`var value = ${n.getByIndices("input_indices")};`,`value = min(value, ${n.getByIndices("input_indices")});`,""]})},Rv=(t,e)=>{zs(t.inputs),Ls(t,"ReduceProd",e,(n,s)=>[`var value = ${s.type.storage}(1);`,"",`value *= ${n.getByIndices("input_indices")};`,""])},Dv=(t,e)=>{zs(t.inputs),Ls(t,"ReduceSum",e,(n,s)=>[`var value = ${s.type.storage}(0);`,"",`value += ${n.getByIndices("input_indices")};`,""])},Ov=(t,e)=>{zs(t.inputs),Ls(t,"ReduceSumSquare",e,(n,s)=>[`var t = ${s.type.value}(0); var value = ${s.type.value}(0);`,"",`t = ${n.getByIndices("input_indices")}; value += t * t;`,""])},Ps=(t,e,n)=>{if(e.length===0)return n;let s=1,r=1;for(let a=0;a<e.length;a++)e.indexOf(a)===-1?s*=t[a]:r*=t[a];return r<32&&s>1024},mR=(t,e)=>{Ps(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Ev(t,e):aR(t,e)},gR=(t,e)=>{Ps(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?kv(t,e):iR(t,e)},yR=(t,e)=>{Ps(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Cv(t,e):oR(t,e)},bR=(t,e)=>{Ps(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Tv(t,e):uR(t,e)},xR=(t,e)=>{Ps(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Nv(t,e):lR(t,e)},wR=(t,e)=>{Ps(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Av(t,e):cR(t,e)},$R=(t,e)=>{Ps(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Rv(t,e):dR(t,e)},vR=(t,e)=>{Ps(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Dv(t,e):hR(t,e)},SR=(t,e)=>{Ps(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Ov(t,e):pR(t,e)},IR=(t,e)=>{Ps(t.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?_v(t,e):fR(t,e)}}),kf,_R,kR,ig,ole=he(()=>{De(),Ot(),B0(),kf=t=>{if(!t||t.length===0||t.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(t[0].dataType!==1)throw new Error("Invalid input type.")},_R=(t,e)=>{kf(t.inputs);let n=(s,r,a)=>{let i=[];for(let o=0;o<s.rank;o++)(a.indexOf(o)>=0||a.length===0)&&i.push(`input_indices[${o}] = 0;`);return[`${i.join(`
`)}`,`var value = ${s.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${s.getByIndices("input_indices")} ${e.selectLastIndex>0?"<=":"<"} value) {
         value = ${s.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",r.setByOffset("global_idx","best_index")]};t.compute(gd("ArgMin",{hint:e.cacheKey,inputDependencies:["rank"]},[t.inputs[0]],n,[e.axis],7,e.keepDims),{inputs:[0]})},kR=(t,e)=>{kf(t.inputs);let n=(s,r,a)=>{let i=[];for(let o=0;o<s.rank;o++)(a.indexOf(o)>=0||a.length===0)&&i.push(`input_indices[${o}] = 0;`);return[`${i.join(`
`)}`,`var value = ${s.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${s.getByIndices("input_indices")} ${e.selectLastIndex>0?">=":">"} value) {
         value = ${s.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",r.setByOffset("global_idx","best_index")]};t.compute(gd("argMax",{hint:e.cacheKey,inputDependencies:["rank"]},[t.inputs[0]],n,[e.axis],7,e.keepDims),{inputs:[0]})},ig=t=>lt(t)}),Fv,yc,zv,Lv,Pv,xu,Bv,CR,M0=he(()=>{De(),Be(),L0(),Me(),Fv=(t,e)=>{let n=t[0],s=t[1],r=t[2],a=t[3],i=t[4],o=t[5];if(i&&o)throw new Error("Attention cannot have both past and attention_bias");if(n.dims.length!==3)throw new Error('Input "input" must have 3 dimensions');let u=n.dims[0],l=n.dims[1],c=n.dims[2];if(r.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimensions');if(s.dims.length!==2)throw new Error('Input "weights" is expected to have 2 dimensions');if(s.dims[0]!==c)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(r.dims[0]!==s.dims[1])throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');let d=r.dims[0]/3,h=d,p=h;if(e.qkvHiddenSizes.length>0){if(e.qkvHiddenSizes.length!==3)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let $ of e.qkvHiddenSizes)if($%e.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");d=e.qkvHiddenSizes[0],h=e.qkvHiddenSizes[1],p=e.qkvHiddenSizes[2]}let f=l;if(d!==h)throw new Error("qkv_hidden_sizes first element should be same as the second");if(r.dims[0]!==d+h+p)throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');let m=0;if(i){if(h!==p)throw new Error('Input "past" expect k_hidden_size == v_hidden_size');if(i.dims.length!==5)throw new Error('Input "past" must have 5 dimensions');if(i.dims[0]!==2)throw new Error('Input "past" first dimension must be 2');if(i.dims[1]!==u)throw new Error('Input "past" second dimension must be batch_size');if(i.dims[2]!==e.numHeads)throw new Error('Input "past" third dimension must be num_heads');if(i.dims[4]!==h/e.numHeads)throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');e.pastPresentShareBuffer||(m=i.dims[3])}let g=f+m,y=-1,b=0;if(a)throw new Error("Mask not supported");if(i)throw new Error("past is not supported");if(o){if(o.dims.length!==4)throw new Error('Input "attention_bias" must have 4 dimensions');if(o.dims[0]!==u||o.dims[1]!==e.numHeads||o.dims[2]!==l||o.dims[3]!==g)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:u,sequenceLength:l,pastSequenceLength:m,kvSequenceLength:f,totalSequenceLength:g,maxSequenceLength:y,inputHiddenSize:c,hiddenSize:d,vHiddenSize:p,headSize:Math.floor(d/e.numHeads),vHeadSize:Math.floor(p/e.numHeads),numHeads:e.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:e.maskFilterValue,maskType:b,scale:e.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},yc=(t,e,n)=>e&&t?`
      let total_sequence_length_input = u32(${e.getByOffset("0")});
      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);
      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;
      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;
      total_sequence_length = u32(${t==null?void 0:t.getByOffset("batchIdx")}) + 1;
      var past_sequence_length: u32 = 0;
      if (is_first_prompt == false) {
        past_sequence_length = total_sequence_length - sequence_length;
      }
       `:`
    ${n?"let past_sequence_length = uniforms.past_sequence_length":""};
    let present_sequence_length = total_sequence_length;
    `,zv=(t,e,n,s,r,a,i,o)=>{let u=Nt(i?1:a),l=64,c=a/u;c<l&&(l=32);let d=Math.ceil(a/u/l),h=[{type:12,data:e},{type:12,data:n},{type:12,data:s},{type:12,data:r},{type:12,data:c},{type:12,data:d}],p=sn(t.dataType,u),f=vn(1,u),m=["type"];i&&m.push("type"),o&&m.push("type");let g=y=>{let b=ve("x",t.dataType,t.dims,u),$=[b],w=i?ue("seq_lens",i.dataType,i.dims):void 0;w&&$.push(w);let v=o?ue("total_sequence_length_input",o.dataType,o.dims):void 0;v&&$.push(v);let k=vn(t.dataType),C=[{name:"batch_size",type:"u32"},{name:"num_heads",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"sequence_length",type:"u32"},{name:"total_sequence_length",type:"u32"},{name:"elements_per_thread",type:"u32"}];return`
  var<workgroup> thread_max: array<f32, ${l}>;
  var<workgroup> thread_sum: array<f32, ${l}>;
  ${y.registerUniforms(C).declareVariables(...$)}
  ${y.mainStart([l,1,1])}
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let sequence_length = uniforms.sequence_length;
    var total_sequence_length = uniforms.total_sequence_length;
    ${yc(w,v,!1)}
    let local_offset = local_idx * uniforms.elements_per_thread;
    let offset = (global_idx / ${l}) * uniforms.total_sequence_length + local_offset;
    let seq_causal_length = ${i?"u32(past_sequence_length + workgroup_id.y + 1)":"total_sequence_length"};
    var thread_max_vector = ${f}(-3.402823e+38f);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      thread_max_vector = max(${f}(x[offset + i]), thread_max_vector);
    }
    thread_max[local_idx] = ${(()=>{switch(u){case 1:return"thread_max_vector";case 2:return"max(thread_max_vector.x, thread_max_vector.y)";case 4:return"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";default:throw new Error(`Unsupported components: ${u}`)}})()};
    workgroupBarrier();

    var max_value =  f32(-3.402823e+38f);
    for (var i = 0u; i < ${l}; i++) {
      max_value = max(thread_max[i], max_value);
    }

    var sum_vector = ${f}(0);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      sum_vector += exp(${f}(x[offset + i]) - max_value);
    }
    thread_sum[local_idx] = ${(()=>{switch(u){case 1:return"sum_vector";case 2:return"sum_vector.x + sum_vector.y";case 4:return"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";default:throw new Error(`Unsupported components: ${u}`)}})()};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${l}; i++) {
      sum += thread_sum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        x[offset + i] = ${b.type.value}(${k}(1.0) / ${k}(seq_causal_length));
      }
    } else {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        var f32input = ${f}(x[offset + i]);
        x[offset + i] = ${b.type.value}(exp(f32input - max_value) / sum);
      }
    }
      ${i?`
        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {
          x[offset + total_seq_id] = ${b.type.value}(${k}(0));
        }`:""};
  }`};return{name:"AttentionProbsSoftmax",shaderCache:{hint:`${l};${p};${u}`,inputDependencies:m},getShaderSource:g,getRunData:()=>({outputs:[],dispatchGroup:{x:1,y:r,z:e*n},programUniforms:h})}},Lv=(t,e,n,s,r,a,i,o,u)=>{let l=i+a.kvSequenceLength,c=[a.batchSize,a.numHeads,a.sequenceLength,l],d=t>1&&s,h=a.kvNumHeads?a.kvNumHeads:a.numHeads,p=d?[a.batchSize,h,l,a.headSize]:void 0,f=a.nReps?a.nReps:1,m=a.scale===0?1/Math.sqrt(a.headSize):a.scale,g=Nt(a.headSize),y=a.headSize/g,b=12,$={x:Math.ceil(l/b),y:Math.ceil(a.sequenceLength/b),z:a.batchSize*a.numHeads},w=[{type:12,data:a.sequenceLength},{type:12,data:y},{type:12,data:l},{type:12,data:a.numHeads},{type:12,data:a.headSize},{type:1,data:m},{type:12,data:i},{type:12,data:a.kvSequenceLength},{type:12,data:f}],v=d&&s&&re.size(s.dims)>0,k=["type","type"];v&&k.push("type"),r&&k.push("type"),o&&k.push("type"),u&&k.push("type");let C=[{dims:c,dataType:e.dataType,gpuDataType:0}];d&&C.push({dims:p,dataType:e.dataType,gpuDataType:0});let N=A=>{let I=ue("q",e.dataType,e.dims,g),E=ue("key",n.dataType,n.dims,g),z=[I,E];if(v){let Y=ue("past_key",s.dataType,s.dims,g);z.push(Y)}r&&z.push(ue("attention_bias",r.dataType,r.dims));let P=o?ue("seq_lens",o.dataType,o.dims):void 0;P&&z.push(P);let H=u?ue("total_sequence_length_input",u.dataType,u.dims):void 0;H&&z.push(H);let G=ve("output",e.dataType,c),W=[G];d&&W.push(ve("present_key",e.dataType,p,g));let L=vn(1,g),B=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"alpha",type:"f32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}];return`
  const TILE_SIZE = ${b}u;

  var<workgroup> tileQ: array<${I.type.storage}, ${b*b}>;
  var<workgroup> tileK: array<${I.type.storage}, ${b*b}>;
  ${A.registerUniforms(B).declareVariables(...z,...W)}
  ${A.mainStart([b,b,1])}
    // x holds the N and y holds the M
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let kvHeadIdx = ${f===1?"headIdx":"headIdx / uniforms.n_reps"};
    let kv_num_heads = ${f===1?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let sequence_length = uniforms.M;
    var total_sequence_length = uniforms.N;
    ${yc(P,H,!0)}
    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;
    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
    ${v&&d?"let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;":""};
    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;
    ${d?"let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;":""}
    var value = ${L}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
      ${v&&d?`
              if (n + local_id.y < past_sequence_length) {
                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];
              }`:`
          if (n + local_id.y < uniforms.kv_sequence_length) {
            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
          }`}
      ${d?`if (n + local_id.y < present_sequence_length) {
        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];
      }`:""}
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
          value += ${L}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);
      }

      workgroupBarrier();
    }

    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {
      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;
      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;
      var sum: f32 = ${(()=>{switch(g){case 1:return"value";case 2:return"value.x + value.y";case 4:return"value.x + value.y + value.z + value.w";default:throw new Error(`Unsupported components: ${g}`)}})()};
        output[outputIdx] = ${G.type.value} (sum * uniforms.alpha) + ${r?"attention_bias[outputIdx]":"0.0"};
    }
  }`};return{name:"AttentionProbs",shaderCache:{hint:`${g};${r!==void 0};${s!==void 0};${t}`,inputDependencies:k},getRunData:()=>({outputs:C,dispatchGroup:$,programUniforms:w}),getShaderSource:N}},Pv=(t,e,n,s,r,a,i=void 0,o=void 0)=>{let u=a+r.kvSequenceLength,l=r.nReps?r.nReps:1,c=r.vHiddenSize*l,d=t>1&&s,h=r.kvNumHeads?r.kvNumHeads:r.numHeads,p=d?[r.batchSize,h,u,r.headSize]:void 0,f=[r.batchSize,r.sequenceLength,c],m=12,g={x:Math.ceil(r.vHeadSize/m),y:Math.ceil(r.sequenceLength/m),z:r.batchSize*r.numHeads},y=[{type:12,data:r.sequenceLength},{type:12,data:u},{type:12,data:r.vHeadSize},{type:12,data:r.numHeads},{type:12,data:r.headSize},{type:12,data:c},{type:12,data:a},{type:12,data:r.kvSequenceLength},{type:12,data:l}],b=d&&s&&re.size(s.dims)>0,$=["type","type"];b&&$.push("type"),i&&$.push("type"),o&&$.push("type");let w=[{dims:f,dataType:e.dataType,gpuDataType:0}];d&&w.push({dims:p,dataType:e.dataType,gpuDataType:0});let v=k=>{let C=ue("probs",e.dataType,e.dims),N=ue("v",n.dataType,n.dims),A=[C,N];b&&A.push(ue("past_value",s.dataType,s.dims));let I=i?ue("seq_lens",i.dataType,i.dims):void 0;i&&A.push(I);let E=o?ue("total_sequence_length_input",o.dataType,o.dims):void 0;o&&A.push(E);let z=[ve("output",e.dataType,f)];d&&z.push(ve("present_value",e.dataType,p));let P=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"v_hidden_size",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}];return`
  const TILE_SIZE = ${m}u;
  var<workgroup> tileQ: array<${C.type.value}, ${m*m}>;
  var<workgroup> tileV: array<${C.type.value}, ${m*m}>;
  ${k.registerUniforms(P).declareVariables(...A,...z)}
  ${k.mainStart([m,m,1])}
   let headIdx = workgroup_id.z % uniforms.num_heads;
   let batchIdx = workgroup_id.z / uniforms.num_heads;
   let kvHeadIdx = ${l===1?"headIdx":"headIdx / uniforms.n_reps"};
   let kv_num_heads = ${l===1?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};
   let m = global_id.y;
   let n = global_id.x;
   let sequence_length = uniforms.M;
   var total_sequence_length = uniforms.K;
   ${yc(I,E,!0)}
   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch
   ${b&&d?"let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;":""};
   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;
   ${d?"let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;":""}
   var value = ${C.type.storage}(0);
   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
        ${b&&d?`
        if (w + local_id.y < past_sequence_length) {
          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];
        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];
        }
      `:`
            if (w + local_id.y < uniforms.kv_sequence_length) {
              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];
            }`}
        ${d?`
            if (w + local_id.y < present_sequence_length) {
          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];
        }`:""}
      }
     workgroupBarrier();
     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   if (m < uniforms.M && n < uniforms.N) {
     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size
       + headIdx * uniforms.N + n;
     output[outputIdx] = value;
   }
  }`};return{name:"AttentionScore",shaderCache:{hint:`${s!==void 0};${t}`,inputDependencies:$},getRunData:()=>({outputs:w,dispatchGroup:g,programUniforms:y}),getShaderSource:v}},xu=(t,e,n,s,r,a,i,o,u,l,c=void 0,d=void 0)=>{let h=Math.min(t.outputCount,1+(i?1:0)+(o?1:0)),p=h>1?l.pastSequenceLength:0,f=p+l.kvSequenceLength,m=u&&re.size(u.dims)>0?u:void 0,g=[e,n];h>1&&i&&re.size(i.dims)>0&&g.push(i),m&&g.push(m),c&&g.push(c),d&&g.push(d);let y=t.compute(Lv(h,e,n,i,m,l,p,c,d),{inputs:g,outputs:h>1?[-1,1]:[-1]})[0];t.compute(zv(y,l.batchSize,l.numHeads,p,l.sequenceLength,f,c,d),{inputs:c&&d?[y,c,d]:[y],outputs:[]});let b=[y,s];h>1&&o&&re.size(o.dims)>0&&b.push(o),c&&b.push(c),d&&b.push(d),t.compute(Pv(h,y,s,o,l,p,c,d),{inputs:b,outputs:h>1?[0,2]:[0]})},Bv=(t,e)=>{let n=[e.batchSize,e.numHeads,e.sequenceLength,e.headSize],s=e.sequenceLength,r=e.inputHiddenSize,a=e.headSize,i=12,o={x:Math.ceil(e.headSize/i),y:Math.ceil(e.sequenceLength/i),z:e.batchSize*e.numHeads},u=[t.inputs[0],t.inputs[1],t.inputs[2]],l=[{type:12,data:s},{type:12,data:r},{type:12,data:a},{type:12,data:e.numHeads},{type:12,data:e.headSize},{type:12,data:e.hiddenSize},{type:12,data:e.hiddenSize+e.hiddenSize+e.vHiddenSize}],c=d=>{let h=ve("output_q",u[0].dataType,n),p=ve("output_k",u[0].dataType,n),f=ve("output_v",u[0].dataType,n),m=ue("input",u[0].dataType,u[0].dims),g=ue("weight",u[1].dataType,u[1].dims),y=ue("bias",u[2].dataType,u[2].dims),b=m.type.storage,$=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}];return`
  const TILE_SIZE = ${i}u;
  var<workgroup> tileInput: array<${b}, ${i*i}>;
  var<workgroup> tileWeightQ: array<${b}, ${i*i}>;
  var<workgroup> tileWeightK: array<${b}, ${i*i}>;
  var<workgroup> tileWeightV: array<${b}, ${i*i}>;
  ${d.registerUniforms($).declareVariables(m,g,y,h,p,f)}
  ${d.mainStart([i,i,1])}
    let batchIndex = workgroup_id.z / uniforms.num_heads;
    let headNumber = workgroup_id.z % uniforms.num_heads;
    let m = global_id.y;
    let n = global_id.x;

    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;
    let biasOffsetQ = headNumber * uniforms.head_size;
    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;
    let biasOffsetV = uniforms.hidden_size + biasOffsetK;

    var valueQ = ${b}(0);
    var valueK = ${b}(0);
    var valueV = ${b}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        let offset = n + (w + local_id.y) * uniforms.ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * uniforms.N + n) % uniforms.head_size;
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * uniforms.M * uniforms.N;
    if (m < uniforms.M && n < uniforms.N) {
      let outputIdx = offset + m * uniforms.N + n;
      output_q[outputIdx] = valueQ;
      output_k[outputIdx] = valueK;
      output_v[outputIdx] = valueV;
    }
  }`};return t.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:n,dataType:t.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:t.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:t.inputs[0].dataType,gpuDataType:0}],dispatchGroup:o,programUniforms:l}),getShaderSource:c},{inputs:u,outputs:[-1,-1,-1]})},CR=(t,e)=>{let n=Fv(t.inputs,e),[s,r,a]=Bv(t,n);return xu(t,s,r,a,t.inputs[4],void 0,void 0,void 0,t.inputs[5],n)}}),Mv,Vv,Wv,TR,ule=he(()=>{Ts(),De(),Be(),Ot(),Me(),Mv=(t,e)=>{if(!t||t.length!==5)throw new Error("BatchNormalization requires 5 inputs");let n=(s,r,a)=>{let i=r.length;if(i!==s.length)throw new Error(`${a}: num dimensions != ${i}`);r.forEach((o,u)=>{if(o!==s[u])throw new Error(`${a}: dim[${u}] do not match`)})};if(t[0].dims.length>1){let s=e.format==="NHWC"?e.spatial?t[0].dims.slice(-1):t[0].dims.slice(-1).concat(t[0].dims.slice(1,t[0].dims.length-1)):t[0].dims.slice(1,e.spatial?2:void 0);n(t[1].dims,s,"Invalid input scale"),n(t[2].dims,s,"Invalid input B"),n(t[3].dims,s,"Invalid input mean"),n(t[4].dims,s,"Invalid input var")}else n(t[1].dims,[1],"Invalid input scale"),n(t[2].dims,[1],"Invalid input B"),n(t[3].dims,[1],"Invalid input mean"),n(t[4].dims,[1],"Invalid input var")},Vv=(t,e)=>{let{epsilon:n,spatial:s,format:r}=e,a=t[0].dims,i=s?Nt(a[a.length-1]):1,o=r==="NHWC"&&a.length>1?i:1,u=re.size(a)/i,l=s,c=l?a.length:a,d=ue("x",t[0].dataType,t[0].dims,i),h=ue("scale",t[1].dataType,t[1].dims,o),p=ue("bias",t[2].dataType,t[2].dims,o),f=ue("inputMean",t[3].dataType,t[3].dims,o),m=ue("inputVar",t[4].dataType,t[4].dims,o),g=ve("y",t[0].dataType,c,i),y=()=>{let $="";if(s)$=`let cOffset = ${a.length===1?"0u":r==="NHWC"?`outputIndices[${a.length-1}] / ${i}`:"outputIndices[1]"};`;else if(r==="NCHW")$=`
            ${g.indicesSet("outputIndices","0","0")}
            let cOffset = ${g.indicesToOffset("outputIndices")};`;else{$=`var cIndices = ${h.type.indices}(0);
                       cIndices[0] = outputIndices[${a.length-1}];`;for(let w=1;w<h.rank;w++)$+=`cIndices[${w}] = outputIndices[${w}];`;$+=`let cOffset = ${h.indicesToOffset("cIndices")};`}return $},b=$=>`
  const epsilon = ${n};
  ${$.registerUniform("outputSize","u32").declareVariables(d,h,p,f,m,g)}
  ${$.mainStart()}
  ${$.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    var outputIndices = ${g.offsetToIndices(`global_idx * ${i}`)};
    ${y()}
    let scale = ${h.getByOffset("cOffset")};
    let bias = ${p.getByOffset("cOffset")};
    let inputMean = ${f.getByOffset("cOffset")};
    let inputVar = ${m.getByOffset("cOffset")};
    let x = ${d.getByOffset("global_idx")};
    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;
    ${g.setByOffset("global_idx","value")}
  }`;return{name:"BatchNormalization",shaderCache:{hint:`${e.epsilon}_${e.format}_${s}_${i}`,inputDependencies:l?["rank","type","type","type","type"]:void 0},getShaderSource:b,getRunData:()=>({outputs:[{dims:t[0].dims,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:l?[{type:12,data:u},...Ce(a)]:[{type:12,data:u}]})}},Wv=t=>lt(t),TR=(t,e)=>{let{inputs:n,outputCount:s}=t,r=Wv({...e,outputCount:s});if(gt.webgpu.validateInputContent&&Mv(n,r),e.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");t.compute(Vv(n,r))}}),Uv,Gv,NR,lle=he(()=>{Be(),Me(),Uv=t=>{if(t[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(t[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(t[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(t[0].dims[2]!==t[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Gv=t=>{let e=t[0].dims,n=t[0].dims[2],s=re.size(e)/4,r=t[0].dataType,a=ue("input",r,e,4),i=ue("bias",r,[n],4),o=ue("residual",r,e,4),u=ve("output",r,e,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:e,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:l=>`
  const channels = ${n}u / 4;
  ${l.declareVariables(a,i,o,u)}

  ${l.mainStart()}
    ${l.guardAgainstOutOfBoundsWorkgroupSizes(s)}
    let value = ${a.getByOffset("global_idx")}
      + ${i.getByOffset("global_idx % channels")} + ${o.getByOffset("global_idx")};
    ${u.setByOffset("global_idx","value")}
  }`}},NR=t=>{Uv(t.inputs),t.compute(Gv(t.inputs))}}),Hv,ot,ER,AR,RR,DR,OR,FR,zR,LR,PR,qv,BR,MR,VR,WR,Qo,UR,zc,GR,HR,qR,jR,KR,XR,YR,ZR,QR,JR,eD,tD,nD,sD,rD,aD,Cf,iD,og,ug,oD,uD,lD,jv,Kv,cD,V0=he(()=>{De(),Be(),Ot(),Me(),Hv=(t,e,n,s,r,a,i)=>{let o=Math.ceil(e/4),u="";typeof r=="string"?u=`${r}(a)`:u=r("a");let l=ue("inputData",n,[o],4),c=ve("outputData",s,[o],4),d=[{name:"vec_size",type:"u32"}];return i&&d.push(...i),`
      ${t.registerUniforms(d).declareVariables(l,c)}

  ${a??""}

  ${t.mainStart()}
    ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${l.getByOffset("global_idx")};
    ${c.setByOffset("global_idx",u)}
  }`},ot=(t,e,n,s,r,a=t.dataType,i,o)=>{let u=[{type:12,data:Math.ceil(re.size(t.dims)/4)}];return i&&u.push(...i),{name:e,shaderCache:{hint:r,inputDependencies:["type"]},getShaderSource:l=>Hv(l,re.size(t.dims),t.dataType,a,n,s,o),getRunData:l=>({outputs:[{dims:t.dims,dataType:a}],dispatchGroup:{x:Math.ceil(re.size(l[0].dims)/64/4)},programUniforms:u})}},ER=t=>{t.compute(ot(t.inputs[0],"Abs","abs"))},AR=t=>{t.compute(ot(t.inputs[0],"Acos","acos"))},RR=t=>{t.compute(ot(t.inputs[0],"Acosh","acosh"))},DR=t=>{t.compute(ot(t.inputs[0],"Asin","asin"))},OR=t=>{t.compute(ot(t.inputs[0],"Asinh","asinh"))},FR=t=>{t.compute(ot(t.inputs[0],"Atan","atan"))},zR=t=>{t.compute(ot(t.inputs[0],"Atanh","atanh"))},LR=t=>lt(t),PR=(t,e)=>{let n;switch(e.to){case 10:n="vec4<f16>";break;case 1:n="vec4<f32>";break;case 12:n="vec4<u32>";break;case 6:n="vec4<i32>";break;case 9:n="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${e.to}`)}t.compute(ot(t.inputs[0],"Cast",n,void 0,e.cacheKey,e.to))},qv=t=>{let e,n,s=t.length>=2&&t[1].data!==0,r=t.length>=3&&t[2].data!==0;switch(t[0].dataType){case 1:e=s?t[1].getFloat32Array()[0]:-34028234663852886e22,n=r?t[2].getFloat32Array()[0]:34028234663852886e22;break;case 10:e=s?t[1].getUint16Array()[0]:64511,n=r?t[2].getUint16Array()[0]:31743;break;default:throw new Error("Unsupport data type")}return lt({min:e,max:n})},BR=(t,e)=>{let n=e||qv(t.inputs),s=vn(t.inputs[0].dataType);t.compute(ot(t.inputs[0],"Clip",r=>`clamp(${r}, vec4<${s}>(uniforms.min), vec4<${s}>(uniforms.max))`,void 0,n.cacheKey,void 0,[{type:t.inputs[0].dataType,data:n.min},{type:t.inputs[0].dataType,data:n.max}],[{name:"min",type:s},{name:"max",type:s}]),{inputs:[0]})},MR=t=>{t.compute(ot(t.inputs[0],"Ceil","ceil"))},VR=t=>{t.compute(ot(t.inputs[0],"Cos","cos"))},WR=t=>{t.compute(ot(t.inputs[0],"Cosh","cosh"))},Qo=t=>lt(t),UR=(t,e)=>{let n=vn(t.inputs[0].dataType);t.compute(ot(t.inputs[0],"Elu",s=>`elu_vf32(${s})`,`
  const elu_alpha_ = ${n}(${e.alpha});

  fn elu_f32(a: ${n}) -> ${n} {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<${n}>) -> vec4<${n}> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,e.cacheKey))},zc=(t="f32")=>`
const r0: ${t} = 0.3275911;
const r1: ${t} = 0.254829592;
const r2: ${t} = -0.284496736;
const r3: ${t} = 1.421413741;
const r4: ${t} = -1.453152027;
const r5: ${t} = 1.061405429;

fn erf_vf32(v: vec4<${t}>) -> vec4<${t}> {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`,GR=t=>{let e=vn(t.inputs[0].dataType);t.compute(ot(t.inputs[0],"Erf",n=>`erf_vf32(${n})`,zc(e)))},HR=t=>{t.compute(ot(t.inputs[0],"Exp","exp"))},qR=t=>{t.compute(ot(t.inputs[0],"Floor","floor"))},jR=t=>{let e=vn(t.inputs[0].dataType);t.compute(ot(t.inputs[0],"Gelu",n=>`0.5 * ${n} * (1.0 + erf_vf32(${n} * 0.7071067811865475))`,zc(e)))},KR=(t,e)=>{let n=vn(t.inputs[0].dataType);t.compute(ot(t.inputs[0],"LeakyRelu",s=>`select(leaky_relu_alpha_ * ${s}, ${s}, ${s} >= vec4<${n}>(0.0))`,`const leaky_relu_alpha_ = ${n}(${e.alpha});`,e.cacheKey))},XR=t=>{t.compute(ot(t.inputs[0],"Not",e=>`!${e}`))},YR=t=>{t.compute(ot(t.inputs[0],"Neg",e=>`-${e}`))},ZR=t=>{t.compute(ot(t.inputs[0],"Reciprocal",e=>`1.0/${e}`))},QR=t=>{let e=vn(t.inputs[0].dataType);t.compute(ot(t.inputs[0],"Relu",n=>`select(vec4<${e}>(0.0), ${n}, ${n} > vec4<${e}>(0.0))`))},JR=t=>{t.compute(ot(t.inputs[0],"Sigmoid",e=>`(1.0 / (1.0 + exp(-${e})))`))},eD=t=>lt(t),tD=(t,e)=>{let n=vn(t.inputs[0].dataType);t.compute(ot(t.inputs[0],"HardSigmoid",s=>`max(vec4<${n}>(0.0), min(vec4<${n}>(1.0), ${e.alpha} * ${s} + vec4<${n}>(${e.beta})))`,void 0,e.cacheKey))},nD=t=>{t.compute(ot(t.inputs[0],"Sin","sin"))},sD=t=>{t.compute(ot(t.inputs[0],"Sinh","sinh"))},rD=t=>{t.compute(ot(t.inputs[0],"Sqrt","sqrt"))},aD=t=>{t.compute(ot(t.inputs[0],"Tan","tan"))},Cf=t=>`sign(${t}) * (1 - exp(-2 * abs(${t}))) / (1 + exp(-2 * abs(${t})))`,iD=t=>{t.compute(ot(t.inputs[0],"Tanh",Cf))},og=(t="f32")=>`
const fast_gelu_a: ${t} = 0.5;
const fast_gelu_b: ${t} = 0.7978845608028654;
const fast_gelu_c: ${t} = 0.035677408136300125;

fn tanh_v(v: vec4<${t}>) -> vec4<${t}> {
  return ${Cf("v")};
}
`,ug=t=>`(fast_gelu_a + fast_gelu_a * tanh_v(${t} * (fast_gelu_c * ${t} * ${t} + fast_gelu_b))) * ${t}`,oD=t=>{let e=vn(t.inputs[0].dataType);t.compute(ot(t.inputs[0],"FastGelu",ug,og(e),void 0,t.inputs[0].dataType))},uD=(t,e)=>{let n=vn(t.inputs[0].dataType);return t.compute(ot(t.inputs[0],"ThresholdedRelu",s=>`select(vec4<${n}>(0.0), ${s}, ${s} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${n}>(${e.alpha});`,e.cacheKey)),0},lD=t=>{t.compute(ot(t.inputs[0],"Log","log"))},jv=(t,e)=>`
const alpha = vec4<${t}>(${e});
const one = ${t}(1.0);
const zero = ${t}(0.0);

fn quick_gelu_impl(x: vec4<${t}>) -> vec4<${t}> {
  let v = x *alpha;
  var x1 : vec4<${t}>;
  for (var i = 0; i < 4; i = i + 1) {
    if (v[i] >= zero) {
      x1[i] = one / (one + exp(-v[i]));
    } else {
      x1[i] = one - one / (one + exp(v[i]));
    }
  }
  return x * x1;
}
`,Kv=t=>`quick_gelu_impl(${t})`,cD=(t,e)=>{let n=vn(t.inputs[0].dataType);t.compute(ot(t.inputs[0],"QuickGelu",Kv,jv(n,e.alpha),e.cacheKey,t.inputs[0].dataType))}}),Xv,Yv,dD,cle=he(()=>{Be(),Me(),V0(),Xv=t=>{if(t[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(t[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(t[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(t[0].dims[2]!==t[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Yv=t=>{let e=t[0].dims.slice();e[2]=e[2]/2;let n=ue("input",t[0].dataType,t[0].dims,4),s=ue("bias",t[0].dataType,[t[0].dims[2]],4),r=ve("output",t[0].dataType,e,4),a=re.size(e)/4,i=sn(t[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:e,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:o=>`
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${t[0].dims[2]/4/2}u;

  ${o.declareVariables(n,s,r)}

  ${zc(i)}

  ${o.mainStart()}
    ${o.guardAgainstOutOfBoundsWorkgroupSizes(a)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${r.setByOffset("global_idx","valueLeft * geluRight")}
  }`}},dD=t=>{Xv(t.inputs),t.compute(Yv(t.inputs))}}),Zv,Qv,Bs,hD,pD,fD,mD,gD,yD,bD,xD,wD,$D,dle=he(()=>{De(),Be(),Me(),Zv=(t,e,n,s,r,a,i,o,u,l,c,d)=>{let h,p;typeof o=="string"?h=p=(b,$)=>`${o}((${b}),(${$}))`:typeof o=="function"?h=p=o:(h=o.scalar,p=o.vector);let f=ve("outputData",c,s.length,4),m=ue("aData",u,e.length,4),g=ue("bData",l,n.length,4),y;if(r)if(a){let b=re.size(e)===1,$=re.size(n)===1,w=e.length>0&&e[e.length-1]%4===0,v=n.length>0&&n[n.length-1]%4===0;b||$?y=f.setByOffset("global_idx",p(b?`${m.type.value}(${m.getByOffset("0")}.x)`:m.getByOffset("global_idx"),$?`${g.type.value}(${g.getByOffset("0")}.x)`:g.getByOffset("global_idx"))):y=`
            let outputIndices = ${f.offsetToIndices("global_idx * 4u")};
            let offsetA = ${m.broadcastedIndicesToOffset("outputIndices",f)};
            let offsetB = ${g.broadcastedIndicesToOffset("outputIndices",f)};
            ${f.setByOffset("global_idx",p(i||w?m.getByOffset("offsetA / 4u"):`${m.type.value}(${m.getByOffset("offsetA / 4u")}[offsetA % 4u])`,i||v?g.getByOffset("offsetB / 4u"):`${g.type.value}(${g.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}
          `}else y=f.setByOffset("global_idx",p(m.getByOffset("global_idx"),g.getByOffset("global_idx")));else{if(!a)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let b=($,w,v="")=>{let k=`aData[indexA${w}][componentA${w}]`,C=`bData[indexB${w}][componentB${w}]`;return`
            let outputIndices${w} = ${f.offsetToIndices(`global_idx * 4u + ${w}u`)};
            let offsetA${w} = ${m.broadcastedIndicesToOffset(`outputIndices${w}`,f)};
            let offsetB${w} = ${g.broadcastedIndicesToOffset(`outputIndices${w}`,f)};
            let indexA${w} = offsetA${w} / 4u;
            let indexB${w} = offsetB${w} / 4u;
            let componentA${w} = offsetA${w} % 4u;
            let componentB${w} = offsetB${w} % 4u;
            ${$}[${w}] = ${v}(${h(k,C)});
          `};c===9?y=`
            var data = vec4<u32>(0);
            ${b("data",0,"u32")}
            ${b("data",1,"u32")}
            ${b("data",2,"u32")}
            ${b("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:y=`
            ${b("outputData[global_idx]",0)}
            ${b("outputData[global_idx]",1)}
            ${b("outputData[global_idx]",2)}
            ${b("outputData[global_idx]",3)}
          `}return`
        ${t.registerUniform("vec_size","u32").declareVariables(m,g,f)}

        ${d??""}

        ${t.mainStart()}
        ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${y}
      }`},Qv=(t,e,n,s,r,a,i=n.dataType)=>{let o=n.dims.map(m=>Number(m)??1),u=s.dims.map(m=>Number(m)??1),l=!re.areEqual(o,u),c=o,d=re.size(o),h=!1,p=!1,f=[l];if(l){let m=ro.calcShape(o,u,!1);if(!m)throw new Error("Can't perform binary op on the given tensors");c=m.slice(),d=re.size(c);let g=re.size(o)===1,y=re.size(u)===1,b=o.length>0&&o[o.length-1]%4===0,$=u.length>0&&u[u.length-1]%4===0;f.push(g),f.push(y),f.push(b),f.push($);let w=1;for(let v=1;v<c.length;v++){let k=o[o.length-v],C=u[u.length-v];if(k===C)w*=k;else break}w%4===0?(p=!0,h=!0):(g||y||b||$)&&(h=!0)}else h=!0;return f.push(h),{name:t,shaderCache:{hint:e+f.map(m=>m.toString()).join("_"),inputDependencies:["rank","rank"]},getShaderSource:m=>Zv(m,o,u,c,h,l,p,r,n.dataType,s.dataType,i,a),getRunData:()=>({outputs:[{dims:c,dataType:i}],dispatchGroup:{x:Math.ceil(d/64/4)},programUniforms:[{type:12,data:Math.ceil(re.size(c)/4)},...Ce(o,u,c)]})}},Bs=(t,e,n,s,r,a)=>{t.compute(Qv(e,r??"",t.inputs[0],t.inputs[1],n,s,a))},hD=t=>{Bs(t,"Add",(e,n)=>`${e}+${n}`)},pD=t=>{Bs(t,"Div",(e,n)=>`${e}/${n}`)},fD=t=>{Bs(t,"Equal",{scalar:(e,n)=>`u32(${e}==${n})`,vector:(e,n)=>`vec4<u32>(${e}==${n})`},void 0,void 0,9)},mD=t=>{Bs(t,"Mul",(e,n)=>`${e}*${n}`)},gD=t=>{let e=ue("input",t.inputs[0].dataType,t.inputs[0].dims).type.value;Bs(t,"Pow",{scalar:(n,s)=>`pow_custom(${n},${s})`,vector:(n,s)=>`pow_vector_custom(${n},${s})`},`
    fn pow_custom(a : ${e}, b : ${e}) -> ${e} {
      if (b == ${e}(0.0)) {
        return ${e}(1.0);
      } else if (a < ${e}(0.0) && f32(b) != floor(f32(b))) {
        return ${e}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${e}(1.0), round(f32(abs(b) % ${e}(2.0))) != 1.0) * ${e}(${e==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${e}>, b : vec4<${e}>) -> vec4<${e}> {
      // TODO: implement vectorized pow
      return vec4<${e}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `)},yD=t=>{Bs(t,"Sub",(e,n)=>`${e}-${n}`)},bD=t=>{Bs(t,"Greater",{scalar:(e,n)=>`u32(${e}>${n})`,vector:(e,n)=>`vec4<u32>(${e}>${n})`},void 0,void 0,9)},xD=t=>{Bs(t,"Less",{scalar:(e,n)=>`u32(${e}<${n})`,vector:(e,n)=>`vec4<u32>(${e}<${n})`},void 0,void 0,9)},wD=t=>{Bs(t,"GreaterOrEqual",{scalar:(e,n)=>`u32(${e}>=${n})`,vector:(e,n)=>`vec4<u32>(${e}>=${n})`},void 0,void 0,9)},$D=t=>{Bs(t,"LessOrEqual",{scalar:(e,n)=>`u32(${e}<=${n})`,vector:(e,n)=>`vec4<u32>(${e}<=${n})`},void 0,void 0,9)}}),Jv,e2,t2,n2,vD,SD,hle=he(()=>{De(),Be(),Ot(),Me(),Jv=(t,e)=>{if(!t||t.length<1)throw new Error("too few inputs");let n=0,s=t[n],r=s.dataType,a=s.dims.length;t.forEach((i,o)=>{if(o!==n){if(i.dataType!==r)throw new Error("input tensors should be one type");if(i.dims.length!==a)throw new Error("input tensors should have the same shape");i.dims.forEach((u,l)=>{if(l!==e&&u!==s.dims[l])throw new Error("non concat dimensions must match")})}})},e2=(t,e)=>`
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${t}u>(${e});
    for (var i: u32 = 0u; i < ${t}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${t}u;
  }`,t2=(t,e)=>{let n=t.length,s=[];for(let r=0;r<n;++r){let a=e.setByOffset("global_idx",t[r].getByIndices("indices"));n===1?s.push(a):r===0?s.push(`if (inputIndex == ${r}u) { ${a} }`):r===n-1?s.push(`else { ${a} }`):s.push(`else if (inputIndex == ${r}) { ${a} }`)}return s.join(`
`)},n2=(t,e,n,s)=>{let r=re.size(n),a=new Array(t.length),i=new Array(t.length),o=0,u=[],l=[],c=[{type:12,data:r}];for(let m=0;m<t.length;++m)o+=t[m].dims[e],a[m]=o,l.push(t[m].dims.length),i[m]=ue(`input${m}`,s,l[m]),u.push("rank"),c.push({type:12,data:a[m]});for(let m=0;m<t.length;++m)c.push(...Ce(t[m].dims));c.push(...Ce(n));let d=ve("output",s,n.length),h=d.indicesGet("indices",e),p=Array.from(Array(a.length).keys()).map(m=>`uniforms.sizeInConcatAxis${m}`).join(","),f=m=>`

  ${(()=>{m.registerUniform("outputSize","u32");for(let g=0;g<t.length;g++)m.registerUniform(`sizeInConcatAxis${g}`,"u32");return m.declareVariables(...i,d)})()}

  ${e2(a.length,p)}

  ${m.mainStart()}
    ${m.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${d.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${h});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${a.length}u>(${p});
      ${h} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${t2(i,d)}
  }`;return{name:"Concat",shaderCache:{hint:`${e}`,inputDependencies:u},getRunData:()=>({outputs:[{dims:n,dataType:s}],dispatchGroup:{x:Math.ceil(r/64)},programUniforms:c}),getShaderSource:f}},vD=(t,e)=>{let n=t.inputs,s=n[0].dims,r=re.normalizeAxis(e.axis,s.length);Jv(n,r);let a=s.slice();a[r]=n.reduce((o,u)=>o+(u.dims.length>r?u.dims[r]:0),0);let i=n.filter(o=>re.size(o.dims)>0);t.compute(n2(i,r,a,n[0].dataType),{inputs:i})},SD=t=>lt({axis:t.axis})}),hi,pi,fi,W0,Ci=he(()=>{De(),Be(),hi=(t,e,n="f32")=>{switch(t.activation){case"Relu":return`value = max(value, ${e}(0.0));`;case"Sigmoid":return`value = (${e}(1.0) / (${e}(1.0) + exp(-value)));`;case"Clip":return`value = clamp(value, ${e}(${n}(uniforms.clip_min)), ${e}(${n}(uniforms.clip_max)));`;case"HardSigmoid":return`value = max(${e}(0.0), min(${e}(1.0), ${n}(uniforms.alpha) * value + ${n}(uniforms.beta)));`;case"LeakyRelu":return`value = select(${n}(uniforms.alpha) * value, value, value >= ${e}(0.0));`;case"Tanh":return`let e2x = exp(-2.0 * abs(value));
              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);
        `;case"":return"";default:throw new Error(`Unsupported activation ${t.activation}`)}},pi=(t,e)=>{t.activation==="Clip"?e.push({type:1,data:t.clipMax},{type:1,data:t.clipMin}):t.activation==="HardSigmoid"?e.push({type:1,data:t.alpha},{type:1,data:t.beta}):t.activation==="LeakyRelu"&&e.push({type:1,data:t.alpha})},fi=(t,e)=>{t.activation==="Clip"?e.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}):t.activation==="HardSigmoid"?e.push({name:"alpha",type:"f32"},{name:"beta",type:"f32"}):t.activation==="LeakyRelu"&&e.push({name:"alpha",type:"f32"})},W0=t=>{let e=(t==null?void 0:t.activation)||"";if(e==="HardSigmoid"){let[n,s]=(t==null?void 0:t.activation_params)||[.2,.5];return{activation:e,alpha:n,beta:s}}else if(e==="Clip"){let[n,s]=(t==null?void 0:t.activation_params)||[XA,YA];return{activation:e,clipMax:s,clipMin:n}}else if(e==="LeakyRelu"){let[n]=(t==null?void 0:t.activation_params)||[.01];return{activation:e,alpha:n}}return{activation:e}}}),un,ID,U0=he(()=>{un=(t,e)=>{switch(t){case 1:return e;case 2:return`vec2<${e}>`;case 3:return`vec3<${e}>`;case 4:return`vec4<${e}>`;default:throw new Error(`${t}-component is not supported.`)}},ID=t=>`
      ${t?"value = value + getBiasByOutputCoords(coords);":""}
      `}),_D,ple=he(()=>{_D=t=>`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    i32(${t}.x), i32(${t}.y), i32(${t}.z), 1));
}
`}),nu,G0,H0=he(()=>{De(),Be(),Me(),Ci(),nu=(t,e,n,s,r)=>{let a=s-n;return`
      ${Array.from({length:n}).map((i,o)=>`
      if (${Se(e.shape,o,e.rank)} != 1) {
        ${e.indicesSet(t,o,Se(r,o+a,s))}
      } else {
        ${e.indicesSet(t,o,0)}
      }`).join("")}
`},G0=(t,e,n,s,r=!1,a)=>{let i=t[0].dims,o=t[1].dims,u=i[i.length-2],l=o[o.length-1],c=i[i.length-1],d=Nt(l),h=Nt(c),p=Nt(u),f=re.size(n)/d/p,m=t.length>2,g=s?s.slice(0,-2):n.slice(0,-2),y=[re.size(g),u,l],b=[{type:12,data:f},{type:12,data:u},{type:12,data:l},{type:12,data:c}];pi(e,b),b.push(...Ce(g,i,o)),m&&b.push(...Ce(t[2].dims)),b.push(...Ce(y));let $=w=>{let v=P0("batch_dims",t[0].dataType,g.length),k=ue("a",t[0].dataType,i.length,h),C=ue("b",t[1].dataType,o.length,d),N=ve("output",t[0].dataType,y.length,d),A=sn(N.type.tensor),I=hi(e,N.type.value,A),E=[k,C],z="";if(m){let G=r?d:1;E.push(ue("bias",t[2].dataType,t[2].dims.length,G)),z=`${r?`value += bias[col / ${G}];`:`value += ${N.type.value}(bias[row + i]);`}`}let P=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"}];fi(e,P);let H=()=>{let G=`var a_data: ${k.type.value};`;for(let W=0;W<h;W++)G+=`
              let b_data${W} = b[(b_offset + (k + ${W}) * uniforms.N + col) / ${d}];`;for(let W=0;W<p;W++){G+=`a_data = a[(a_offset + (row + ${W}) * uniforms.K + k) / ${h}];`;for(let L=0;L<h;L++)G+=`
            values[${W}] = fma(${C.type.value}(a_data${h===1?"":`[${L}]`}), b_data${L}, values[${W}]);
`}return G};return`
  ${w.registerUniforms(P).registerInternalVariables(v).declareVariables(...E,N)}
  ${w.mainStart()}
    ${w.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let col = (global_idx % (uniforms.N / ${d})) * ${d};
    var index1 = global_idx / (uniforms.N / ${d});
    let stride1 = uniforms.M / ${p};
    let row = (index1 % stride1) * ${p};
    let batch = index1 / stride1;

    ${n.length===2?"":`let batch_indices = ${v.offsetToIndices("batch")};`}

    var a_indices: ${k.type.indices};
    ${nu("a_indices",k,k.rank-2,v.rank,"batch_indices")}
    ${k.indicesSet("a_indices",k.rank-2,0)}
    ${k.indicesSet("a_indices",k.rank-1,0)}
    let a_offset = ${k.indicesToOffset("a_indices")};

    var b_indices: ${C.type.indices};
    ${nu("b_indices",C,C.rank-2,v.rank,"batch_indices")}
    ${C.indicesSet("b_indices",C.rank-2,0)}
    ${C.indicesSet("b_indices",C.rank-1,0)}
    let b_offset = ${C.indicesToOffset("b_indices")};
    var values: array<${N.type.value}, ${p}>;
    for (var k: u32 = 0u; k < uniforms.K; k = k + ${h}) {
      ${H()}
    }
    for (var i = 0u; i < ${p}u; i++) {
      var value = values[i];
      ${z}
      ${I}
      let cur_indices = ${N.type.indices}(batch, row + i, col);
      let offset = ${N.indicesToOffset("cur_indices")};
      ${N.setByOffset(`offset / ${d}`,"value")};
    }
  }
  `};return{name:"MatMulNaive",shaderCache:{hint:`${e.activation};${d};${h};${p};${r}`,inputDependencies:m?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:a?a(n):n,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:b}),getShaderSource:$}}}),s2,r2,lg,Tf,a2,cg,i2,yd,q0=he(()=>{De(),Be(),Me(),Ci(),H0(),U0(),s2=(t,e)=>t?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${e?", batchIndices":""});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${e?", batchIndices":""});
        `,r2=(t,e)=>t?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${e===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${e===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${e===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`,lg=(t,e,n="f32",s,r=!1,a=32,i=!1,o=32)=>{let u=e[1]*t[1],l=e[0]*t[0],c=r?u:a,d=r?a:u,h=c/e[0],p=a/e[1];if(!((r&&h===4&&t[1]===4||!r&&(h===3||h===4))&&c%e[0]===0&&a%e[1]===0&&t[0]===4))throw new Error(`If transposeA ${r} is true, innerElementSize ${h} and workPerThread[1] ${t[1]} must be 4.
      Otherwise, innerElementSize ${h} must be 3 or 4.
  tileAWidth ${c} must be divisible by workgroupSize[0]${e[0]}. tileInner ${a} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${t[0]} must be 4.`);return`
var<workgroup> mm_Asub: array<array<vec${h}<${n}>, ${c/h}>, ${d}>;
var<workgroup> mm_Bsub: array<array<vec4<${n}>, ${l/t[0]}>, ${a}>;

const rowPerThread = ${t[1]};
const colPerThread = ${t[0]};
const innerElementSize = ${h};
const tileInner = ${a};

@compute @workgroup_size(${e[0]}, ${e[1]}, ${e[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${i?"0":"i32(globalId.z)"};
  ${s?`let batchIndices = ${s.offsetToIndices("u32(batch)")};`:""}
  let globalRowStart = i32(workgroupId.y) * ${u};

  let num_tiles = ${i?`${Math.ceil(o/a)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
  var kStart = ${i?`i32(globalId.z) * ${o}`:"0"};

  var acc: array<vec4<${n}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${p};
  for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${s2(r,s)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${p}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${s?", batchIndices":""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${h===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${r2(r,h)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`},Tf=(t,e)=>t?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${e?", batchIndices":""});
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${e?", batchIndices":""});
            `,a2=t=>t?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",cg=(t,e,n="f32",s,r=!1,a=32,i=!1,o=32,u=!1)=>{let l=t[1]*e[1],c=t[0]*e[0],d=r?l:a,h=r?a:l;if(!(h%e[1]===0&&d%e[0]===0&&a%e[1]===0))throw new Error(`tileAHight ${h} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${d} must be divisible by workgroupSize[0]${e[0]}, tileInner ${a} must be divisible by workgroupSize[1]${e[1]}`);let p=h/e[1],f=d/e[0],m=a/e[1],g=u?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${l};
    let globalColStart = i32(workgroupId.x) * ${c};

    // Loop over shared dimension.
    for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${h}; inputRow = inputRow + ${e[1]}) {
        for (var inputCol = localCol; inputCol < ${d}; inputCol = inputCol + ${e[0]}) {
          ${Tf(r,s)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${a}; inputRow = inputRow + ${e[1]}) {
            for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${e[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${s?", batchIndices":""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${n}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${r?`mm_Asub[k][localRow + innerRow * ${e[1]}];`:`mm_Asub[localRow + innerRow * ${e[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${e[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${e[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${l};

let tileRowA = i32(localId.y) * ${p};
let tileColA = i32(localId.x) * ${f};
let tileRowB = i32(localId.y) * ${m};
// Loop over shared dimension.
for (var t = 0; t < num_tiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${p}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${f}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${Tf(r,s)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${m}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${s?", batchIndices":""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${n}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${a2(r)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<${n}, ${d}>, ${h}>;
  var<workgroup> mm_Bsub : array<array<${n}, ${c}>, ${a}>;
  const rowPerThread = ${t[1]};
  const colPerThread = ${t[0]};
  const tileInner = ${a};

@compute @workgroup_size(${e[0]}, ${e[1]}, ${e[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${i?"0":"i32(globalId.z)"};
    ${s?`let batchIndices = ${s.offsetToIndices("u32(batch)")};`:""}
    let num_tiles = ${i?`${Math.ceil(o/a)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
    var kStart = ${i?`i32(globalId.z) * ${o}`:"0"};

    var acc : array<array<${n}, colPerThread>, rowPerThread>;
    ${g}
  }
`},i2=(t,e,n,s,r=!1)=>{let[a,i,o,u]=s,l=sn(s[0].type.tensor);return`
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${a.type.indices}) -> ${un(t,l)} {
      var value = ${un(t,l)}(0.0);
      let col = colIn * ${t};
      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)
      {
        var aIndices: ${i.type.indices};
        ${nu("aIndices",i,i.rank-2,a.rank,"batchIndices")}
        ${i.indicesSet("aIndices",i.rank-2,"u32(row)")}
        ${i.indicesSet("aIndices",i.rank-1,"u32(colIn)")}
        value = ${i.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${a.type.indices}) -> ${un(t,l)} {
      var value = ${un(t,l)}(0.0);
      let col = colIn * ${t};
      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)
      {
        var bIndices: ${o.type.indices};
        ${nu("bIndices",o,o.rank-2,a.rank,"batchIndices")}
        ${o.indicesSet("bIndices",o.rank-2,"u32(row)")}
        ${o.indicesSet("bIndices",o.rank-1,"u32(colIn)")}
        value = ${o.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${un(t,l)}) {
      let col = colIn * ${t};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${e?`value = value + ${r?"bias[colIn]":`${un(t,l)}(bias[row])`};`:""}
        ${n}
        ${u.setByIndices("vec3<u32>(coords)","value")}
      }
    }
    `},yd=(t,e,n,s,r=!1,a)=>{let i=t[0].dims,o=t[1].dims,u=i.slice(0,-2),l=o.slice(0,-2),c=s?s.slice(0,-2):n.slice(0,-2),d=re.size(c),h=i[i.length-2],p=i[i.length-1],f=o[o.length-1],m=p%4===0&&f%4===0,g=h<=8?[4,1,1]:[4,4,1],y=[8,8,1],b=[Math.ceil(f/y[0]/g[0]),Math.ceil(h/y[1]/g[1]),Math.ceil(d/y[2]/g[2])],$=m?4:1,w=[...u,h,p/$],v=w.length,k=[...l,p,f/$],C=k.length,N=[d,h,f/$],A=[{type:6,data:h},{type:6,data:f},{type:6,data:p}];pi(e,A),A.push(...Ce(c,w,k));let I=["rank","rank"],E=t.length>2;E&&(A.push(...Ce(t[2].dims)),I.push("rank")),A.push(...Ce(N));let z=P=>{let H=c.length,G=P0("batchDims",t[0].dataType,H,1),W=sn(t[0].dataType),L=ue("a",t[0].dataType,v,$),B=ue("b",t[1].dataType,C,$),Y=ve("result",t[0].dataType,N.length,$),ne=[L,B];if(E){let de=r?$:1;ne.push(ue("bias",t[2].dataType,t[2].dims.length,de))}let M=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"}];fi(e,M);let Z=sn(Y.type.tensor),J=hi(e,Y.type.value,Z),oe=i2($,E,J,[G,L,B,Y],r);return`
  ${P.registerUniforms(M).registerInternalVariables(G).declareVariables(...ne,Y)}
  ${oe}
  ${m?lg(g,y,W,G):cg(g,y,W,G)}
                   `};return{name:"MatMul",shaderCache:{hint:`${g};${e.activation};${m};${r}`,inputDependencies:I},getRunData:()=>({outputs:[{dims:a?a(n):n,dataType:t[0].dataType}],dispatchGroup:{x:b[0],y:b[1],z:b[2]},programUniforms:A}),getShaderSource:z}}}),o2,kD,fle=he(()=>{De(),Br(),Me(),Ci(),U0(),ple(),q0(),o2=(t,e,n,s,r=!1,a,i=4,o=4,u=4,l="f32")=>{let c=A=>{switch(A){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${l}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${A} is not supported.`)}},d=A=>{switch(A){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${A} is not supported.`)}},h=t?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,p=t?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,f=t?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",m=t?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",g=t?"row":"col",y=t?"col":"row",b=`
    let inChannels = i32(uniforms.w_shape[2]);
    let outWidth = ${t?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
    let outRow = ${g} / outWidth;
    let outCol = ${g} % outWidth;

    let WRow = ${y} / (i32(uniforms.w_shape[1]) * inChannels);
    let WCol = ${y} / inChannels % i32(uniforms.w_shape[1]);
    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
    let xCh = ${y} % inChannels;
    var resData = ${un(i,l)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${f} && xCol >= 0 && xCol < ${m}) {
      ${h}
      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));
      ${c(i)}
    }
    return resData;`,$=t?e&&s?`
    let col = colIn * ${i};
    ${b}`:`
    let col = colIn * ${i};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
      ${b}
    }
    return ${un(i,l)}(0.0);`:s&&n?`
    let col = colIn * ${i};
    ${b}`:`
    let col = colIn * ${i};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${b}
    }
    return ${un(i,l)}(0.0);`,w=t?s&&n?d(o):`
    let col = colIn * ${o};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${d(o)}
    }
    return ${un(o,l)}(0.0);`:`
    let col = colIn * ${o};
    if (row < uniforms.dim_inner && col < uniforms.dim_a_outer) {
      ${d(o)}
    }
    return ${un(o,l)}(0.0);`,v=un(u,l),k=un(t?i:o,l),C=un(t?o:i,l),N=hi(a,v,l);return`
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${k} {
      ${t?$:w}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${C} {
      ${t?w:$}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${v}) {
      let col = colIn * ${u};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)
      {
      var value = valueIn;
      let outWidth = ${t?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${p}
      ${ID(r)}
      ${N}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`},kD=(t,e,n,s,r,a,i,o,u)=>{let l=e.format==="NHWC",c=l?t[0].dims[3]:t[0].dims[1],d=n[0],h=l?n[2]:n[3],p=l?n[1]:n[2],f=l?n[3]:n[1],m=l&&(c%4===0||c%3===0)&&f%4===0,g=l?f:h*p,y=l?h*p:f,b=[8,8,1],$=s<=8?[4,1,1]:[4,4,1],w=[Math.ceil(g/b[0]/$[0]),Math.ceil(y/b[1]/$[1]),Math.ceil(d/b[2]/$[2])];et("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${w}`);let v=m?l&&c%4!==0?3:4:1,k=b[1]*$[1],C=b[0]*$[0],N=Math.max(b[0]*v,b[1]),A=s%k===0,I=r%C===0,E=a%N===0,z=m?[v,4,4]:[1,1,1],P=[{type:6,data:s},{type:6,data:r},{type:6,data:a},{type:6,data:[e.pads[0],e.pads[1]]},{type:6,data:e.strides},{type:6,data:e.dilations}];pi(e,P),P.push(...Ce(t[0].dims,t[1].dims));let H=["rank","rank"];i&&(P.push(...Ce(t[2].dims)),H.push("rank")),P.push(...Ce(n));let G=W=>{let L=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"pad",type:"i32",length:2},{name:"stride",type:"i32",length:2},{name:"dilation",type:"i32",length:2}];fi(e,L);let B=m?4:1,Y=sn(t[0].dataType),ne=`
      fn setOutputAtIndex(flatIndex : i32, value : ${m?`vec4<${Y}>`:Y}) {
        result[flatIndex] = ${m?`vec4<${Y}>`:Y}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${m?`vec4<${Y}>`:Y}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${m?"/ 4":""}, value);
      }`,M=ue("x",t[0].dataType,t[0].dims.length,v===3?1:v),Z=ue("w",t[1].dataType,t[1].dims.length,B),J=[M,Z],oe=ve("result",t[0].dataType,n.length,B);if(i){let de=ue("bias",t[2].dataType,t[2].dims.length,B);J.push(de),ne+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${m?`vec4<${Y}>`:Y} {
          return bias[coords.${l?"w":"y"}${m?"/ 4":""}];
        }`}return`
        ${_D("uniforms.result_strides")}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${W.registerUniforms(L).declareVariables(...J,oe)}
        ${ne}
        ${o2(l,A,I,E,i,e,z[0],z[1],z[2],Y)}
        ${m?lg($,b,Y,void 0,!l,N):cg($,b,Y,void 0,!l,N,!1,void 0,o)}`};return{name:"Conv2DMatMul",shaderCache:{hint:`${e.cacheKey};${v};${m};${A};${I};${E};${k};${C};${N}`,inputDependencies:H},getRunData:()=>({outputs:[{dims:u?u(n):n,dataType:t[0].dataType}],dispatchGroup:{x:w[0],y:w[1],z:w[2]},programUniforms:P}),getShaderSource:G}}}),u2,Nf,Po,l2,Ef,c2,CD,TD,mle=he(()=>{De(),Br(),Be(),Me(),Ci(),U0(),u2=t=>{let e=1;for(let n=0;n<t.length;n++)e*=t[n];return e},Nf=t=>typeof t=="number"?[t,t,t]:t,Po=(t,e)=>e<=1?t:t+(t-1)*(e-1),l2=(t,e,n,s=1)=>{let r=Po(e,s);return Math.floor((t[0]*(n-1)-n+r)/2)},Ef=(t,e,n,s,r)=>{r==null&&(r=l2(t,e[0],s[0]));let a=[0,0,0,n];for(let i=0;i<3;i++)t[i]+2*r>=e[i]&&(a[i]=Math.trunc((t[i]-e[i]+2*r)/s[i]+1));return a},c2=(t,e,n,s,r,a,i,o,u,l)=>{let c,d,h,p;if(t==="VALID"&&(t=0),typeof t=="number"){c={top:t,bottom:t,left:t,right:t,front:t,back:t};let f=Ef([e,n,s,1],[o,u,l],1,[r,a,i],t);d=f[0],h=f[1],p=f[2]}else if(Array.isArray(t)){if(!t.every((m,g,y)=>m===y[0]))throw Error(`Unsupported padding parameter: ${t}`);c={top:t[0],bottom:t[1],left:t[2],right:t[3],front:t[4],back:t[5]};let f=Ef([e,n,s,1],[o,u,l],1,[r,a,i],t[0]);d=f[0],h=f[1],p=f[2]}else if(t==="SAME_UPPER"){d=Math.ceil(e/r),h=Math.ceil(n/a),p=Math.ceil(s/i);let f=(d-1)*r+o-e,m=(h-1)*a+u-n,g=(p-1)*i+l-s,y=Math.floor(f/2),b=f-y,$=Math.floor(m/2),w=m-$,v=Math.floor(g/2),k=g-v;c={top:$,bottom:w,left:v,right:k,front:y,back:b}}else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:c,outDepth:d,outHeight:h,outWidth:p}},CD=(t,e,n,s,r,a=!1,i="channelsLast")=>{let o,u,l,c,d;if(i==="channelsLast")[o,u,l,c,d]=t;else if(i==="channelsFirst")[o,d,u,l,c]=t;else throw new Error(`Unknown dataFormat ${i}`);let[h,,p,f,m]=e,[g,y,b]=Nf(n),[$,w,v]=Nf(s),k=Po(p,$),C=Po(f,w),N=Po(m,v),{padInfo:A,outDepth:I,outHeight:E,outWidth:z}=c2(r,u,l,c,g,y,b,k,C,N),P=a?h*d:h,H=[0,0,0,0,0];return i==="channelsFirst"?H=[o,P,I,E,z]:i==="channelsLast"&&(H=[o,I,E,z,P]),{batchSize:o,dataFormat:i,inDepth:u,inHeight:l,inWidth:c,inChannels:d,outDepth:I,outHeight:E,outWidth:z,outChannels:P,padInfo:A,strideDepth:g,strideHeight:y,strideWidth:b,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:k,effectiveFilterHeight:C,effectiveFilterWidth:N,dilationDepth:$,dilationHeight:w,dilationWidth:v,inShape:t,outShape:H,filterShape:e}},TD=(t,e,n,s,r,a)=>{let i=a==="channelsLast";i?t[0].dims[3]:t[0].dims[1];let o=[64,1,1],u={x:n.map((g,y)=>y)},l=[Math.ceil(u2(u.x.map(g=>n[g]))/o[0]),1,1];et("verbose",()=>`[conv3d_naive_webgpu] dispatch = ${l}`);let c=1,d=re.size(n),h=[{type:12,data:d},{type:12,data:s},{type:12,data:r},{type:12,data:e.strides},{type:12,data:e.dilations}];pi(e,h),h.push(...Ce(t[0].dims,t[1].dims));let p=["rank","rank"],f=t.length===3;f&&(h.push(...Ce(t[2].dims)),p.push("rank")),h.push(...Ce(n));let m=g=>{let y=[{name:"output_size",type:"u32"},{name:"filter_dims",type:"u32",length:s.length},{name:"pads",type:"u32",length:r.length},{name:"strides",type:"u32",length:e.strides.length},{name:"dilations",type:"u32",length:e.dilations.length}];fi(e,y);let b=1,$=sn(t[0].dataType),w=ue("x",t[0].dataType,t[0].dims.length,c),v=ue("W",t[1].dataType,t[1].dims.length,b),k=[w,v],C=ve("result",t[0].dataType,n.length,b),N="";if(f){let E=ue("bias",t[2].dataType,t[2].dims.length,b);k.push(E),N+=`
        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${$} {
          return bias[${i?Se("coords",4,5):Se("coords",1,5)}];
        }`}let A=un(c,$),I=hi(e,A,$);return`
            ${N}
            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${w.getByIndices("aIndices")};
            }
            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${v.getByIndices("aIndices")};
            }
          ${g.registerUniforms(y).declareVariables(...k,C)}
          ${g.mainStart()}
          ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
              let coords = ${C.offsetToIndices("global_idx")};
              let batch = ${Se("coords",0,w.rank)};
              let d2 = ${i?Se("coords",w.rank-1,w.rank):Se("coords",1,w.rank)};
              let xFRCCorner = vec3<u32>(${i?Se("coords",1,w.rank):Se("coords",2,w.rank)},
              ${i?Se("coords",2,w.rank):Se("coords",3,w.rank)},
              ${i?Se("coords",3,w.rank):Se("coords",4,w.rank)}) * uniforms.strides - uniforms.pads;
              let xFCorner = xFRCCorner.x;
              let xRCorner = xFRCCorner.y;
              let xCCorner = xFRCCorner.z;
              let xShapeY = ${i?Se("uniforms.x_shape",1,w.rank):Se("uniforms.x_shape",2,w.rank)};
              let xShapeZ = ${i?Se("uniforms.x_shape",2,w.rank):Se("uniforms.x_shape",3,w.rank)};
              let xShapeW = ${i?Se("uniforms.x_shape",3,w.rank):Se("uniforms.x_shape",4,w.rank)};
              let xShapeU = ${i?Se("uniforms.x_shape",4,w.rank):Se("uniforms.x_shape",1,w.rank)};
              let inputDepthNearestVec4 = (xShapeU / 4) * 4;
              let inputDepthVec4Remainder = xShapeU % 4;

              var value = 0.0;
              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {
                let xF = xFCorner + wF * uniforms.dilations[0];
                if (xF < 0 || xF >= xShapeY) {
                  continue;
                }

                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {
                  let xR = xRCorner + wR * uniforms.dilations[1];
                  if (xR < 0 || xR >= xShapeZ) {
                    continue;
                  }

                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {
                    let xC = xCCorner + wC * uniforms.dilations[2];
                    if (xC < 0 || xC >= xShapeW) {
                      continue;
                    }

                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {
                      ${i?`let xValues = vec4<f32>(
                               getX(batch, xF, xR, xC, d1),
                               getX(batch, xF, xR, xC, d1 + 1),
                               getX(batch, xF, xR, xC, d1 + 2),
                               getX(batch, xF, xR, xC, d1 + 3));
                            `:`let xValues = vec4<f32>(
                               getX(batch, d1, xF, xR, xC),
                               getX(batch, d1 + 1, xF, xR, xC),
                               getX(batch, d1 + 2, xF, xR, xC),
                               getX(batch, d1 + 3, xF, xR, xC));
                            `}
                            let wValues = vec4<f32>(
                              getW(d2, d1, wF, wR, wC),
                              getW(d2, d1 + 1, wF, wR, wC),
                              getW(d2, d1 + 2, wF, wR, wC),
                              getW(d2, d1 + 3, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                    if (inputDepthVec4Remainder == 1) {
                        ${i?`value += getX(batch, xF, xR, xC, inputDepthNearestVec4)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`:`value += getX(batch, inputDepthNearestVec4, xF, xR, xC)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`}
                    } else if (inputDepthVec4Remainder == 2) {
                      ${i?`let xValues = vec2<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));
                      `:`let xValues = vec2<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));
                    `}
                    let wValues = vec2<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));
                      value += dot(xValues, wValues);
                    } else if (inputDepthVec4Remainder == 3) {
                      ${i?`let xValues = vec3<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));
                      `:`let xValues = vec3<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));
                    `}
                    let wValues = vec3<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                  }
                }
              }
              ${f?"value = value + getBiasByOutputCoords(coords)":""};
              ${I}
              result[global_idx] = f32(value);
          }`};return{name:"Conv3DNaive",shaderCache:{hint:`${e.cacheKey};${i};${c};${f}`,inputDependencies:p},getRunData:()=>({outputs:[{dims:n,dataType:t[0].dataType}],dispatchGroup:{x:l[0],y:l[1],z:l[2]},programUniforms:h}),getShaderSource:m}}}),ND,ED,gle=he(()=>{De(),Be(),Me(),Ci(),ND=(t,e,n,s)=>{let r=t.length>2,a=r?"value += b[output_channel];":"",i=t[0].dims,o=t[1].dims,u=e.format==="NHWC",l=u?n[3]:n[1],c=l/e.group,d=u&&c>=4?Nt(l):1,h=re.size(n)/d,p=[{type:12,data:h},{type:12,data:e.dilations},{type:12,data:[e.strides[0],e.strides[1]]},{type:12,data:[e.pads[0],e.pads[1]]},{type:12,data:c}];pi(e,p),p.push(...Ce(i,[o[0],o[1],o[2],o[3]/d]));let f=r?["rank","rank","rank"]:["rank","rank"];p.push(...Ce([n[0],n[1],n[2],n[3]/d]));let m=g=>{let y=ve("output",t[0].dataType,n.length,d),b=sn(y.type.tensor),$=hi(e,y.type.value,b),w=ue("x",t[0].dataType,i.length),v=ue("w",t[1].dataType,o.length,d),k=[w,v];r&&k.push(ue("b",t[2].dataType,t[2].dims,d));let C=[{name:"output_size",type:"u32"},{name:"dilations",type:"u32",length:e.dilations.length},{name:"strides",type:"u32",length:2},{name:"pads",type:"u32",length:2},{name:"output_channels_per_group",type:"u32"}];fi(e,C);let N=u?`
      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {
            let input_channel = in_channel_offset + wInChannel;
            let xVal = ${w.get("batch","xHeight","xWidth","input_channel")};
            let wVal = ${v.get("wHeight","wWidth","wInChannel","output_channel")};
            value += xVal * wVal;
          }
        }
      }
      `:`
      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {
        let input_channel = in_channel_offset + wInChannel;
        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {
          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {
            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {
              continue;
            }

            let xVal = ${w.get("batch","input_channel","xHeight","xWidth")};
            let wVal = ${v.get("output_channel","wInChannel","wHeight","wWidth")};
            value += xVal * wVal;
          }
        }
      }
      `;return`
  ${g.registerUniforms(C).declareVariables(...k,y)}

  ${g.mainStart()}
    ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let outputIndices = ${y.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${u?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${u?1:2}], outputIndices[${u?2:3}]) * uniforms.strides - uniforms.pads;
    let group_id: u32 = output_channel * ${d} / uniforms.output_channels_per_group;
    var in_channel_offset = group_id * uniforms.w_shape[${u?2:1}];

    var value: ${y.type.value} = ${y.type.value}(0);
    ${N}
    ${a}
    ${$}
    ${y.setByOffset("global_idx","value")}
  }`};return{name:"GroupedConv",shaderCache:{hint:`${e.cacheKey}_${d}`,inputDependencies:f},getRunData:()=>({outputs:[{dims:s?s(n):n,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:p}),getShaderSource:m}},ED=(t,e,n,s)=>{let r=t.length>2,a=Nt(n[3]),i=Nt(n[2]),o=re.size(n)/a/i,u=[t[0].dims[0],t[0].dims[1],t[0].dims[2],t[0].dims[3]/a],l=[t[1].dims[0],t[1].dims[1],t[1].dims[2],t[1].dims[3]/a],c=[n[0],n[1],n[2],n[3]/a],d=[{type:12,data:o},{type:6,data:[e.strides[0],e.strides[1]]},{type:6,data:[e.pads[0],e.pads[1]]}];pi(e,d),d.push(...Ce(u,l,c));let h=(i-1)*e.strides[1]+l[1],p=f=>{let m=ve("output",t[0].dataType,c.length,a),g=sn(m.type.tensor),y=hi(e,m.type.value,g),b=ue("x",t[0].dataType,u.length,a),$=ue("w",t[1].dataType,l.length,a),w=[b,$];r&&w.push(ue("b",t[2].dataType,t[2].dims,a));let v=r?"value += b[output_channel];":"",k=[{name:"output_size",type:"u32"},{name:"strides",type:"i32",length:2},{name:"pads",type:"i32",length:2}];return fi(e,k),`
  ${f.registerUniforms(k).declareVariables(...w,m)}
  ${f.mainStart()}
    ${f.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let width0 = uniforms.output_shape[3];
    let output_channel = global_idx % width0;
    var index1 = global_idx / width0;
    let width1 = uniforms.output_shape[2] / ${i}u;
    let col = (index1 % width1) * ${i}u;
    index1 = index1 / width1;
    let row = index1 % uniforms.output_shape[1];
    let batch = index1 / uniforms.output_shape[1];

    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;

    var x_vals: array<${b.type.value}, ${h}>;
    var values: array<${m.type.value}, ${i}>;
    let input_channel = output_channel;
    // Use constant instead of uniform can give better performance for w's height/width.
    for (var w_height: u32 = 0u; w_height < ${l[0]}; w_height++) {
      let x_height = x_corner.x + i32(w_height);
      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {
        for (var i = 0; i < ${h}; i++) {
          let x_width = x_corner.y + i;
          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {
            x_vals[i] = ${b.get("batch","u32(x_height)","u32(x_width)","input_channel")};
          } else {
            x_vals[i] = ${b.type.value}(0);
          }
        }
        for (var w_width: u32 = 0u; w_width < ${l[1]}; w_width++) {
          let w_val = ${$.get("w_height","w_width","0","output_channel")};
          for (var i = 0u; i < ${i}u; i++) {
            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);
          }
        }
      }
    }

    for (var i = 0u; i < ${i}u; i++) {
      var value = values[i];
      ${v}
      ${y}
      ${m.set("batch","row","col + i","output_channel","value")};
    }
  }`};return{name:"GroupedConv-Vectorize",shaderCache:{hint:`${e.cacheKey};${a};${i};${h};${l[0]};${l[1]}`,inputDependencies:r?["rank","rank","type"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:s?s(n):n,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:d}),getShaderSource:p}}}),d2,bc,h2,xc,dg,Af,p2,f2,hg,yle=he(()=>{Be(),fle(),mle(),q0(),gle(),Ci(),H0(),ka(),d2=(t,e,n,s,r,a)=>{let i=t[0],o=t.slice(a?1:2,a?3:4),u=o.length,l=e[0],c=e.slice(2).map((h,p)=>h+(h-1)*(n[p]-1)),d=o.map((h,p)=>h+s[p]+s[p+u]).map((h,p)=>Math.floor((h-c[p]+r[p])/r[p]));return d.splice(0,0,i),d.splice(a?3:1,0,l),d},bc=[2,3,1,0],h2=(t,e)=>{if(!t||t.length!==2&&t.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(t[0].dims.length>5)throw new Error("greater than 5D is not supported");if(t[0].dims.length!==t[1].dims.length)throw new Error("filter does not have same dimension as input");let n=t[0].dims[e.format==="NHWC"?t[0].dims.length-1:1],s=t[1].dims[1]*e.group;if(n!==s)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(t.length===3&&(t[2].dims.length!==1||t[1].dims[0]!==t[2].dims[0]))throw new Error("invalid bias");let r=t[0].dims.length-2;if(e.dilations.length!==r)throw new Error(`dilations should be ${r}D`);if(e.strides.length!==r)throw new Error(`strides should be ${r}D`);if(e.pads.length!==r*2)throw new Error(`pads should be ${r*2}D`);if(e.kernelShape.length!==0&&e.kernelShape.length!==t[1].dims.length-2)throw new Error("invalid kernel shape")},xc=(t,e)=>{let n=t.kernelShape.slice();n.length<e[1].dims.length-2&&n.push(...Array(e[1].dims.length-2-n.length).fill(0));for(let a=2;a<e[1].dims.length;++a)n[a-2]===0&&(n[a-2]=e[1].dims[a]);let s=t.pads.slice();md.adjustPadsBasedOnAutoPad(e[0].dims,t.strides,t.dilations,n,s,t.format==="NHWC",t.autoPad);let r=Object.assign({},t);return Object.assign(r,{kernelShape:n,pads:s}),r},dg=t=>{let e=W0(t),n=t.format,s=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][t.auto_pad],r=t.dilations,a=t.group,i=t.kernel_shape,o=t.pads,u=t.strides,l=t.w_is_const();return{autoPad:s,format:n,dilations:r,group:a,kernelShape:i,pads:o,strides:u,wIsConst:l,...e,cacheKey:`${t.format};${e.activation};`}},Af=(t,e,n,s)=>{let r=n.format==="NHWC",a=d2(e[0].dims,e[1].dims,n.dilations,n.pads,n.strides,r);if(n.group!==1){let k=[e[0]];if(r){let C=t.kernelCustomData.wT??t.compute(ss(e[1],bc),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!t.kernelCustomData.wT&&(t.kernelCustomData.wT=C),k.push(C)}else k.push(e[1]);e.length===3&&k.push(e[2]),!t.adapterInfo.isArchitecture("ampere")&&r&&e[1].dims[0]===n.group&&e[1].dims[1]===1&&n.dilations[0]===1&&n.dilations[1]===1?t.compute(ED(k,n,a,s),{inputs:k}):t.compute(ND(k,n,a,s),{inputs:k});return}let i=e.length===3,o=e[0].dims[r?1:2],u=e[0].dims[r?2:3],l=e[0].dims[r?3:1],c=e[1].dims[2],d=e[1].dims[3],h=a[r?1:2],p=a[r?2:3],f=a[r?3:1],m=r&&c===o&&d===u&&n.pads[0]===0&&n.pads[1]===0;if(m||c===1&&d===1&&n.dilations[0]===1&&n.dilations[1]===1&&n.strides[0]===1&&n.strides[1]===1&&n.pads[0]===0&&n.pads[1]===0){let k=a[0],C,N,A,I=[];if(r){let P=t.kernelCustomData.wT??t.compute(ss(e[1],bc),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];if(n.wIsConst&&!t.kernelCustomData.wT&&(t.kernelCustomData.wT=P),m){let H=o*u*l;C=e[0].reshape([1,k,H]),N=P.reshape([1,H,f]),A=[1,k,f]}else C=e[0].reshape([k,o*u,l]),N=P.reshape([1,l,f]),A=[k,h*p,f];I.push(C),I.push(N)}else C=e[0].reshape([k,l,o*u]),N=e[1].reshape([1,f,l]),A=[k,f,h*p],I.push(N),I.push(C);i&&I.push(e[2]);let E=A[2],z=I[0].dims[I[0].dims.length-1];E<8&&z<8?t.compute(G0(I,n,a,A,r,s),{inputs:I}):t.compute(yd(I,n,a,A,r,s),{inputs:I});return}let g=!0,y=t.kernelCustomData.wT??t.compute(ss(e[1],bc),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!t.kernelCustomData.wT&&(t.kernelCustomData.wT=y);let b=[e[0],y];i&&b.push(e[2]);let $=r?h*p:f,w=r?f:h*p,v=c*d*l;t.compute(kD(b,n,a,$,w,v,i,g,s),{inputs:b})},p2=(t,e)=>{let n=e.format==="NHWC",s=[t.inputs[0].reshape(n?[t.inputs[0].dims[0],1,t.inputs[0].dims[1],t.inputs[0].dims[2]]:[t.inputs[0].dims[0],t.inputs[0].dims[1],1,t.inputs[0].dims[2]]),t.inputs[1].reshape([t.inputs[1].dims[0],t.inputs[1].dims[1],1,t.inputs[1].dims[2]])];t.inputs.length===3&&s.push(t.inputs[2]);let r=[0,e.pads[0],0,e.pads[1]],a=[1].concat(e.strides),i=[1].concat(e.dilations),o=[1].concat(e.kernelShape),u=xc({...e,pads:r,strides:a,dilations:i,kernelShape:o},s);Af(t,s,u,l=>n?[l[0],l[2],l[3]]:[l[0],l[1],l[3]])},f2=(t,e,n)=>{let s=n.format==="NHWC"?"channelsLast":"channelsFirst",r=xc(n,e),a=n.autoPad==="NOTSET"?n.pads:n.autoPad,i=CD(e[0].dims,e[1].dims,n.strides,n.dilations,a,!1,s);t.compute(TD(e,r,i.outShape,[i.filterDepth,i.filterHeight,i.filterWidth],[i.padInfo.front,i.padInfo.top,i.padInfo.left],s))},hg=(t,e)=>{if(h2(t.inputs,e),t.inputs[0].dims.length===3)p2(t,e);else if(t.inputs[0].dims.length===5)f2(t,t.inputs,e);else{let n=xc(e,t.inputs);Af(t,t.inputs,n)}}}),AD,ble=he(()=>{De(),Br(),Be(),Me(),AD=(t,e,n)=>{let s=t.length>2,r=e.outputShape,a=e.format==="NHWC",i=e.group,o=t[1].dims,u=o[2]/i,l=o[3],c=a?Nt(u):1,d=a&&l===1&&u>=4,h=d?Math.floor(u/4)*4:Math.floor(u/c)*c,p=u-h,f=a?Nt(l):1,m=a?l===1?c:f:1,g=re.size(r)/f,y=[Math.ceil(g/64),1,1];et("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${y}`);let b=["rank","rank"],$=[e.strides[0],e.strides[1]],w=[e.kernelShape[a?1:2],e.kernelShape[a?2:3]],v=[e.dilations[0],e.dilations[1]],k=[w[0]+(e.dilations[0]<=1?0:(e.kernelShape[a?1:2]-1)*(e.dilations[0]-1)),w[1]+(e.dilations[1]<=1?0:(e.kernelShape[a?2:3]-1)*(e.dilations[1]-1))],C=[k[0]-1-Math.floor((e.pads[0]+e.pads[2])/2),k[1]-1-Math.floor((e.pads[1]+e.pads[3])/2)],N=[{type:12,data:g},{type:12,data:$},{type:12,data:w},{type:12,data:v},{type:12,data:k},{type:6,data:C},{type:12,data:h},{type:12,data:u},{type:12,data:l},...Ce(t[0].dims,t[1].dims)];s&&(N.push(...Ce(t[2].dims)),b.push("rank")),N.push(...Ce(r));let A=I=>{let E=[{name:"output_size",type:"u32"},{name:"strides",type:"u32",length:$.length},{name:"filter_dims",type:"u32",length:w.length},{name:"dilations",type:"u32",length:w.length},{name:"effective_filter_dims",type:"u32",length:k.length},{name:"pads",type:"i32",length:C.length},{name:"input_channels_per_group_int",type:"u32"},{name:"input_channels_per_group",type:"u32"},{name:"output_channels_per_group",type:"u32"}],z=sn(t[0].dataType),P=a?1:2,H=a?2:3,G=a?3:1,W=ue("W",t[1].dataType,t[1].dims.length,m),L=ue("Dy",t[0].dataType,t[0].dims.length,c),B=[L,W];s&&B.push(ue("bias",t[2].dataType,[r[G]].length,f));let Y=ve("result",t[0].dataType,r.length,f),ne=()=>{let J="";if(d)c===4?J+=`
        let xValue = ${L.getByOffset("x_offset")};
        let wValue = ${W.getByOffset("w_offset")};
        dotProd = dotProd + dot(xValue, wValue);
        x_offset += 1u;
        w_offset += 1u;`:c===2?J+=`
          dotProd = dotProd + dot(vec4<${z}>(${L.getByOffset("x_offset")}, ${L.getByOffset("x_offset + 1u")}), vec4<${z}>(${W.getByOffset("w_offset")}, ${W.getByOffset("w_offset + 1u")}));
          x_offset += 2u;
          w_offset += 2u;`:c===1&&(J+=`
          dotProd = dotProd + dot(vec4<${z}>(${L.getByOffset("x_offset")}, ${L.getByOffset("x_offset + 1u")}, ${L.getByOffset("x_offset + 2u")}, ${L.getByOffset("x_offset + 3u")}), vec4<${z}>(${W.getByOffset("w_offset")}, ${W.getByOffset("w_offset + 1u")}, ${W.getByOffset("w_offset + 2u")}, ${W.getByOffset("w_offset + 3u")}));
          x_offset += 4u;
          w_offset += 4u;`);else if(J+=`
                  let xValue = ${a?L.getByOffset(`${L.indicesToOffset(`${L.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${c}`):L.get("batch","inputChannel","idyR","idyC")};
        `,c===1)J+=`
          let w_offset = ${W.indicesToOffset(`${W.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)};
          let wValue = ${W.getByOffset(`w_offset / ${m}`)};
          dotProd = dotProd + xValue * wValue;`;else for(let oe=0;oe<c;oe++)J+=`
            let wValue${oe} = ${W.getByOffset(`${W.indicesToOffset(`${W.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel + ${oe}, wOutChannel)`)} / ${m}`)};
            dotProd = dotProd + xValue[${oe}] * wValue${oe};`;return J},M=()=>{if(p===0)return"";if(!d)throw new Error(`packInputAs4 ${d} is not true.`);let J="";if(c===1){J+="dotProd = dotProd";for(let oe=0;oe<p;oe++)J+=`
            + ${L.getByOffset(`x_offset + ${oe}`)} * ${W.getByOffset(`w_offset + ${oe}`)}`;J+=";"}else if(c===2){if(p!==2)throw new Error(`Invalid inputChannelsRemainder ${p}.`);J+=`
          let xValue = ${L.getByOffset("x_offset")};
          let wValue = ${W.getByOffset("w_offset")};
          dotProd = dotProd + dot(xValue, wValue);`}return J},Z=`
            let outputIndices = ${Y.offsetToIndices(`global_idx * ${f}`)};
            let batch = ${Y.indicesGet("outputIndices",0)};
            let d1 = ${Y.indicesGet("outputIndices",G)};
            let r = ${Y.indicesGet("outputIndices",P)};
            let c = ${Y.indicesGet("outputIndices",H)};
            let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;
            let dyRCorner = dyCorner.x;
            let dyCCorner = dyCorner.y;
            let groupId = d1 / uniforms.output_channels_per_group;
            let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;
            // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
            // ? = to be determined. : = across all values in that axis.
            var dotProd = ${Y.type.value}(0.0);
            var wR: u32 = 0;
            if (uniforms.dilations.x == 1) {
              // Minimum wR >= 0 that satisfies (dyRCorner + wR) % (uniforms.strides.x) == 0
              wR = u32(((dyRCorner + i32(uniforms.strides.x) - 1) / i32(uniforms.strides.x)) * i32(uniforms.strides.x) - dyRCorner);
            }
            for (; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {
              if (wR % uniforms.dilations.x != 0) {
                continue;
              }
              let dyR = (${z}(dyRCorner) + ${z}(wR)) / ${z}(uniforms.strides[0]);
              let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;
              if (dyR < 0.0 || dyR >= ${z}(uniforms.Dy_shape[${P}]) || fract(dyR) > 0.0 ||
                  wRPerm < 0) {
                continue;
              }
              let idyR: u32 = u32(dyR);
              var wC: u32 = 0;
              if (uniforms.dilations.y == 1) {
                // Minimum wC >= 0 that satisfies (dyCCorner + wC) % (uniforms.strides.y) == 0
                wC = u32(((dyCCorner + i32(uniforms.strides.y) - 1) / i32(uniforms.strides.y)) * i32(uniforms.strides.y) - dyCCorner);
              }
              for (; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {
                if (wC % uniforms.dilations.y != 0) {
                  continue;
                }
                let dyC = (${z}(dyCCorner) + ${z}(wC)) / ${z}(uniforms.strides.y);
                let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;
                if (dyC < 0.0 || dyC >= ${z}(uniforms.Dy_shape[${H}]) ||
                    fract(dyC) > 0.0 || wCPerm < 0) {
                  continue;
                }
                let idyC: u32 = u32(dyC);
                var inputChannel = groupId * uniforms.input_channels_per_group;
                ${d?`
                var x_offset = ${L.indicesToOffset(`${L.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${c};
                var w_offset = ${W.indicesToOffset(`${W.type.indices}(wRPerm, wCPerm, inputChannel, wOutChannel)`)} / ${m};
                  `:""}
                for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group_int; d2 = d2 + ${d?4:c}) {
                  ${ne()}
                  inputChannel = inputChannel + ${d?4:c};
                }
                ${M()}
                wC = wC + uniforms.strides.y - 1;
              }
              wR = wR + uniforms.strides[0] - 1;
            }
            let value = dotProd${s?` + bias[d1 / ${f}]`:""};
            ${Y.setByOffset("global_idx","value")};
          `;return`
    ${I.registerUniforms(E).declareVariables(...B,Y)}
      ${I.mainStart()}
      ${I.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};
    ${Z}}`};return{name:"ConvTranspose2D",shaderCache:{hint:`${e.cacheKey};${c}${m}${f}${d}${p}`,inputDependencies:b},getRunData:()=>({dispatchGroup:{x:y[0],y:y[1],z:y[2]},outputs:[{dims:n?n(r):r,dataType:t[0].dataType}],programUniforms:N}),getShaderSource:A}}}),m2,g2,y2,Rf,RD,b2,Df,x2,DD,xle=he(()=>{ble(),Ci(),ka(),m2=(t,e,n,s,r,a)=>(t-1)*e+n+(s-1)*r+1-a,g2=(t,e,n,s,r)=>{let a=Math.floor(t/2);e==="SAME_UPPER"?(n[s]=a,n[r]=t-a):e==="SAME_LOWER"&&(n[s]=t-a,n[r]=a)},y2=(t,e,n,s,r,a,i,o,u,l)=>{let c=t.length-2,d=l.length===0;u.length<c&&u.push(...Array(c-u.length).fill(0));let h=t[0],p=e[o?3:1]*r;for(let f=0,m=t.length-c-(o?1:0);f<c;++f,++m){let g=t[m],y=d?g*i[f]:l[f],b=m2(g,i[f],a[f],e[m],n[f],y);g2(b,s,a,f,f+c),d&&l.push(i[f]*(g-1)+u[f]+(e[m]-1)*n[f]+1-a[f]-a[f+c])}l.splice(0,0,h),l.splice(o?3:1,0,p)},Rf=(t,e)=>{let n=t.kernelShape.slice();if(t.kernelShape.length===0||t.kernelShape.reduce((d,h)=>d*h,1)===0){n.length=0;for(let d=2;d<e[1].dims.length;++d)n.push(e[1].dims[d])}let s=t.format==="NHWC";n.splice(0,0,e[1].dims[0]),n.splice(s?3:1,0,e[1].dims[1]);let r=t.pads.slice(),a=t.outputShape.slice(),i=t.outputPadding.slice(),o=e[0].dims,u=t.dilations.slice();if(u.reduce((d,h)=>d+h,0)===0){let d=e[0].dims.length-2;u=new Array(d).fill(1)}let l=t.strides.slice();if(l.reduce((d,h)=>d+h,0)===0){let d=e[0].dims.length-2;l=new Array(d).fill(1)}y2(o,n,u,t.autoPad,t.group,r,l,s,i,a);let c=Object.assign({},t);return Object.assign(c,{kernelShape:n,pads:r,outputPadding:i,outputShape:a,dilations:u,strides:l}),c},RD=t=>{let e=W0(t),n=t.format,s=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof t.autoPad>"u"?0:t.autoPad],r=t.dilations,a=t.group,i=t.kernelShape,o=t.pads,u=t.strides,l=t.wIsConst(),c=t.outputPadding,d=t.outputShape;return{autoPad:s,format:n,dilations:r,group:a,kernelShape:i,outputPadding:c,outputShape:d,pads:o,strides:u,wIsConst:l,...e,cacheKey:`${t.format};${e.activation};`}},b2=(t,e)=>{if(!t||t.length!==2&&t.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(t[0].dims.length!==4&&t[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(t[0].dims.length!==t[1].dims.length)throw new Error("filter does not have same dimension as input");let n=t[0].dims[e.format==="NHWC"?t[0].dims.length-1:1],s=t[1].dims[0];if(n!==s)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let r=t[1].dims[1]*e.group;if(t.length===3&&(t[2].dims.length!==1||t[2].dims[0]!==r))throw new Error("invalid bias");let a=t[0].dims.length-2;if(e.dilations.reduce((i,o)=>i+o,0)>0&&e.dilations.length!==a)throw new Error(`dilations should be ${a}D`);if(e.strides.reduce((i,o)=>i+o,0)>0&&e.strides.length!==a)throw new Error(`strides should be ${a}D`);if(e.pads.reduce((i,o)=>i+o,0)>0&&e.pads.length!==a*2)throw new Error(`pads should be ${a*2}D`);if(e.outputPadding.length!==a&&e.outputPadding.length!==0)throw new Error(`output_padding should be ${a}D`);if(e.kernelShape.reduce((i,o)=>i+o,0)>0&&e.kernelShape.length!==0&&e.kernelShape.length!==t[1].dims.length-2)throw new Error("invalid kernel shape");if(e.outputShape.length!==0&&e.outputShape.length!==t[0].dims.length-2)throw new Error("invalid output shape")},Df=(t,e,n,s)=>{let r=t.kernelCustomData.wT??t.compute(ss(e[1],[2,3,0,1]),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!t.kernelCustomData.wT&&(t.kernelCustomData.wT=r);let a=[e[0],r];e.length===3&&a.push(e[2]),t.compute(AD(a,n,s),{inputs:a})},x2=(t,e)=>{let n=e.format==="NHWC",s=[t.inputs[0].reshape(n?[t.inputs[0].dims[0],1,t.inputs[0].dims[1],t.inputs[0].dims[2]]:[t.inputs[0].dims[0],t.inputs[0].dims[1],1,t.inputs[0].dims[2]]),t.inputs[1].reshape([t.inputs[1].dims[0],t.inputs[1].dims[1],1,t.inputs[1].dims[2]])];t.inputs.length===3&&s.push(t.inputs[2]);let r=e.kernelShape;(r.length===0||r[0]===0)&&(r=[t.inputs[1].dims[2]]);let a=e.dilations;(a.length===0||a[0]===0)&&(a=[1]);let i=e.strides;(i.length===0||i[0]===0)&&(i=[1]);let o=e.pads;o.length===0&&(o=[0,0]),o=[0,o[0],0,o[1]],i=[1].concat(i),a=[1].concat(a),r=[1].concat(r);let u=e.outputPadding;u=[0].concat(u);let l=Rf({...e,pads:o,strides:i,dilations:a,kernelShape:r,outputPadding:u},s);Df(t,s,l,c=>n?[c[0],c[2],c[3]]:[c[0],c[1],c[3]])},DD=(t,e)=>{if(b2(t.inputs,e),t.inputs[0].dims.length===3)x2(t,e);else{let n=Rf(e,t.inputs);Df(t,t.inputs,n)}}}),w2,OD,FD,wle=he(()=>{De(),Be(),Ot(),Me(),w2=(t,e,n,s)=>{let r=re.size(e),a=e.length,i=ue("input",t,a),o=ve("output",t,a),u=n.dataType===6?n.getInt32Array()[0]:Number(n.getBigInt64Array()[0]),l=re.normalizeAxis(u,a),c=d=>{let h=` i32(${i.indicesGet("inputIndices","uniforms.axis")}) `,p=Se("uniforms.input_shape","uniforms.axis",a),f=s.reverse?h+(s.exclusive?" + 1":""):"0",m=s.reverse?p:h+(s.exclusive?"":" + 1");return`
                ${d.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(i,o)}
                ${d.mainStart()}
                  ${d.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
                  var inputIndices = ${o.offsetToIndices("global_idx")};
                  var sum = ${o.type.value}(0);
                  let first : i32 = ${f};
                  let last : i32 = ${m};
                  for (var i : i32 = first; i < last; i++) {
                    ${i.indicesSet("inputIndices","uniforms.axis","u32(i)")};
                    sum = sum + ${i.getByIndices("inputIndices")};
                  }
                  ${o.setByOffset("global_idx","sum")};
                }`};return{name:"CumSum",shaderCache:{hint:s.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:e,dataType:t}],dispatchGroup:{x:Math.ceil(r/64)},programUniforms:[{type:12,data:r},{type:12,data:l},...Ce(e,e)]}),getShaderSource:c}},OD=(t,e)=>{let n=t.inputs[0].dims,s=t.inputs[0].dataType,r=t.inputs[1];t.compute(w2(s,n,r,e),{inputs:[0]})},FD=t=>{let e=t.exclusive===1,n=t.reverse===1;return lt({exclusive:e,reverse:n})}}),$2,v2,S2,zD,LD,$le=he(()=>{De(),Be(),Ot(),Me(),$2=t=>{if(!t||t.length!==1)throw new Error("DepthToSpace requires 1 input.");if(t[0].dims.length!==4)throw new Error("DepthToSpace requires 4D input.")},v2=(t,e,n,s)=>{let r=[];r.push(`fn perm(i: ${s.type.indices}) -> ${n.type.indices} {
    var a: ${n.type.indices};`);for(let a=0;a<e;++a)r.push(n.indicesSet("a",t[a],`i[${a}]`));return r.push("return a;}"),r.join(`
`)},S2=(t,e)=>{let n,s,r,a,i,o,u=e.format==="NHWC",l=e.blocksize,c=e.mode==="DCR";u?([n,s,r,a]=t.dims,i=c?[n,s,r,l,l,a/l**2]:[n,s,r,a/l**2,l,l],o=c?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([n,s,r,a]=[t.dims[0],t.dims[2],t.dims[3],t.dims[1]],i=c?[n,l,l,a/l**2,s,r]:[n,a/l**2,l,l,s,r],o=c?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let d=t.reshape(i),h=d.dims.length,p=t.dataType,f=ue("a",p,h),m=ve("output",p,h),g=y=>`
  ${y.registerUniform("output_size","u32").declareVariables(f,m)}

  ${v2(o,h,f,m)}

  ${y.mainStart()}
    ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${m.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${m.setByOffset("global_idx",f.getByIndices("aIndices"))}
  }`;return{name:"DepthToSpace",shaderCache:{hint:`${t.dims};${e.blocksize};${e.mode}`,inputDependencies:["rank"]},getRunData:y=>{let b=u?[n,s*l,r*l,a/l**2]:[n,a/l**2,s*l,r*l],$=re.size(b),w=d.dims,v=re.sortBasedOnPerm(w,o);return{outputs:[{dims:b,dataType:y[0].dataType}],dispatchGroup:{x:Math.ceil($/64)},programUniforms:[{type:12,data:$},...Ce(w,v)]}},getShaderSource:g}},zD=(t,e)=>{$2(t.inputs),t.compute(S2(t.inputs[0],e))},LD=t=>lt({blocksize:t.blocksize,mode:t.mode,format:t.format})}),wc,Bo,Of,I2,_2,k2,C2,Ff,T2,PD,BD,vle=he(()=>{De(),Be(),Ot(),Me(),wc="[a-zA-Z]|\\.\\.\\.",Bo="("+wc+")+",Of="^"+Bo+"$",I2="("+Bo+",)*"+Bo,_2="^"+I2+"$",k2=class{constructor(t=-1){this.symbolToIndices=new Map,this.inputIndex=t}addSymbol(t,e){let n=this.symbolToIndices.get(t);n===void 0?n=[e]:n.push(e),this.symbolToIndices.set(t,n)}},C2=class{constructor(t,e){var r;this.equation=e,this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[n,s]=e.includes("->")?e.split("->",2):[e,""];if(!n.match(RegExp(_2)))throw new Error("Invalid LHS term");if(n.split(",").forEach((a,i)=>{let o=t[i].dims.slice();if(!a.match(RegExp(Of)))throw new Error("Invalid LHS term");let u=this.processTerm(a,!0,o,i);this.lhs.push(u)}),s==="")s+=[...this.symbolToInfo.entries()].filter(([a,i])=>i.count===1||a==="...").map(([a])=>a).join("");else if(!s.match(RegExp(Bo)))throw new Error("Invalid RHS");(r=s.match(RegExp(wc,"g")))==null||r.forEach(a=>{if(a==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let i=this.symbolToInfo.get(a);if(i===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(i.dimValue)}}),this.rhs=this.processTerm(s,!1,this.outputDims)}addSymbol(t,e,n){let s=this.symbolToInfo.get(t);if(s!==void 0){if(s.dimValue!==e&&s.count!==1)throw new Error("Dimension mismatch");s.count++,s.inputIndices.push(n)}else s={count:1,dimValue:e,inputIndices:[n]};this.symbolToInfo.set(t,s)}processTerm(t,e,n,s=-1){let r=n.length,a=!1,i=[],o=0;if(!t.match(RegExp(Of))&&!e&&t!=="")throw new Error("Invalid LHS term");let u=t.match(RegExp(wc,"g")),l=new k2(s);return u==null||u.forEach((c,d)=>{if(c==="..."){if(a)throw new Error("Only one ellipsis is allowed per input term");a=!0;let h=r-u.length+1;if(h<0)throw new Error("Ellipsis out of bounds");if(i=n.slice(o,o+h),this.hasEllipsis){if(this.ellipsisDims.length!==i.length||this.ellipsisDims.toString()!==i.toString())throw new Error("Ellipsis dimensions mismatch")}else if(e)this.hasEllipsis=!0,this.ellipsisDims=i;else throw new Error("Ellipsis must be specified in the LHS");for(let p=0;p<i.length;p++){let f=String.fromCharCode(48+p);l.addSymbol(f,d+p),this.addSymbol(f,n[o++],s)}}else l.addSymbol(c,d+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(c,n[o++],s)}),l}},Ff=t=>t+"_max",T2=(t,e,n,s)=>{let r=t.map(l=>l.length).map((l,c)=>ue(`input${c}`,e,l)),a=re.size(s),i=ve("output",e,s.length),o=[...n.symbolToInfo.keys()].filter(l=>!n.rhs.symbolToIndices.has(l)),u=l=>{let c=[],d="var prod = 1.0;",h="var sum = 0.0;",p="sum += prod;",f=[],m=[],g=[],y=[],b=n.symbolToInfo.size===n.rhs.symbolToIndices.size;n.symbolToInfo.forEach((w,v)=>{var k;if(n.rhs.symbolToIndices.has(v)){let C=(k=n.rhs.symbolToIndices.get(v))==null?void 0:k[0];C!==void 0&&n.lhs.forEach((N,A)=>{if(w.inputIndices.includes(A)){let I=N.symbolToIndices.get(v);if(I===void 0)throw new Error("Invalid symbol error");I.forEach(E=>{c.push(`${r[A].indicesSet(`input${A}Indices`,E,i.indicesGet("outputIndices",C))}`)})}})}else n.lhs.forEach((C,N)=>{if(w.inputIndices.includes(N)){let A=C.symbolToIndices.get(v);if(A===void 0)throw new Error("Invalid symbol error");A.forEach(I=>{f.push(`${r[N].indicesSet(`input${N}Indices`,I,`${v}`)}`)}),y.push(`prod *= ${r[N].getByIndices(`input${N}Indices`)};`)}}),m.push(`for(var ${v}: u32 = 0; ${v} < uniforms.${Ff(v)}; ${v}++) {`),g.push("}")});let $=b?[...c,`let sum = ${r.map((w,v)=>w.getByIndices(`input${v}Indices`)).join(" * ")};`]:[...c,h,...m,...f,d,...y,p,...g];return`
            ${l.registerUniforms(o.map(w=>({name:`${Ff(w)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...r,i)}

            ${l.mainStart()}
            ${l.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
            var outputIndices = ${i.offsetToIndices("global_idx")};
            ${r.map((w,v)=>`var input${v}Indices: ${r[v].type.indices};`).join(`
`)}
            ${$.join(`
`)};
            ${i.setByOffset("global_idx","sum")};
          }`};return{name:"Einsum",shaderCache:{hint:n.equation,inputDependencies:t.map(()=>"rank")},getRunData:()=>{let l=o.filter(d=>n.symbolToInfo.has(d)).map(d=>{var h;return{type:12,data:((h=n.symbolToInfo.get(d))==null?void 0:h.dimValue)||0}});l.push({type:12,data:a});let c=t.map((d,h)=>[...Ce(d)]).reduce((d,h)=>d.concat(h),l);return c.push(...Ce(s)),{outputs:[{dims:s,dataType:e}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:c}},getShaderSource:u}},PD=(t,e)=>{let n=new C2(t.inputs,e.equation),s=n.outputDims,r=t.inputs.map((a,i)=>a.dims);t.compute(T2(r,t.inputs[0].dataType,n,s))},BD=t=>{let e=t.equation.replace(/\s+/g,"");return lt({equation:e})}}),N2,zf,E2,A2,MD,Sle=he(()=>{De(),Be(),Me(),N2=t=>{if(!t||t.length!==2)throw new Error("Expand requires 2 input.");let e=t[0].dims,n=Array.from(t[1].getBigInt64Array(),Number),s=n.length<e.length?0:n.length-e.length,r=e.length<n.length?0:e.length-n.length;for(;s<n.length&&r<e.length;++s,++r)if(n[s]!==e[r]&&n[s]!==1&&e[r]!==1)throw new Error("Expand requires shape to be broadcastable to input")},zf=(t,e)=>{let n=t.length-e.length,s=[];for(let r=0;r<n;++r)s.push(t[r]);for(let r=0;r<e.length;++r)s.push(e[r]===1?t[r+n]:e[r]);return s},E2=(t,e)=>t.length>e.length?zf(t,e):zf(e,t),A2=t=>{let e=t[0].dims,n=Array.from(t[1].getBigInt64Array(),Number),s=E2(e,n),r=t[0].dataType,a=r===9||re.size(e)===1,i=r===9||e.length>0&&e[e.length-1]%4===0?4:1,o=a||s.length>0&&s[s.length-1]%4===0?4:1,u=Math.ceil(re.size(s)/o),l=d=>{let h=ue("input",r,e.length,i),p=ve("output",r,s.length,o),f;if(r===9){let m=(g,y,b="")=>`
          let outputIndices${y} = ${p.offsetToIndices(`outputOffset + ${y}u`)};
          let offset${y} = ${h.broadcastedIndicesToOffset(`outputIndices${y}`,p)};
          let index${y} = offset${y} / 4u;
          let component${y} = offset${y} % 4u;
          ${g}[${y}] = ${b}(${h.getByOffset(`index${y}`)}[component${y}]);
        `;f=`
        let outputOffset = global_idx * ${o};
        var data = vec4<u32>(0);
        ${m("data",0,"u32")}
        ${m("data",1,"u32")}
        ${m("data",2,"u32")}
        ${m("data",3,"u32")}
        ${p.setByOffset("global_idx","data")}
      }`}else f=`
        let outputIndices = ${p.offsetToIndices(`global_idx * ${o}`)};
        let inputOffset = ${h.broadcastedIndicesToOffset("outputIndices",p)};
        let data = ${p.type.value}(${h.getByOffset(`inputOffset / ${i}`)});
        ${p.setByOffset("global_idx","data")}
      }`;return`
    ${d.registerUniform("vec_size","u32").declareVariables(h,p)}
    ${d.mainStart()}
    ${d.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
    ${f}`},c=[{type:12,data:u},...Ce(e,s)];return{name:"Expand",shaderCache:{hint:`${s.length};${i}${o}`,inputDependencies:["rank"]},getShaderSource:l,getRunData:()=>({outputs:[{dims:s,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:c})}},MD=t=>{N2(t.inputs),t.compute(A2(t.inputs),{inputs:[0]})}}),R2,VD,Ile=he(()=>{De(),Be(),Me(),V0(),R2=t=>{let e=t[0].dataType,n=re.size(t[0].dims),s=re.size(t[1].dims),r=s%4===0,a=i=>{let o=ue("x",e,[1],4),u=ue("bias",e,[1],4),l=ve("y",e,[1],4),c=[{name:"output_vec_size",type:"u32"},{name:"bias_size",type:"u32"}],d=p=>`
      let bias${p}_offset: u32 = (global_idx * 4 + ${p}) % uniforms.bias_size;
      let bias${p} = ${u.getByOffset(`bias${p}_offset / 4`)}[bias${p}_offset % 4];`,h=r?`
      let bias = ${u.getByOffset("global_idx % (uniforms.bias_size / 4)")};`:`${d(0)}${d(1)}${d(2)}${d(3)}
      let bias = ${o.type.value}(bias0, bias1, bias2, bias3);`;return`${i.registerUniforms(c).declareVariables(o,u,l)}

    ${og(vn(e))}

    ${i.mainStart(ao)}
      ${i.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}

      let x = ${o.getByOffset("global_idx")};
      ${h}
      let x_in = x + bias;
      ${l.setByOffset("global_idx",ug("x_in"))}
    }`};return{name:"FastGeluWithBias",shaderCache:{hint:`${r}`,inputDependencies:["type","type"]},getShaderSource:a,getRunData:i=>({outputs:[{dims:i[0].dims,dataType:i[0].dataType}],programUniforms:[{type:12,data:Math.ceil(n/4)},{type:12,data:s}],dispatchGroup:{x:Math.ceil(n/ao/4)}})}},VD=t=>{t.inputs.length<2||re.size(t.inputs[1].dims)===0?oD(t):t.compute(R2(t.inputs))}}),D2,O2,WD,UD,_le=he(()=>{De(),Be(),Ot(),Me(),D2=t=>{if(!t||t.length!==2)throw new Error("Gather requires 2 inputs.")},O2=(t,e)=>{let n=t[0].dims,s=t[1].dims,r=n.length,a=re.normalizeAxis(e.axis,r),i=n.slice(0);i.splice(a,1,...s);let o=n[a],u=t[0].dataType===9?4:1,l=Math.ceil(re.size(i)/u),c=[{type:12,data:l},{type:6,data:o},{type:12,data:a},...Ce(t[0].dims,t[1].dims,i)],d=h=>{let p=ue("data",t[0].dataType,t[0].dims.length,u),f=ue("inputIndices",t[1].dataType,t[1].dims.length),m=ve("output",t[0].dataType,i.length,u),g=b=>{let $=s.length,w=`var indicesIndices${b}  = ${f.type.indices}(0);`;for(let v=0;v<$;v++)w+=`${$>1?`indicesIndices${b}[${v}]`:`indicesIndices${b}`} = ${i.length>1?`outputIndices${b}[uniforms.axis + ${v}]`:`outputIndices${b}`};`;w+=`
          var idx${b} = ${f.getByIndices(`indicesIndices${b}`)};
          if (idx${b} < 0) {
            idx${b} = idx${b} + uniforms.axisDimLimit;
          }
          var dataIndices${b} : ${p.type.indices};
        `;for(let v=0,k=0;v<r;v++)v===a?(w+=`${r>1?`dataIndices${b}[${v}]`:`dataIndices${b}`} = u32(idx${b});`,k+=$):(w+=`${r>1?`dataIndices${b}[${v}]`:`dataIndices${b}`} = ${i.length>1?`outputIndices${b}[${k}]`:`outputIndices${b}`};`,k++);return w},y;if(t[0].dataType===9){let b=($,w,v="")=>`
          let outputIndices${w} = ${m.offsetToIndices(`outputOffset + ${w}u`)};
          ${g(w)};
          let offset${w} = ${p.indicesToOffset(`dataIndices${w}`)};
          let index${w} = offset${w} / 4u;
          let component${w} = offset${w} % 4u;
          ${$}[${w}] = ${v}(${p.getByOffset(`index${w}`)}[component${w}]);
        `;y=`
        let outputOffset = global_idx * ${u};
        var value = vec4<u32>(0);
        ${b("value",0,"u32")}
        ${b("value",1,"u32")}
        ${b("value",2,"u32")}
        ${b("value",3,"u32")}
        ${m.setByOffset("global_idx","value")}
      `}else y=`
      let outputIndices = ${m.offsetToIndices("global_idx")};
      ${g("")};
      let value = ${p.getByIndices("dataIndices")};
      ${m.setByOffset("global_idx","value")};
      `;return`
      ${h.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(p,f,m)}
      ${h.mainStart()}
        ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        ${y}
      }`};return{name:"Gather",shaderCache:{hint:e.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:i,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:c}),getShaderSource:d}},WD=t=>lt({axis:t.axis}),UD=(t,e)=>{let n=t.inputs;D2(n),t.compute(O2(t.inputs,e))}}),F2,GD,HD,kle=he(()=>{De(),Be(),Me(),F2=(t,e,n,s,r,a,i,o,u)=>{let l=[{type:12,data:a},{type:12,data:s},{type:12,data:r},{type:12,data:n},{type:12,data:i},{type:12,data:o},{type:12,data:u}],c=[a];l.push(...Ce(e.dims,c));let d=h=>{let p=ue("indices_data",e.dataType,e.dims.length),f=ve("input_slice_offsets_data",12,1,1),m=[p,f],g=[{name:"output_size",type:"u32"},{name:"batch_dims",type:"u32"},{name:"input_dims",type:"u32",length:r.length},{name:"sizes_from_slice_dims_data",type:"u32",length:n.length},{name:"num_slices_per_batch",type:"u32"},{name:"input_batch_stride",type:"u32"},{name:"num_slice_dims",type:"u32"}];return`
  ${h.registerUniforms(g).declareVariables(...m)}
  ${h.mainStart()}
    ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let batch_idx = global_idx / uniforms.num_slices_per_batch;
    let base_offset = batch_idx * uniforms.input_batch_stride;

    let slice_indices_base_offset = global_idx * uniforms.num_slice_dims;
    var relative_slice_offset = 0;
    for (var dim_idx = 0u; dim_idx < uniforms.num_slice_dims; dim_idx ++) {
      var index = i32(indices_data[dim_idx + slice_indices_base_offset].x);
      let input_dim_idx = uniforms.batch_dims + dim_idx;
      if (index < 0) {
        ${r.length===1?"index += i32(uniforms.input_dims);":"index += i32(uniforms.input_dims[input_dim_idx]);"}
      }
      ${n.length===1?"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data);":"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data[dim_idx]);"}
    }

    input_slice_offsets_data[global_idx] =  base_offset + u32(relative_slice_offset);
  }`};return t.compute({name:"computeSliceOffsets",shaderCache:{hint:`${r.length}_${n.length}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:c,dataType:t.inputs[1].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:l}),getShaderSource:d},{inputs:[e],outputs:[-1]})[0]},GD=(t,e)=>{let n=t.inputs,s=n[0].dims,r=n[0].dataType,a=n[1].dims,i=a[a.length-1],o=re.sizeToDimension(a,a.length-1),u=re.sizeFromDimension(s,e.batchDims+i),l=re.sizeToDimension(s,e.batchDims),c=re.sizeFromDimension(s,e.batchDims),d=o/l,h=new Array(i),p=u;for(let w=0;w<i;++w)h[i-1-w]=p,p*=s[e.batchDims+i-1-w];let f=F2(t,n[1],h,e.batchDims,s,o,d,c,i),m=e.batchDims+i;if(m>s.length)throw new Error("last dimension of indices must not be larger than rank of input tensor");let g=a.slice(0,-1).concat(s.slice(m)),y=re.size(g),b=[{type:12,data:y},{type:12,data:u},...Ce(n[0].dims,f.dims,g)],$=w=>{let v=ue("data",n[0].dataType,n[0].dims.length),k=ue("slice_offsets",12,f.dims.length),C=ve("output",n[0].dataType,g.length);return`
          ${w.registerUniform("output_size","u32").registerUniform("slice_size","u32").declareVariables(v,k,C)}
            ${w.mainStart()}
            ${w.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let slice_offset = slice_offsets[global_idx / uniforms.slice_size];
          output[global_idx] = data[u32(slice_offset) + global_idx % uniforms.slice_size];
        }`};t.compute({name:"GatherND",shaderCache:{hint:e.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:g,dataType:r}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:b}),getShaderSource:$},{inputs:[n[0],f]})},HD=t=>({batchDims:t.batch_dims,cacheKey:""})}),z2,L2,qD,jD,Cle=he(()=>{De(),Be(),Ot(),Me(),z2=(t,e)=>{if(t.length<3||t.length>4)throw new Error("GatherBlockQuantized requires 3 or 4 inputs.");let n=re.normalizeAxis(e.quantizeAxis,t[0].dims.length),s=e.blockSize,r=t[0],a=t[2],i=t.length===4?t[3]:void 0;if(a.dims.length!==r.dims.length||!r.dims.map((o,u)=>u===n?Math.ceil(o/s)===a.dims[u]:o===a.dims[u]).reduce((o,u)=>o&&u,!0))throw new Error("Scales must have the same rank as the input tensor and the dims should match except on gatherAxis.");if(i){if(i.dataType!==r.dataType)throw new Error("Zero point must have the same data type as the input tensor.");if(i.dims.length!==a.dims.length||!i.dims.map((o,u)=>o===a.dims[u]).reduce((o,u)=>o&&u,!0))throw new Error("Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis.")}},L2=(t,e)=>{let n=t[0].dims,s=t[1].dims,r=n.length,a=re.normalizeAxis(e.gatherAxis,r),i=re.normalizeAxis(e.quantizeAxis,r),o=n.slice(0);o.splice(a,1,...s);let u=re.size(o),l=t[2].dataType,c=t[0].dataType===22,d=[{type:12,data:u},{type:12,data:i},{type:12,data:a},{type:12,data:e.blockSize},...Ce(...t.map((p,f)=>p.dims),o)],h=p=>{let f=ue("data",t[0].dataType,t[0].dims.length),m=ue("inputIndices",t[1].dataType,t[1].dims.length),g=ue("scales",t[2].dataType,t[2].dims.length),y=t.length>3?ue("zeroPoint",t[3].dataType,t[3].dims.length):void 0,b=ve("output",l,o.length),$=[f,m,g];y&&$.push(y);let w=[{name:"output_size",type:"u32"},{name:"quantize_axis",type:"u32"},{name:"gather_axis",type:"u32"},{name:"block_size",type:"u32"}];return`
        ${p.registerUniforms(w).declareVariables(...$,b)}
        ${p.mainStart()}
        let output_indices = ${b.offsetToIndices("global_idx")};
        var indices_indices = ${m.type.indices}(0);
        ${s.length>1?`
          for (var i: u32 = 0; i < ${s.length}; i++) {
            let index = ${b.indicesGet("output_indices","uniforms.gather_axis + i")};
            ${m.indicesSet("indices_indices","i","index")};
          }`:`indices_indices = ${b.indicesGet("output_indices","uniforms.gather_axis")};`};
        var data_indices = ${f.type.indices}(0);
        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {
          let index = ${b.indicesGet("output_indices","i")};
          ${f.indicesSet("data_indices","i","index")};
        }
        var index_from_indices = ${m.getByIndices("indices_indices")};
        if (index_from_indices < 0) {
          index_from_indices += ${n[a]};
        }
        ${f.indicesSet("data_indices","uniforms.gather_axis","u32(index_from_indices)")};
        for (var i = uniforms.gather_axis + 1; i < ${o.length}; i++) {
          let index = ${b.indicesGet("output_indices",`i + ${s.length} - 1`)};
          ${f.indicesSet("data_indices","i","index")};
        }
        let data_offset = ${f.indicesToOffset("data_indices")};
        let data_index = data_offset % 8;
        // Convert 4-bit packed data to 8-bit packed data.
        let packed_4bit_quantized_data = ${f.getByOffset("data_offset / 8")};
        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;
        let quantized_data_vec = ${c?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_quantized_data));
        let quantized_data = quantized_data_vec[data_index / 2];
        var scale_indices = data_indices;
        let quantize_axis_index = ${g.indicesGet("data_indices","uniforms.quantize_axis")} / uniforms.block_size;
        ${g.indicesSet("scale_indices","uniforms.quantize_axis","quantize_axis_index")};
        var scale = ${g.getByIndices("scale_indices")};
        ${y?`
              let zero_point_indices = scale_indices;
              let zero_point_offset = ${y.indicesToOffset("zero_point_indices")};
              let zero_point_index = zero_point_offset % 8;
              let packed_4bit_zero_points = ${y.getByOffset("zero_point_offset / 8")};
              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;
              let zero_point_vec = ${c?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_zero_points));
              let zero_point = zero_point_vec[zero_point_index / 2];`:"var zero_point = 0"};
        let dequantized_data = ${vn(l)}(quantized_data - zero_point) * scale;
        ${b.setByOffset("global_idx","dequantized_data")};
    }`};return{name:"GatherBlockQuantized",shaderCache:{hint:`${e.cacheKey};${t.filter((p,f)=>f!==1).map(p=>p.dims.join("_")).join(";")}`,inputDependencies:Array.from({length:t.length},(p,f)=>"rank")},getRunData:()=>({outputs:[{dims:o,dataType:l}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:d}),getShaderSource:h}},qD=(t,e)=>{let n=t.inputs;z2(n,e),t.compute(L2(t.inputs,e))},jD=t=>lt({blockSize:t.blockSize,gatherAxis:t.gatherAxis,quantizeAxis:t.quantizeAxis})}),P2,B2,KD,XD,Tle=he(()=>{De(),Be(),Ot(),Me(),P2=t=>{if(!t||t.length!==2)throw new Error("GatherElements requires 2 inputs.");if(t[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(t[0].dims.length!==t[1].dims.length)throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`)},B2=(t,e)=>{let n=t[0].dims,s=t[0].dataType,r=n.length,a=t[1].dims,i=t[1].dataType,o=re.normalizeAxis(e.axis,r),u=n[o],l=a.slice(0),c=re.size(l),d=ue("input",s,r),h=ue("indicesInput",i,a.length),p=ve("output",s,l.length),f=[{type:12,data:c},{type:6,data:u},{type:12,data:o}];return f.push(...Ce(n,a,l)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:l,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:f}),getShaderSource:m=>`
      ${m.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(d,h,p)}
      ${m.mainStart()}
      ${m.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

      let outputIndices = ${p.offsetToIndices("global_idx")};

      var idx = ${h.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + uniforms.axisDimLimit;
      }
      var inputIndices = ${d.type.indices}(outputIndices);
      ${d.indicesSet("inputIndices","uniforms.axis","u32(idx)")};
      let value = ${d.getByIndices("inputIndices")};

      ${p.setByOffset("global_idx","value")};
  }`}},KD=t=>lt({axis:t.axis}),XD=(t,e)=>{let n=t.inputs;P2(n),t.compute(B2(t.inputs,e))}}),M2,V2,YD,ZD,Nle=he(()=>{De(),Be(),Me(),M2=t=>{if(!t)throw new Error("Input is missing");if(t.length<2||t.length>3)throw new Error("Invaid input number.");if(t.length===3&&t[2].dims.length>2)throw new Error("Invalid input shape of C");if(t[0].dataType!==t[1].dataType||t.length===3&&t[0].dataType!==t[2].dataType)throw new Error("Input types are mismatched")},V2=(t,e)=>{let n=t[0].dims.slice(),s=t[1].dims.slice(),[r,a,i]=KA.getShapeOfGemmResult(n,e.transA,s,e.transB,t.length===3?t[2].dims:void 0),o=[r,a];if(!o)throw new Error("Can't use gemm on the given tensors");let u=16,l=Math.ceil(a/u),c=Math.ceil(r/u),d=!0,h=re.size(o),p=[{type:12,data:d?l:h},{type:12,data:r},{type:12,data:a},{type:12,data:i},{type:1,data:e.alpha},{type:1,data:e.beta}],f=["type","type"];t.length===3&&(p.push(...Ce(t[2].dims)),f.push("rank")),p.push(...Ce(o));let m=y=>{let b="";e.transA&&e.transB?b="value += a[k * uniforms.M + m] * b[n * uniforms.K + k];":e.transA&&!e.transB?b="value += a[k * uniforms.M + m] * b[k * uniforms.N + n];":!e.transA&&e.transB?b="value += a[m * uniforms.K + k] * b[n * uniforms.K + k];":!e.transA&&!e.transB&&(b="value += a[m * uniforms.K + k] * b[k * uniforms.N + n];");let $=e.alpha===1?"":"value *= uniforms.alpha;",w=ue("a",t[0].dataType,t[0].dims),v=ue("b",t[1].dataType,t[1].dims),k=w.type.value,C=null,N=[w,v];t.length===3&&(C=ue("c",t[2].dataType,t[2].dims.length),N.push(C));let A=ve("output",t[0].dataType,o.length);N.push(A);let I=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}];return`
  ${y.registerUniforms(I).declareVariables(...N)}

  ${y.mainStart()}
    ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let m = global_idx / uniforms.N;
    let n = global_idx % uniforms.N;

    var value = ${k}(0);
    for (var k: u32 = 0u; k < uniforms.K; k++) {
      ${b}
    }

    ${$}
    ${C!=null?`let cOffset = ${C.broadcastedIndicesToOffset("vec2(m, n)",A)}; value += ${k}(uniforms.beta) * ${C.getByOffset("cOffset")};`:""}
    output[global_idx] = value;
  }`},g=y=>{let b=ue("a",t[0].dataType,t[0].dims),$=ue("b",t[1].dataType,t[1].dims),w=null,v=[b,$];t.length===3&&(w=ue("c",t[2].dataType,t[2].dims.length),v.push(w));let k=ve("output",t[0].dataType,o.length);v.push(k);let C=[{name:"num_tile_n",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}],N="",A="";e.transA&&e.transB?(A=`
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${b.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${$.type.value}(0);
      }
      `,N="value += tile_a[k][local_id.y] * tile_b[local_id.x][k];"):e.transA&&!e.transB?(A=`
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${b.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${$.type.value}(0);
      }
      `,N="value += tile_a[k][local_id.y] * tile_b[k][local_id.x];"):!e.transA&&e.transB?(A=`
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${b.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${$.type.value}(0);
      }
      `,N="value += tile_a[local_id.y][k] * tile_b[local_id.x][k];"):!e.transA&&!e.transB&&(A=`
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${b.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${$.type.value}(0);
      }
      `,N="value += tile_a[local_id.y][k] * tile_b[k][local_id.x];");let I=e.alpha===1?"":"value *= uniforms.alpha;";return`
  ${y.registerUniforms(C).declareVariables(...v)}
  var<workgroup> tile_a: array<array<${b.type.storage}, ${u}>, ${u}>;
  var<workgroup> tile_b: array<array<${$.type.storage}, ${u}>, ${u}>;
  ${y.mainStart([u,u,1])}
    let tile_col_start = (workgroup_index % uniforms.num_tile_n) * ${u};
    let tile_row_start = (workgroup_index / uniforms.num_tile_n) * ${u};
    let num_tiles = (uniforms.K - 1) / ${u} + 1;
    var k_start = 0u;
    var value = ${k.type.value}(0);
    for (var t: u32 = 0u; t < num_tiles; t++) {
      ${A}
      k_start = k_start + ${u};
      workgroupBarrier();

      for (var k: u32 = 0u; k < ${u}; k++) {
        ${N}
      }
      workgroupBarrier();
    }

    ${I}
    let m = tile_row_start + local_id.y;
    let n = tile_col_start + local_id.x;
    ${w!=null?`let cOffset = ${w.broadcastedIndicesToOffset("vec2(m, n)",k)}; value += ${k.type.value}(uniforms.beta) * ${w.getByOffset("cOffset")};`:""}
    if (m < uniforms.M && n < uniforms.N) {
      output[m * uniforms.N + n] = value;
    }
  }`};return d?{name:"GemmShared",shaderCache:{hint:`${e.cacheKey}`,inputDependencies:f},getRunData:()=>({outputs:[{dims:o,dataType:t[0].dataType}],dispatchGroup:{x:l*c},programUniforms:p}),getShaderSource:g}:{name:"Gemm",shaderCache:{hint:`${e.cacheKey}`,inputDependencies:f},getRunData:()=>({outputs:[{dims:o,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:p}),getShaderSource:m}},YD=t=>{let e=t.transA,n=t.transB,s=t.alpha,r=t.beta;return{transA:e,transB:n,alpha:s,beta:r,cacheKey:`${t.transA};${t.transB};${t.alpha===1}`}},ZD=(t,e)=>{M2(t.inputs),t.compute(V2(t.inputs,e))}}),rr,vr,Da,Oa,W2,U2,G2,H2,q2,j2,K2,X2,QD,JD,Ele=he(()=>{De(),Be(),Ot(),Me(),[rr,vr,Da,Oa]=[0,1,2,3],W2=t=>{if(t[0].dims.length!==4)throw new Error("only 4-D tensor is supported.");if(t[0].dims.length!==t[1].dims.length)throw new Error("input dimensions must be equal to grid dimensions");if(t[0].dims.length-2!==t[1].dims[t[1].dims.length-1])throw new Error(`last dimension of grid must be equal to ${t[0].dims.length-2}`);if(t[0].dims[0]!==t[1].dims[0])throw new Error("grid batch size must match input batch size")},U2=`
  fn gs_get_cubic_coeffs(x: f32) -> vec4<f32> {
    let cubic_alpha = -0.75f;
    let x_abs = abs(x);
    var coeffs: vec4<f32>;
    coeffs[0] = (((cubic_alpha * (x_abs + 1) - 5 * cubic_alpha) * (x_abs + 1) + 8 * cubic_alpha) * (x_abs + 1) - 4 * cubic_alpha);
    coeffs[1] = (((cubic_alpha + 2) * x_abs - (cubic_alpha + 3)) * x_abs * x_abs + 1);
    coeffs[2] = (((cubic_alpha + 2) * (1 - x_abs) - (cubic_alpha + 3)) * (1 - x_abs) * (1 - x_abs) + 1);
    coeffs[3] = (((cubic_alpha * (2 - x_abs) - 5 * cubic_alpha) * (2 - x_abs) + 8 * cubic_alpha) * (2 - x_abs) - 4 * cubic_alpha);
    return coeffs;
  }
`,G2=t=>`
  fn gs_bicubic_interpolate(p: mat4x4<${t}>, x: f32, y: f32) -> ${t} {
    var v: vec4<f32>;
    var coeffs = gs_get_cubic_coeffs(x);
    for (var i = 0; i < 4; i++) {
      v[i] = coeffs[0] * p[i][0] + coeffs[1] * p[i][1] + coeffs[2] * p[i][2] + coeffs[3] * p[i][3];
    }
    coeffs = gs_get_cubic_coeffs(y);
    let pixel = ${t}(coeffs[0] * v[0] + coeffs[1] * v[1] + coeffs[2] * v[2] + coeffs[3] * v[3]);
    return pixel;
  }
`,H2=t=>`
  fn gs_denormalize(n: f32, length: i32) -> f32 {
    ${t.alignCorners===0?`
    // alignCorners: false => [-1, 1] to [-0.5, length - 0.5]
    return ((n + 1.0) * f32(length) - 1.0) / 2.0;
    `:`
    // alignCorners: true => [-1, 1] to [0, length - 1]
    return (n + 1.0) / 2.0 * (f32(length - 1));
    `}
  }
`,q2=t=>`
  ${t.paddingMode==="reflection"?`
      fn gs_reflect(x: i32, x_min: f32, x_max: f32) -> u32 {
        var dx = 0.0;
        var fx = f32(x);
        let range = x_max - x_min;
        if (fx < x_min) {
          dx = x_min - fx;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_min + r;
          } else {
            fx = x_max - r;
          }
        } else if (fx > x_max) {
          dx = fx - x_max;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_max - r;
          } else {
            fx = x_min + r;
          }
        }
        return u32(fx);
      }`:""}
`,j2=(t,e,n)=>`
  fn pixel_at_grid(r: i32, c: i32, H: i32, W: i32, batch: u32, channel: u32, border: vec4<f32>) -> ${e} {
     var pixel = ${e}(0);
     var indices = vec4<u32>(0);
     indices[${rr}] = batch;
     indices[${vr}] = channel;`+(()=>{switch(n.paddingMode){case"zeros":return`
          if (r >= 0 && r < H && c >=0 && c < W) {
            indices[${Da}] = u32(r);
            indices[${Oa}] = u32(c);
          } else {
            return ${e}(0);
          }
        `;case"border":return`
          indices[${Da}] = u32(clamp(r, 0, H - 1));
          indices[${Oa}] = u32(clamp(c, 0, W - 1));
        `;case"reflection":return`
          indices[${Da}] = gs_reflect(r, border[1], border[3]);
          indices[${Oa}] = gs_reflect(c, border[0], border[2]);
        `;default:throw new Error(`padding mode ${n.paddingMode} is not supported`)}})()+`
    return ${t.getByIndices("indices")};
  }
`,K2=(t,e,n)=>(()=>{switch(n.mode){case"nearest":return`
          let result = pixel_at_grid(i32(round(y)), i32(round(x)), H_in, W_in, indices[${rr}], indices[${vr}], border);
        `;case"bilinear":return`
          let x1 = i32(floor(x));
          let y1 = i32(floor(y));
          let x2 = x1 + 1;
          let y2 = y1 + 1;

          let p11 = pixel_at_grid(y1, x1, H_in, W_in, indices[${rr}], indices[${vr}], border);
          let p12 = pixel_at_grid(y1, x2, H_in, W_in, indices[${rr}], indices[${vr}], border);
          let p21 = pixel_at_grid(y2, x1, H_in, W_in, indices[${rr}], indices[${vr}], border);
          let p22 = pixel_at_grid(y2, x2, H_in, W_in, indices[${rr}], indices[${vr}], border);

          let dx2 = ${e}(f32(x2) - x);
          let dx1 = ${e}(x - f32(x1));
          let dy2 = ${e}(f32(y2) - y);
          let dy1 = ${e}(y - f32(y1));
          let result = dy2 * (dx2 * p11 + dx1 * p12) + dy1 * (dx2 * p21 + dx1 * p22);
        `;case"bicubic":return`
          let x0 = i32(floor(x)) - 1;
          let y0 = i32(floor(y)) - 1;
          var p: mat4x4<${e}>;
          for (var h = 0; h < 4; h++) {
            for (var w = 0; w < 4; w++) {
              p[h][w] = pixel_at_grid(h + y0, w + x0, H_in, W_in, indices[${rr}], indices[${vr}], border);
            }
          }

          let dx = x - f32(x0 + 1);
          let dy = y - f32(y0 + 1);
          let result = gs_bicubic_interpolate(p, dx, dy);
        `;default:throw new Error(`mode ${n.mode} is not supported`)}})()+`${t.setByOffset("global_idx","result")}`,X2=(t,e)=>{let n=ue("x",t[0].dataType,t[0].dims.length),s=[t[1].dims[0],t[1].dims[1],t[1].dims[2]],r=ue("grid",t[1].dataType,s.length,2),a=[t[0].dims[0],t[0].dims[1],t[1].dims[1],t[1].dims[2]];e.format==="NHWC"&&(a=[t[0].dims[0],t[1].dims[1],t[1].dims[2],t[0].dims[3]],[rr,vr,Da,Oa]=[0,3,1,2]);let i=ve("output",t[0].dataType,a.length),o=n.type.value,u=re.size(a),l=[{type:12,data:u},...Ce(t[0].dims,s,a)],c=d=>`
  ${d.registerUniform("output_size","u32").declareVariables(n,r,i)}
  ${U2}
  ${G2(o)}
  ${H2(e)}
  ${q2(e)}
  ${j2(n,o,e)}

  ${d.mainStart()}
    ${d.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let H_in = i32(uniforms.x_shape[${Da}]);
      let W_in = i32(uniforms.x_shape[${Oa}]);

      ${e.alignCorners===0?`
      let x_min = -0.5;
      let x_max = f32(W_in) - 0.5;
      let y_min = -0.5;
      let y_max = f32(H_in) - 0.5;
      `:`
      let x_min = 0.0;
      let x_max = f32(W_in) - 1.0;
      let y_min = 0.0;
      let y_max = f32(H_in) - 1.0;
      `};
      let border = vec4<f32>(x_min, y_min, x_max, y_max);

      let indices = ${i.offsetToIndices("global_idx")};
      var grid_indices = vec3<u32>(indices[${rr}], indices[${Da}], indices[${Oa}]);
      let nxy = ${r.getByIndices("grid_indices")};
      var x = gs_denormalize(f32(nxy[0]), W_in);
      var y = gs_denormalize(f32(nxy[1]), H_in);

      ${K2(i,o,e)}
  }`;return{name:"GridSample",shaderCache:{hint:`${e.cacheKey}`,inputDependencies:["type","type"]},getRunData:d=>{let h=re.size(a);return{outputs:[{dims:a,dataType:d[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:l}},getShaderSource:c}},QD=(t,e)=>{W2(t.inputs),t.compute(X2(t.inputs,e))},JD=t=>lt({alignCorners:t.align_corners,mode:t.mode,paddingMode:t.padding_mode,format:t.format})}),An,Y2,eO,Lf,Z2,Jo,tO,nO=he(()=>{De(),Be(),Ot(),L0(),M0(),Me(),ka(),An=(t,e)=>t.length>e&&t[e].dims.length>0?t[e]:void 0,Y2=(t,e)=>{let n=t[0],s=An(t,1),r=An(t,2),a=An(t,3),i=An(t,4),o=An(t,5),u=An(t,6),l=An(t,7);if(n.dims.length!==3&&n.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let c=n.dims[0],d=n.dims[1],h=n.dims.length===3?n.dims[2]:e.numHeads*n.dims[4],p=d,f=0,m=0,g=Math.floor(h/e.numHeads);if(u&&l&&re.size(u.dims)&&re.size(l.dims)){if(u.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(u.dims[0]!==c||u.dims[1]!==e.numHeads||u.dims[3]!==g)throw new Error('Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)');if(l.dims[0]!==c||l.dims[1]!==e.numHeads||l.dims[3]!==g)throw new Error('Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)');if(u.dims[2]!==l.dims[2])throw new Error('Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)');if(l.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');f=u.dims[2],m=u.dims[2]}else if(u&&re.size(u.dims)||l&&re.size(l.dims))throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let y;if(s&&re.size(s.dims)>0){if(n.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(s.dims.length<3||s.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(n.dims[0]!==s.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(s.dims.length===3){if(s.dims[2]!==n.dims[2])throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');y=2,p=s.dims[1]}else if(s.dims.length===5){if(s.dims[2]!==e.numHeads||s.dims[3]!==2||s.dims[4]!==g)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(r)throw new Error('Expect "value" be none when "key" has packed kv format.');y=5,p=s.dims[1]}else{if(s.dims[1]!==e.numHeads||s.dims[3]!==g)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');y=0,p=s.dims[2]}}else{if(n.dims.length!==5)throw new Error('Input "query" is expected to have 5 dimensions when key is empty');if(n.dims[2]!==e.numHeads||n.dims[3]!==3)throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');y=3}if(a&&re.size(a.dims)>0){if(a.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimension');if(s&&s.dims.length===5&&s.dims[3]===2)throw new Error("bias is not allowed for packed kv.")}let b=f+p,$=0;if(i&&re.size(i.dims)>0){$=8;let C=i.dims;throw C.length===1?C[0]===c?$=1:C[0]===3*c+2&&($=3):C.length===2&&C[0]===c&&C[1]===b&&($=5),$===8?new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, total_sequence_length)'):new Error("Mask not supported")}let w=!1,v=h;if(r&&re.size(r.dims)>0){if(r.dims.length!==3&&r.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(n.dims[0]!==r.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(r.dims.length===3){if(p!==r.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');v=r.dims[2]}else{if(p!==r.dims[2])throw new Error('Input "key" and "value" shall have the same dim 2 (kv_sequence_length)');v=r.dims[1]*r.dims[3],w=!0}}let k=!1;if(i&&re.size(i.dims)>0)throw new Error("Key padding mask is not supported");if(o&&re.size(o.dims)>0){if(o.dims.length!==4)throw new Error('Input "attention_bias" is expected to have 4 dimensions');if(o.dims[0]!==c||o.dims[1]!==e.numHeads||o.dims[2]!==d||o.dims[3]!==b)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:c,sequenceLength:d,pastSequenceLength:f,kvSequenceLength:p,totalSequenceLength:b,maxSequenceLength:m,inputHiddenSize:0,hiddenSize:h,vHiddenSize:v,headSize:g,vHeadSize:Math.floor(v/e.numHeads),numHeads:e.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:e.maskFilterValue,maskType:$,scale:e.scale,broadcastResPosBias:k,passPastInKv:w,qkvFormat:y}},eO=t=>lt({...t}),Lf=lt({perm:[0,2,1,3]}),Z2=(t,e,n,s,r,a,i)=>{let o=[s,r,a],u=re.size(o),l=[{type:12,data:u},{type:12,data:i},{type:12,data:a}],c=d=>{let h=ve("qkv_with_bias",e.dataType,o),p=ue("qkv",e.dataType,o),f=ue("bias",n.dataType,o),m=[{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}];return`
  ${d.registerUniforms(m).declareVariables(p,f,h)}
  ${d.mainStart()}
    ${d.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];
  }`};return t.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:o,dataType:e.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:l}),getShaderSource:c},{inputs:[e,n],outputs:[-1]})[0]},Jo=(t,e,n,s,r,a,i,o)=>{let u=a;if(i&&re.size(i.dims)>0){if(s===1)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return u=Z2(t,a,i,e,s,n*r,o),u=u.reshape([e,s,n,r]),n===1||s===1?u:t.compute(ss(u,Lf.perm),{inputs:[u],outputs:[-1]})[0]}else return a.dims.length===3&&(u=a.reshape([e,s,n,r])),n===1||s===1?u:t.compute(ss(u,Lf.perm),{inputs:[u],outputs:[-1]})[0]},tO=(t,e)=>{let n=Y2(t.inputs,e),s=t.inputs[0],r=An(t.inputs,1),a=An(t.inputs,2),i=An(t.inputs,3),o=An(t.inputs,4),u=An(t.inputs,5),l=An(t.inputs,6),c=An(t.inputs,7);if(s.dims.length===5)throw new Error("Packed QKV is not implemented");if((r==null?void 0:r.dims.length)===5)throw new Error("Packed KV is not implemented");let d=r&&a&&r.dims.length===4&&a.dims.length===4,h=Jo(t,n.batchSize,n.numHeads,n.sequenceLength,n.headSize,s,i,0);if(d)return xu(t,h,r,a,o,void 0,l,c,u,n);if(!r||!a)throw new Error("key and value must be provided");let p=Jo(t,n.batchSize,n.numHeads,n.kvSequenceLength,n.headSize,r,i,n.hiddenSize),f=Jo(t,n.batchSize,n.numHeads,n.kvSequenceLength,n.vHeadSize,a,i,2*n.hiddenSize);xu(t,h,p,f,o,void 0,l,c,u,n)}}),Q2,J2,eS,tS,pg,sO,rO,aO=he(()=>{De(),Be(),Ot(),Me(),Q2=t=>{if(!t||t.length<1)throw new Error("too few inputs")},J2=(t,e)=>{let n=[],s=e.numOutputs;return t[1].dims[0]>0&&(t[1].getBigInt64Array().forEach(r=>n.push(Number(r))),s=n.length),lt({numOutputs:s,axis:e.axis,splitSizes:n})},eS=t=>`
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${t}u; i += 1u ) {
    if (index < ${Se("uniforms.size_in_split_axis","i",t)}) {
        return i;
    }
    }
    return ${t}u;
}`,tS=t=>{let e=t.length,n=[];for(let s=0;s<e;++s){let r=t[s].setByIndices("indices","input[global_idx]");e===1?n.push(r):s===0?n.push(`if (output_number == ${s}u) { ${r} }`):s===e-1?n.push(`else { ${r} }`):n.push(`else if (output_number == ${s}) { ${r} }`)}return`
      fn writeBufferData(output_number: u32, indices: ${t[0].type.indices}, global_idx: u32) {
        ${n.join(`
`)}
      }`},pg=(t,e)=>{let n=t[0].dims,s=re.size(n),r=t[0].dataType,a=re.normalizeAxis(e.axis,n.length),i=new Array(e.numOutputs),o=ue("input",r,n.length),u=new Array(e.numOutputs),l=[],c=[],d=0,h=[{type:12,data:s}];for(let f=0;f<e.numOutputs;f++){d+=e.splitSizes[f],u[f]=d;let m=n.slice();m[a]=e.splitSizes[f],c.push(m),i[f]=ve(`output${f}`,r,m.length),l.push({dims:c[f],dataType:t[0].dataType})}h.push({type:12,data:u},...Ce(n,...c));let p=f=>`
  ${f.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",u.length).declareVariables(o,...i)}
  ${eS(u.length)}
  ${tS(i)}

  ${f.mainStart()}
    ${f.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}

    var indices = ${o.offsetToIndices("global_idx")};
    var index = ${o.indicesGet("indices",a)};
    let output_number = calculateOutputIndex(index);
    if (output_number != 0) {
      index -= ${Se("uniforms.size_in_split_axis","output_number - 1u",u.length)};
      ${o.indicesSet("indices",a,"index")};
    }
    writeBufferData(output_number, indices, global_idx);
  }`;return{name:"Split",shaderCache:{hint:e.cacheKey,inputDependencies:["rank"]},getShaderSource:p,getRunData:()=>({outputs:l,dispatchGroup:{x:Math.ceil(s/64)},programUniforms:h})}},sO=(t,e)=>{Q2(t.inputs);let n=t.inputs.length===1?e:J2(t.inputs,e);t.compute(pg(t.inputs,n),{inputs:[0]})},rO=t=>{let e=t.axis,n=t.splitSizes,s=t.numOutputs<0?n.length:t.numOutputs;if(s!==n.length)throw new Error("numOutputs and splitSizes length must be equal");return lt({axis:e,numOutputs:s,splitSizes:n})}}),nS,bd,iO,oO=he(()=>{De(),Be(),Ot(),Me(),nS=(t,e)=>{let[n,s,r,a]=t,{numHeads:i,rotaryEmbeddingDim:o}=e;if(n.dims.length!==3&&n.dims.length!==4)throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${n.dims.length}`);if(!re.areEqual(s.dims,[])&&!re.areEqual(s.dims,[1])&&s.dims.length!==2)throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${s.dims.length}`);if(r.dims.length!==2)throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${r.dims.length}`);if(a.dims.length!==2)throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${a.dims.length}`);if(!re.areEqual(r.dims,a.dims))throw new Error("Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape");if(o>0&&i===0)throw new Error("num_heads must be provided if rotary_embedding_dim is specified");let u=n.dims[0],l=n.dims[n.dims.length-2],c=r.dims[0],d=re.sizeFromDimension(n.dims,1)/l,h=o===0?r.dims[1]*2:d/i;if(o>h)throw new Error("rotary_embedding_dim must be less than or equal to head_size");if(s.dims.length===2){if(u!==s.dims[0])throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${s.dims[0]}`);if(l!==s.dims[1])throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${s.dims[1]}`)}if(h/2!==r.dims[1]&&o/2!==r.dims[1])throw new Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${r.dims[1]}`);if(l>c)throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported")},bd=(t,e)=>{let{interleaved:n,numHeads:s,rotaryEmbeddingDim:r,scale:a}=e,i=t[0].dims[0],o=re.sizeFromDimension(t[0].dims,1),u=t[0].dims[t[0].dims.length-2],l=o/u,c=t[2].dims[1],d=r===0?c*2:l/s,h=new Array(i,u,l/d,d-c),p=re.computeStrides(h),f=[{type:1,data:a},{type:12,data:h},{type:12,data:p},...t[0].dims.length===3?new Array({type:12,data:[o,l,d,1]}):[],...t[0].dims.length===4?new Array({type:12,data:[o,d,u*d,1]}):[],...Ce(t[0].dims,t[1].dims,t[2].dims,t[3].dims,t[0].dims)],m=g=>{let y=ue("input",t[0].dataType,t[0].dims.length),b=ue("position_ids",t[1].dataType,t[1].dims.length),$=ue("cos_cache",t[2].dataType,t[2].dims.length),w=ue("sin_cache",t[3].dataType,t[3].dims.length),v=ve("output",t[0].dataType,t[0].dims.length);return g.registerUniforms([{name:"scale",type:"f32"},{name:"global_shape",type:"u32",length:h.length},{name:"global_strides",type:"u32",length:p.length},{name:"input_output_strides",type:"u32",length:p.length}]),`
        ${g.declareVariables(y,b,$,w,v)}

        ${g.mainStart(ao)}
          let half_rotary_emb_dim = uniforms.${$.name}_shape[1];
          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;
          let size = uniforms.global_shape[0] * uniforms.global_strides[0];
          ${g.guardAgainstOutOfBoundsWorkgroupSizes("size")}

          if (bsnh[3] < half_rotary_emb_dim) {
            let position_ids_idx =
                ${b.broadcastedIndicesToOffset("bsnh.xy",ve("",b.type.tensor,2))};
            let position_id =
                u32(${b.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);
            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${n});
            let j = i + select(half_rotary_emb_dim, 1, ${n});
            let re = ${y.getByOffset("i")} * ${$.get("position_id","bsnh[3]")} -
                ${y.getByOffset("j")} * ${w.get("position_id","bsnh[3]")};
            ${v.setByOffset("i","re")}
            let im = ${y.getByOffset("i")} * ${w.get("position_id","bsnh[3]")} +
                ${y.getByOffset("j")} * ${$.get("position_id","bsnh[3]")};
            ${v.setByOffset("j","im")}
          } else {
            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;
            ${v.setByOffset("k",y.getByOffset("k"))}
          }
        }`};return{name:"RotaryEmbedding",shaderCache:{hint:lt({interleaved:n}).cacheKey,inputDependencies:["rank","rank","rank","rank"]},getShaderSource:m,getRunData:()=>({outputs:[{dims:t[0].dims,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(re.size(h)/ao)},programUniforms:f})}},iO=(t,e)=>{nS(t.inputs,e),t.compute(bd(t.inputs,e))}}),sS,rS,Pf,aS,uO,Ale=he(()=>{Ot(),De(),M0(),nO(),aO(),ka(),oO(),Me(),sS=(t,e)=>{if(e.doRotary&&t.length<=7)throw new Error("cos_cache and sin_cache inputs are required if do_rotary is specified");let n=t[0],s=t[1],r=t[2],a=t[3],i=t[4];if(e.doRotary!==0&&t.length<=7)throw new Error("cos_cast and sin_cache are expected if do_rotary attribute is non-zero");if(e.localWindowSize!==-1)throw new Error("Local attention is not supported");if(e.softcap!==0)throw new Error("Softcap is not supported");if(e.rotaryInterleaved!==0)throw new Error("Rotary interleaved is not supported");if(e.smoothSoftmax)throw new Error("Smooth softmax is not supported");if(n.dims.length!==3&&n.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let o=!1,u=n.dims[0],l=n.dims[1],c=n.dims.length===3?o?n.dims[2]/3:n.dims[2]:e.numHeads*n.dims[4],d=l,h=0,p=!s||s.dims.length===0,f=Math.floor(p?c/(e.numHeads+2*e.kvNumHeads):c/e.numHeads);p&&(c=f*e.numHeads);let m=a&&a.dims.length!==0,g=i&&i.dims.length!==0;if(m&&a.dims.length===4&&a.dims[0]===u&&a.dims[1]!==e.kvNumHeads&&a.dims[2]===e.kvNumHeads&&a.dims[3]===f)throw new Error("BSNH pastKey/pastValue is not supported");if(m&&g){if(a.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(i.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');h=a.dims[2]}else if(m||g)throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let y=1;if(s&&s.dims.length>0){if(n.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(s.dims.length<3||s.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(n.dims[0]!==s.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(s.dims.length===3){if(n.dims[2]%s.dims[2]!==0)throw new Error('Dimension 2 of "query" should be a multiple of "key"');d=s.dims[1]}else if(s.dims.length===5){if(s.dims[2]!==e.numHeads||s.dims[3]!==2||s.dims[4]!==f)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(r)throw new Error('Expect "value" be none when "key" has packed kv format.');d=s.dims[1]}else{if(s.dims[1]!==e.numHeads||s.dims[3]!==f)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');d=s.dims[2]}}else{if(n.dims.length!==3&&n.dims.length!==5)throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');if(n.dims.length===5&&(n.dims[2]!==e.numHeads||n.dims[3]!==3))throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');y=3}let b=0,$=!1,w=e.kvNumHeads?f*e.kvNumHeads:c;if(r&&r.dims.length>0){if(r.dims.length!==3&&r.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(n.dims[0]!==r.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(r.dims.length===3){if(d!==r.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');w=r.dims[2]}else{if(d!==r.dims[2])throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');w=r.dims[1]*r.dims[3],$=!0}}let v=t.length>4?t[5]:void 0;if(v&&v.dims.length!==1&&v.dims[0]!==u)throw new Error('Input "seqlens" is expected to have 1 dimension and the same dim 0 as batch_size');return{batchSize:u,sequenceLength:l,pastSequenceLength:h,kvSequenceLength:d,totalSequenceLength:-1,maxSequenceLength:-1,inputHiddenSize:0,hiddenSize:c,vHiddenSize:w,headSize:f,vHeadSize:Math.floor(w/e.kvNumHeads),numHeads:e.numHeads,kvNumHeads:e.kvNumHeads,nReps:e.numHeads/e.kvNumHeads,pastPresentShareBuffer:!1,maskType:b,scale:e.scale,broadcastResPosBias:!1,passPastInKv:$,qkvFormat:y}},rS=lt({perm:[0,2,1,3]}),Pf=(t,e,n)=>{let s=e,r=n.kvNumHeads;return e.dims.length===3&&n.kvSequenceLength!==0&&(s=e.reshape([n.batchSize,n.kvSequenceLength,r,n.headSize]),s=t.compute(ss(s,rS.perm),{inputs:[s],outputs:[-1]})[0]),s},aS=(t,e,n,s)=>{let r=7,a=["type","type"],i=[t*e],o=t*e,u=[{type:12,data:o},{type:12,data:e},{type:12,data:t}],l=c=>{let d=ue("seq_lens",n.dataType,n.dims),h=ue("total_seq_lens",s.dataType,s.dims),p=ve("pos_ids",r,i),f=[{name:"output_size",type:"u32"},{name:"sequence_length",type:"u32"},{name:"batch_size",type:"u32"}];return`
  ${c.registerUniforms(f).declareVariables(d,h,p)}
  ${c.mainStart()}
    ${c.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let total_sequence_length = u32(${h.getByOffset("0")});
    let is_subsequent_prompt = uniforms.sequence_length > 1 && uniforms.sequence_length != total_sequence_length;
    let is_first_prompt = !is_subsequent_prompt && uniforms.sequence_length == total_sequence_length;
    let batch_idx = global_idx / uniforms.sequence_length;
    let sequence_idx = i32(global_idx % uniforms.sequence_length);
    var pos_id: i32 = 0;
    let seqlen = ${d.getByOffset("batch_idx")};
    let total_seqlen = seqlen + 1;
    if (is_first_prompt) {
      if (sequence_idx < total_seqlen) {
        pos_id = sequence_idx;
      } else {
        pos_id = 1;
      }
      ${p.setByOffset("global_idx","pos_id")}
    } else if (is_subsequent_prompt) {
      let past_seqlen = total_seqlen - i32(uniforms.sequence_length);
      if (past_seqlen + sequence_idx < total_seqlen) {
        pos_id = past_seqlen + sequence_idx;
      } else {
        pos_id = 1;
      }
      ${p.setByOffset("global_idx","pos_id")}
    } else if (global_idx < uniforms.batch_size) {
      ${p.setByOffset("global_idx","seqlen")}
    };
  }
  `};return{name:"GeneratePositionIds",shaderCache:{hint:`${t};${e}`,inputDependencies:a},getRunData:()=>({outputs:[{dims:i,dataType:r}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:u}),getShaderSource:l}},uO=(t,e)=>{var w;let n=sS(t.inputs,e);if(t.inputs[0].dims.length===5)throw new Error("Packed QKV is not implemented");if(((w=t.inputs[1])==null?void 0:w.dims.length)===5)throw new Error("Packed KV is not implemented");let s=t.inputs[0],r=t.inputs[1]&&t.inputs[1].dims.length>0?t.inputs[1]:void 0,a=t.inputs[2]&&t.inputs[2].dims.length>0?t.inputs[2]:void 0,i=t.inputs[3]&&t.inputs[3].dims.length!==0?t.inputs[3]:void 0,o=t.inputs[4]&&t.inputs[4].dims.length!==0?t.inputs[4]:void 0,u=t.inputs.length>4?t.inputs[5]:void 0,l=t.inputs.length>5?t.inputs[6]:void 0,c=n.kvNumHeads?n.kvNumHeads:n.numHeads,d=lt({axis:2,numOutputs:3,splitSizes:[n.numHeads*n.headSize,c*n.headSize,c*n.headSize]}),[h,p,f]=!r&&!a?t.compute(pg([s],d),{inputs:[s],outputs:[-1,-1,-1]}):[s,r,a],m,g;if(e.doRotary){let v=t.compute(aS(n.batchSize,n.sequenceLength,u,l),{inputs:[u,l],outputs:[-1]})[0],k=t.inputs[7],C=t.inputs[8],N=lt({interleaved:e.rotaryInterleaved!==0,numHeads:n.numHeads,rotaryEmbeddingDim:0,scale:e.scale}),A=[h,v,k,C],I=[-1];m=t.compute(bd(A,N),{inputs:A,outputs:I})[0],A.splice(0,1,p);let E=lt({interleaved:e.rotaryInterleaved!==0,numHeads:n.kvNumHeads,rotaryEmbeddingDim:0,scale:e.scale});g=t.compute(bd(A,E),{inputs:A,outputs:I})[0]}let y=Jo(t,n.batchSize,n.numHeads,n.sequenceLength,n.headSize,e.doRotary?m:h,void 0,0),b=Pf(t,e.doRotary?g:p,n),$=Pf(t,f,n);xu(t,y,b,$,void 0,void 0,i,o,void 0,n,u,l)}}),Bf,iS,oS,lO,Rle=he(()=>{De(),Be(),ka(),Me(),Bf=(t,e,n,s,r,a,i,o)=>{let u=Nt(a),l=u===1?"f32":`vec${u}f`,c=u===1?"vec2f":`mat2x${u}f`,d=r*i,h=64;d===1&&(h=256);let p=[r,i,a/u],f=[r,i,2],m=["rank","type","type"],g=[];g.push(...Ce(p,f));let y=b=>{let $=ue("x",e.dataType,3,u),w=ue("scale",n.dataType,n.dims),v=ue("bias",s.dataType,s.dims),k=ve("output",1,3,2),C=[$,w,v,k];return`
  var<workgroup> workgroup_shared : array<${c}, ${h}>;
  const workgroup_size = ${h}u;
  ${b.declareVariables(...C)}
  ${b.mainStart(h)}
    let batch = workgroup_index / uniforms.x_shape[1];
    let channel = workgroup_index % uniforms.x_shape[1];
    let hight = uniforms.x_shape[2];
    // initialize workgroup memory
    var sum = ${l}(0);
    var squared_sum = ${l}(0);
    for (var h = local_idx; h < hight; h += workgroup_size) {
      let value = ${l}(${$.get("batch","channel","h")});
      sum += value;
      squared_sum += value * value;
    }
    workgroup_shared[local_idx] = ${c}(sum, squared_sum);
    workgroupBarrier();

    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (local_idx < currSize) {
        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];
      }
      workgroupBarrier();
    }
    if (local_idx == 0) {
      let sum_final = ${pa("workgroup_shared[0][0]",u)} / f32(hight * ${u});
      let squared_sum_final = ${pa("workgroup_shared[0][1]",u)} / f32(hight * ${u});

      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${o}));
      let channel_scale = inv_std_dev * f32(scale[channel]);
      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;
      output[workgroup_index] = vec2f(channel_scale, channel_shift);
    }
  }`};return t.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${u};${o};${h}`,inputDependencies:m},getRunData:()=>({outputs:[{dims:f,dataType:1}],dispatchGroup:{x:d},programUniforms:g}),getShaderSource:y},{inputs:[e,n,s],outputs:[-1]})[0]},iS=(t,e,n)=>{let s=e[0].dims,r=s,a=2,i=s[0],o=s[1],u=re.sizeFromDimension(s,a),l=Nt(u),c=re.size(r)/l,d=Bf(t,e[0],e[1],e[2],i,u,o,n.epsilon),h=[i,o,u/l],p=[i,o],f=["type","none"],m=g=>{let y=ue("x",e[0].dataType,h.length,l),b=ue("scale_shift",1,p.length,2),$=ve("output",e[0].dataType,h.length,l),w=[y,b,$];return`
  ${g.registerUniform("output_size","u32").declareVariables(...w)}
  ${g.mainStart()}
  ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let outputIndices = ${$.offsetToIndices("global_idx")};
      let batch = outputIndices[0];
      let channel = outputIndices[1];
      let scale_shift = ${b.getByIndices("vec2<u32>(batch, channel)")};
      let value = ${y.getByOffset("global_idx")} * ${$.type.value}(scale_shift.x) + ${$.type.value}(scale_shift.y);
      ${$.setByOffset("global_idx","value")};
  }`};t.compute({name:"InstanceNormalization",shaderCache:{hint:`${l}`,inputDependencies:f},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:[{type:12,data:c},...Ce(h,p,h)]}),getShaderSource:m},{inputs:[e[0],d]})},oS=(t,e,n)=>{let s=e[0].dims,r=s,a=s[0],i=s[s.length-1],o=re.sizeFromDimension(s,1)/i,u=Nt(i),l=re.size(r)/u,c=[{type:12,data:o},{type:12,data:Math.floor(i/u)}],d=["type","type"],h=!1,p=[0,s.length-1];for(let y=0;y<s.length-2;y++)h=h||s[y+1]!==1,p.push(y+1);h=h&&s[s.length-1]!==1;let f=h?t.compute(ss(t.inputs[0],p),{inputs:[t.inputs[0]],outputs:[-1]})[0]:t.inputs[0].reshape(Array.from({length:s.length},(y,b)=>s[p[b]])),m=Bf(t,f,e[1],e[2],a,o,i,n.epsilon),g=y=>{let b=sn(e[0].dataType),$=u===1?"vec2f":`mat${u}x2f`,w=C=>{let N=C===0?"x":"y",A=u===1?"f32":`vec${u}f`;switch(u){case 1:return`${b}(${A}(scale.${N}))`;case 2:return`vec2<${b}>(${A}(scale[0].${N}, scale[1].${N}))`;case 4:return`vec4<${b}>(${A}(scale[0].${N}, scale[1].${N}, scale[2].${N}, scale[3].${N}))`;default:throw new Error(`Not supported compoents ${u}`)}},v=ue("input",e[0].dataType,e[0].dims,u),k=ve("output",e[0].dataType,r,u);return`
  @group(0) @binding(0) var<storage, read> input : array<${v.type.storage}>;
  @group(0) @binding(1) var<storage, read> scale_input : array<${$}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${k.type.storage}>;
  struct Uniforms {H: u32, C : u32};
  @group(0) @binding(3) var<uniform> uniforms: Uniforms;

  ${y.mainStart()}
    let current_image_number = global_idx / (uniforms.C * uniforms.H);
    let current_channel_number = global_idx % uniforms.C;

    let scale_offset = current_image_number * uniforms.C + current_channel_number;
    let scale = scale_input[scale_offset];
    output[global_idx] = fma(input[global_idx], ${w(0)}, ${w(1)});
  }`};t.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${u}`,inputDependencies:d},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:c}),getShaderSource:g},{inputs:[e[0],m]})},lO=(t,e)=>{e.format==="NHWC"?oS(t,t.inputs,e):iS(t,t.inputs,e)}}),uS,lS,cO,Dle=he(()=>{De(),Be(),Me(),uS=t=>{if(!t||t.length<2)throw new Error("layerNorm requires at least 2 inputs.")},lS=(t,e,n)=>{let s=e.simplified,r=t[0].dims,a=t[1],i=!s&&t[2],o=r,u=re.normalizeAxis(e.axis,r.length),l=re.sizeToDimension(r,u),c=re.sizeFromDimension(r,u),d=re.size(a.dims),h=i?re.size(i.dims):0;if(d!==c||i&&h!==c)throw new Error(`Size of X.shape()[axis:] == ${c}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${d} and bias size of ${h}`);let p=[];for(let v=0;v<r.length;++v)v<u?p.push(r[v]):p.push(1);let f=Nt(c),m=["type","type"],g=[{type:12,data:l},{type:1,data:c},{type:12,data:Math.floor(c/f)},{type:1,data:e.epsilon}];i&&m.push("type");let y=n>1,b=n>2,$=v=>{let k=sn(t[0].dataType),C=[ue("x",t[0].dataType,t[0].dims,f),ue("scale",a.dataType,a.dims,f)];i&&C.push(ue("bias",i.dataType,i.dims,f)),C.push(ve("output",t[0].dataType,o,f)),y&&C.push(ve("mean_data_output",1,p)),b&&C.push(ve("inv_std_output",1,p));let N=[{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}];return`
  ${v.registerUniforms(N).declareVariables(...C)}
  ${v.mainStart()}
    ${v.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}
    let offset = global_idx * uniforms.norm_size_vectorized;
    var mean_vector = ${rg("f32",f)};
    var mean_square_vector = ${rg("f32",f)};

    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {
      let value = ${Pi(k,f,"x[h + offset]")};
      mean_vector += value;
      mean_square_vector += value * value;
    }
    let mean = ${pa("mean_vector",f)} / uniforms.norm_size;
    let inv_std_dev = inverseSqrt(${pa("mean_square_vector",f)} / uniforms.norm_size ${s?"":"- mean * mean"} + uniforms.epsilon);

    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {
      let f32input = ${Pi(k,f,"x[j + offset]")};
      let f32scale = ${Pi(k,f,"scale[j]")};
      output[j + offset] = ${C[0].type.value}((f32input ${s?"":"- mean"}) * inv_std_dev * f32scale
        ${i?`+ ${Pi(k,f,"bias[j]")}`:""}
      );
    }

    ${y?"mean_data_output[global_idx] = mean":""};
    ${b?"inv_std_output[global_idx] = inv_std_dev":""};
  }`},w=[{dims:o,dataType:t[0].dataType}];return y&&w.push({dims:p,dataType:1}),b&&w.push({dims:p,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${f};${n};${s}`,inputDependencies:m},getRunData:()=>({outputs:w,dispatchGroup:{x:Math.ceil(l/64)},programUniforms:g}),getShaderSource:$}},cO=(t,e)=>{uS(t.inputs),t.compute(lS(t.inputs,e,t.outputCount))}}),cS,dO,Ole=he(()=>{Be(),H0(),q0(),cS=t=>{if(!t||t.length!==2)throw new Error("MatMul requires 2 inputs.");if(t[0].dims[t[0].dims.length-1]!==t[1].dims[t[1].dims.length-2])throw new Error("shared dimension does not match.")},dO=t=>{cS(t.inputs);let e=ro.calcShape(t.inputs[0].dims,t.inputs[1].dims,!0);if(!e)throw new Error("Can't use matmul on the given tensors");let n=e[e.length-1],s=t.inputs[0].dims[t.inputs[0].dims.length-1];if(n<8&&s<8)t.compute(G0(t.inputs,{activation:""},e));else{let r=e[e.length-2],a=re.size(t.inputs[0].dims.slice(0,-2)),i=re.size(t.inputs[1].dims.slice(0,-2));if(a!==1&&r===1&&i===1){let o=t.inputs[0].reshape([1,a,s]),u=t.inputs[1].reshape([1,s,n]),l=[1,a,n],c=[o,u];t.compute(yd(c,{activation:""},e,l),{inputs:c})}else t.compute(yd(t.inputs,{activation:""},e))}}}),dS,hS,pS,hO,pO,Fle=he(()=>{De(),Be(),Ot(),Me(),dS=(t,e)=>{if(t.length<3||t.length>4)throw new Error("MatMulNBits requires 3 or 4 inputs");let n=t[0],s=n.dims.length;if(n.dims[s-1]!==e.k)throw new Error("The last dim of input shape does not match the k value");let r=Math.floor((e.k+e.blockSize-1)/e.blockSize),a=e.blockSize/8*e.bits,i=t[1];if(!re.areEqual(i.dims,[e.n,r,a]))throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");let o=t[2].dims;if(re.size(o)!==e.n*r)throw new Error("scales input size error.");if(t.length===4){let u=t[3].dims,l=e.n*(e.bits===8?r:Math.floor((r*e.bits+7)/8));if(re.size(u)!==l)throw new Error("zeroPoints input size error.")}},hS=(t,e)=>{let n=t[0].dims,s=n.length,r=n[s-2],a=e.k,i=e.n,o=n.slice(0,s-2),u=re.size(o),l=t[1].dims[2]/4,c=t[0].dataType,d=Nt(e.k),h=Nt(l),p=Nt(i),f=o.concat([r,i]),m=r>1&&i/p%2===0?2:1,g=re.size(f)/p/m,y=64,b=[],$=[u,r,a/d],w=re.convertShape(t[1].dims).slice();w.splice(-1,1,l/h),b.push(...Ce($)),b.push(...Ce(w)),b.push(...Ce(t[2].dims)),t.length===4&&b.push(...Ce(re.convertShape(t[3].dims)));let v=[u,r,i/p];b.push(...Ce(v));let k=C=>{let N=$.length,A=ue("a",t[0].dataType,N,d),I=ue("b",12,w.length,h),E=ue("scales",t[2].dataType,t[2].dims.length),z=[A,I,E],P=t.length===4?ue("zero_points",12,t[3].dims.length):void 0;P&&z.push(P);let H=v.length,G=ve("output",t[0].dataType,H,p),W=sn(t[0].dataType),L=(()=>{switch(d){case 1:return`array<${W}, 8>`;case 2:return`mat4x2<${W}>`;case 4:return`mat2x4<${W}>`;default:throw new Error(`${d}-component is not supported.`)}})(),B=()=>{let M=`
          // reuse a data
            var input_offset = ${A.indicesToOffset(`${A.type.indices}(batch, row, word_offset)`)};
            var a_data: ${L};
            for (var j: u32 = 0; j < ${8/d}; j++) {
              a_data[j] = ${A.getByOffset("input_offset")};
              input_offset++;
            }
          `;for(let Z=0;Z<p*m;Z++)M+=`
            b_value = ${h===1?`b${Z}_data`:`b${Z}_data[i]`};
            b_value_lower = unpack4xU8(b_value & b_mask);
            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);
            b_quantized_values = ${L}(${Array.from({length:4},(J,oe)=>`${W}(b_value_lower[${oe}]), ${W}(b_value_upper[${oe}])`).join(", ")});
            b_dequantized_values = ${d===1?`${L}(${Array.from({length:8},(J,oe)=>`(b_quantized_values[${oe}] - ${P?`zero_point${Z}`:"zero_point"}) * scale${Z}`).join(", ")});`:`(b_quantized_values - ${L}(${Array(8).fill(`${P?`zero_point${Z}`:"zero_point"}`).join(",")})) * scale${Z};`};
            workgroup_shared[local_id.x * ${m} + ${Math.floor(Z/p)}]${p>1?`[${Z%p}]`:""} += ${Array.from({length:8/d},(J,oe)=>`${d===1?`a_data[${oe}] * b_dequantized_values[${oe}]`:`dot(a_data[${oe}], b_dequantized_values[${oe}])`}`).join(" + ")};
          `;return M},Y=()=>{let M=`
            var col_index = col * ${p};
            ${P?`
            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;
            var zero_point_byte_count: u32;
            var zero_point_word_index: u32;
            var zero_point_byte_offset: u32;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            var zero_point_bits_offset: u32;
            var zero_point_word: u32;`:`
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${W}(8);`}
            `;for(let Z=0;Z<p*m;Z++)M+=`
            let scale${Z} = ${E.getByOffset("col_index * nBlocksPerCol + block")};
            ${P?`
            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);
            zero_point_word_index = zero_point_byte_count >> 0x2u;
            zero_point_byte_offset = zero_point_byte_count & 0x3u;
            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            zero_point_word = ${P.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point${Z} = ${W}((zero_point_word) & 0xFu);`:""}
            col_index += 1;`;return M},ne=()=>{let M=`col_index = col * ${p};`;for(let Z=0;Z<p*m;Z++)M+=`
            let b${Z}_data = ${I.getByIndices(`${I.type.indices}(col_index, block, word)`)};
            col_index += 1;`;return M+=`
            var b_value: u32;
            let b_mask: u32 = 0x0F0F0F0Fu;
            var b_value_lower: vec4<u32>;
            var b_value_upper: vec4<u32>;
            var b_quantized_values: ${L};
            var b_dequantized_values: ${L};`,M};return`
        var<workgroup> workgroup_shared: array<${G.type.value}, ${m*y}>;
        ${C.declareVariables(...z,G)}
        ${C.mainStart([y,1,1])}
          let output_indices = ${G.offsetToIndices(`(global_idx / ${y}) * ${m}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let nBlocksPerCol = uniforms.b_shape[1];

          for (var block = local_id.x; block < nBlocksPerCol; block += ${y}) {
            //process one block
            var word_offset: u32 = block * ${e.blockSize/d};
            ${Y()}
            for (var word: u32 = 0; word < ${l}; word += ${h}) {
              ${ne()}
              for (var i: u32 = 0; i < ${h}; i++) {
                ${B()}
                word_offset += ${8/d};
              }
            }
          }
          workgroupBarrier();

          if (local_id.x < ${m}) {
            var output_value: ${G.type.value} = ${G.type.value}(0);
            var workgroup_shared_offset: u32 = local_id.x;
            for (var b: u32 = 0u; b < ${y}u; b++) {
              output_value += workgroup_shared[workgroup_shared_offset];
              workgroup_shared_offset += ${m};
            }
            ${G.setByIndices(`${G.type.indices}(batch, row, col + local_id.x)`,"output_value")};
          }
        }`};return{name:"MatMulNBits",shaderCache:{hint:`${e.blockSize};${e.bits};${d};${h};${p};${m};${y}`,inputDependencies:Array(t.length).fill("rank")},getRunData:()=>({outputs:[{dims:f,dataType:c}],dispatchGroup:{x:g},programUniforms:b}),getShaderSource:k}},pS=(t,e)=>{let n=t[0].dims,s=n.length,r=n[s-2],a=e.k,i=e.n,o=n.slice(0,s-2),u=re.size(o),l=t[1].dims[2]/4,c=t[0].dataType,d=Nt(e.k),h=Nt(l),p=o.concat([r,i]),f=128,m=i%8===0?8:i%4===0?4:1,g=f/m,y=g*h*8,b=y/d,$=y/e.blockSize,w=re.size(p)/m,v=[],k=[u,r,a/d],C=re.convertShape(t[1].dims).slice();C.splice(-1,1,l/h),v.push(...Ce(k)),v.push(...Ce(C)),v.push(...Ce(t[2].dims)),t.length===4&&v.push(...Ce(re.convertShape(t[3].dims)));let N=[u,r,i];v.push(...Ce(N));let A=I=>{let E=k.length,z=ue("a",t[0].dataType,E,d),P=ue("b",12,C.length,h),H=ue("scales",t[2].dataType,t[2].dims.length),G=[z,P,H],W=t.length===4?ue("zero_points",12,t[3].dims.length):void 0;W&&G.push(W);let L=N.length,B=ve("output",t[0].dataType,L),Y=sn(t[0].dataType),ne=()=>{switch(d){case 1:return`
          let a_data0 = vec4<${Y}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);
          let a_data1 = vec4<${Y}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;case 2:return`
          let a_data0 = vec4<${Y}>(sub_a[word_offset], sub_a[word_offset + 1]);
          let a_data1 = vec4<${Y}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;case 4:return`
          let a_data0 = sub_a[word_offset];
          let a_data1 = sub_a[word_offset + 1];`;default:throw new Error(`${d}-component is not supported.`)}};return`
        var<workgroup> sub_a: array<${z.type.value}, ${b}>;
        var<workgroup> inter_results: array<array<${B.type.value}, ${g}>, ${m}>;
        ${I.declareVariables(...G,B)}
        ${I.mainStart([g,m,1])}
          let output_indices = ${B.offsetToIndices(`workgroup_index * ${m}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let n_blocks_per_col = uniforms.b_shape[1];
          let num_tiles =  (n_blocks_per_col - 1) / ${$} + 1;

          // Loop over shared dimension.
          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {
            let a_col_start = tile * ${b};
            // load one tile A data into shared memory.
            for (var a_offset = local_idx; a_offset < ${b}; a_offset += ${f})
            {
              let a_col = a_col_start + a_offset;
              if (a_col < uniforms.a_shape[2])
              {
                sub_a[a_offset] = ${z.getByIndices(`${z.type.indices}(batch, row, a_col)`)};
              } else {
                sub_a[a_offset] = ${z.type.value}(0);
              }
            }
            workgroupBarrier();

            // each thread process one block
            let b_row = col + local_id.y;
            let block = tile * ${$} + local_id.x;
            ${W?`
            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;
            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);
            let zero_point_word_index = zero_point_byte_count >> 0x2u;
            let zero_point_byte_offset = zero_point_byte_count & 0x3u;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            let zero_point_word = ${W.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point = ${Y}((zero_point_word) & 0xFu);`:`
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${Y}(8);`}
            let scale = ${H.getByOffset("b_row * n_blocks_per_col + block")};
            let b_data = ${P.getByIndices(`${P.type.indices}(b_row, block, 0)`)};
            var word_offset = local_id.x * ${e.blockSize/d};
            for (var i: u32 = 0; i < ${h}; i++) {
              ${ne()}
              let b_value = ${h===1?"b_data":"b_data[i]"};
              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);
              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);
              let b_quantized_values = mat2x4<${Y}>(${Array.from({length:4},(M,Z)=>`${Y}(b_value_lower[${Z}]), ${Y}(b_value_upper[${Z}])`).join(", ")});
              let b_dequantized_values = (b_quantized_values - mat2x4<${Y}>(${Array(8).fill("zero_point").join(",")})) * scale;
              inter_results[local_id.y][local_id.x] += ${Array.from({length:2},(M,Z)=>`${`dot(a_data${Z}, b_dequantized_values[${Z}])`}`).join(" + ")};
              word_offset += ${8/d};
            }
            workgroupBarrier();
          }

          if (local_idx < ${m}) {
            var output_value: ${B.type.value} = ${B.type.value}(0);
            for (var b = 0u; b < ${g}; b++) {
              output_value += inter_results[local_idx][b];
            }
            if (col + local_idx < uniforms.output_shape[2])
            {
              ${B.setByIndices(`${B.type.indices}(batch, row, col + local_idx)`,"output_value")}
            }
          }
        }`};return{name:"BlockwiseMatMulNBits32",shaderCache:{hint:`${e.blockSize};${d};${h};${g};${m}`,inputDependencies:Array(t.length).fill("rank")},getRunData:()=>({outputs:[{dims:p,dataType:c}],dispatchGroup:{x:w},programUniforms:v}),getShaderSource:A}},hO=(t,e)=>{dS(t.inputs,e),e.blockSize===32&&t.adapterInfo.isVendor("intel")&&t.adapterInfo.isArchitecture("gen-12lp")?t.compute(pS(t.inputs,e)):t.compute(hS(t.inputs,e))},pO=t=>lt(t)}),fS,mS,gS,yS,bS,xS,wS,$S,fO,zle=he(()=>{De(),Be(),Me(),fS=t=>{if(!t||t.length<1)throw new Error("Too few inputs");if(t[0].dataType!==1&&t[0].dataType!==10)throw new Error("Input type must be float or float16.");if(t.length>=2){let e=t[0].dims.length*2===t[1].dims[0];if(t.length===4&&(e=t[3].dims[0]*2===t[1].dims[0]),!e)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},mS=(t,e,n)=>{let s="";for(let r=e-1;r>=0;--r)s+=`
            k = i32(${t.indicesGet("indices",r)}) - ${Se("uniforms.pads",r,n)};
            if (k < 0) {
              break;
            }
            if (k >= i32(${Se("uniforms.x_shape",r,e)})) {
              break;
            }
            offset += k * i32(${Se("uniforms.x_strides",r,e)});
        `;return`
          value = ${t.type.value}(uniforms.constant_value);
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${s}
            value = x[offset];
          }
      `},gS=(t,e,n)=>{let s="";for(let r=e-1;r>=0;--r)s+=`
                k = i32(${t.indicesGet("indices",r)}) - ${Se("uniforms.pads",r,n)};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = 2 * (i32(${Se("uniforms.x_shape",r,e)}) - 1);
                  k = k % _2n_1;
                  if(k >= i32(${Se("uniforms.x_shape",r,e)})) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * i32(${Se("uniforms.x_strides",r,e)});
            `;return`
              var offset = 0;
              var k = 0;
              ${s}
              value = x[offset];
          `},yS=(t,e,n)=>{let s="";for(let r=e-1;r>=0;--r)s+=`
                k = i32(${t.indicesGet("indices",r)}) - ${Se("uniforms.pads",r,n)};
                if (k < 0) {
                  k = 0;
                }
                if (k >= i32(${Se("uniforms.x_shape",r,e)})) {
                  k = i32(${Se("uniforms.x_shape",r,e)}) - 1;
                }
                offset += k * i32(${Se("uniforms.x_strides",r,e)});
            `;return`
              var offset = 0;
              var k = 0;
              ${s}
              value = x[offset];
          `},bS=(t,e,n)=>{let s="";for(let r=e-1;r>=0;--r)s+=`
                k = i32(${t.indicesGet("indices",r)}) - ${Se("uniforms.pads",r,n)};
                if (k < 0)  {
                  k += i32(${Se("uniforms.x_shape",r,e)}]);
                }
                if (k >= i32(${Se("uniforms.x_shape",r,e)})) {
                  k -= i32(${Se("uniforms.x_shape",r,e)});
                }
                offset += k * i32(${Se("uniforms.x_strides",r,e)});
            `;return`
              var offset = 0;
              var k = 0;
              ${s}
              value = x[offset];
          `},xS=(t,e,n)=>{switch(n.mode){case 0:return mS(t,e,n.pads.length);case 1:return gS(t,e,n.pads.length);case 2:return yS(t,e,n.pads.length);case 3:return bS(t,e,n.pads.length);default:throw new Error("Invalid mode")}},wS=(t,e)=>{let n=re.padShape(t[0].dims.slice(),e.pads),s=t[0].dims,r=re.size(n),a=[{type:12,data:r},{type:6,data:e.pads}],i=t.length>=3&&t[2].data;e.mode===0&&a.push({type:i?t[2].dataType:1,data:e.value}),a.push(...Ce(t[0].dims,n));let o=["rank"],u=l=>{let c=ve("output",t[0].dataType,n.length),d=ue("x",t[0].dataType,s.length),h=d.type.value,p=xS(c,s.length,e),f=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:e.pads.length}];return e.mode===0&&f.push({name:"constant_value",type:i?h:"f32"}),`
            ${l.registerUniforms(f).declareVariables(d,c)}
            ${l.mainStart()}
            ${l.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

            let indices = ${c.offsetToIndices("global_idx")};

            var value = ${h}(0);
            ${p}
            output[global_idx] = value;
        }`};return{name:"Pad",shaderCache:{hint:`${e.mode}${i}`,inputDependencies:o},getRunData:()=>({outputs:[{dims:n,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(re.size(n)/64)},programUniforms:a}),getShaderSource:u}},$S=(t,e)=>{if(t.length>1){let n=t[1].getBigInt64Array(),s=t.length>=3&&t[2].data?t[2].dataType===10?t[2].getUint16Array()[0]:t[2].getFloat32Array()[0]:0,r=t[0].dims.length,a=new Int32Array(2*r).fill(0);if(t.length>=4){let o=t[3].getBigInt64Array();for(let u=0;u<o.length;u++)a[Number(o[u])]=Number(n[u]),a[Number(o[u])+r]=Number(n[u+o.length])}else n.forEach((o,u)=>a[Number(u)]=Number(o));let i=[];return a.forEach(o=>i.push(o)),{mode:e.mode,value:s,pads:i}}else return e},fO=(t,e)=>{fS(t.inputs);let n=$S(t.inputs,e);t.compute(wS(t.inputs,n),{inputs:[0]})}}),Mo,Mf,Vf,Wf,Uf,vS,SS,Gf,Hf,mO,gO,qf,yO,bO,jf,xO,wO,$O,vO,Lle=he(()=>{Ts(),De(),Be(),Me(),Mo=t=>{if(gt.webgpu.validateInputContent&&(!t||t.length!==1))throw new Error("Pool ops requires 1 input.")},Mf=(t,e,n)=>{let s=e.format==="NHWC",r=t.dims.slice();s&&r.splice(1,0,r.pop());let a=Object.hasOwnProperty.call(e,"dilations"),i=e.kernelShape.slice(),o=e.strides.slice(),u=a?e.dilations.slice():[],l=e.pads.slice();md.adjustPoolAttributes(n,r,i,o,u,l);let c=md.computePoolOutputShape(n,r,o,u,i,l,e.autoPad),d=Object.assign({},e);a?Object.assign(d,{kernelShape:i,strides:o,pads:l,dilations:u,cacheKey:e.cacheKey}):Object.assign(d,{kernelShape:i,strides:o,pads:l,cacheKey:e.cacheKey});let h=c.slice();return h.push(h.splice(1,1)[0]),[d,s?h:c]},Vf=(t,e)=>{let n=e.format==="NHWC",s=re.size(t),r=re.size(e.kernelShape),a=[{type:12,data:s},{type:12,data:r}],i=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(e.kernelShape.length<=2){let o=e.kernelShape[e.kernelShape.length-1],u=e.strides[e.strides.length-1],l=e.pads[e.pads.length/2-1],c=e.pads[e.pads.length-1],d=!!(l+c);a.push({type:12,data:o},{type:12,data:u},{type:12,data:l},{type:12,data:c}),i.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let h=!1;if(e.kernelShape.length===2){let p=e.kernelShape[e.kernelShape.length-2],f=e.strides[e.strides.length-2],m=e.pads[e.pads.length/2-2],g=e.pads[e.pads.length-2];h=!!(m+g),a.push({type:12,data:p},{type:12,data:f},{type:12,data:m},{type:12,data:g}),i.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[a,i,!0,d,h]}else{if(n)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let o=re.computeStrides(e.kernelShape);a.push({type:12,data:o},{type:12,data:e.pads},{type:12,data:e.strides}),i.push({name:"kernelStrides",type:"u32",length:o.length},{name:"pads",type:"u32",length:e.pads.length},{name:"strides",type:"u32",length:e.strides.length});let u=e.pads.reduce((l,c)=>l+c);return[a,i,!!u,!1,!1]}},Wf=(t,e,n,s,r,a,i,o,u,l,c,d)=>{let h=r.format==="NHWC",p=e.type.value,f=ve("output",e.type.tensor,s);if(r.kernelShape.length<=2){let m="",g="",y="",b=n-(h?2:1);if(c?m=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${b}] = indices[${b}] * uniforms.sw - uniforms.pwStart + i;
                  if (xIndices[${b}] < 0 || xIndices[${b}]
                      >= uniforms.x_shape[${b}]) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${e.indicesToOffset("xIndices")}];
                  ${a}
                }`:m=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${b}] = indices[${b}] * uniforms.sw - uniforms.pwStart + i;
                  let x_val = x[${e.indicesToOffset("xIndices")}];
                  ${a}
                }`,r.kernelShape.length===2){let $=n-(h?3:2);d?g=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${$}] = indices[${$}] * uniforms.sh - uniforms.phStart + j;
                  if (xIndices[${$}] < 0 || xIndices[${$}] >= uniforms.x_shape[${$}]) {
                    pad += i32(uniforms.kw);
                    continue;
                  }
              `:g=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${$}] = indices[${$}] * uniforms.sh - uniforms.phStart + j;
                `,y=`
              }
            `}return`
            ${t.registerUniforms(u).declareVariables(e,f)}

            ${t.mainStart()}
              ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

              let indices = ${f.offsetToIndices("global_idx")};
              var xIndices = ${f.offsetToIndices("global_idx")};

              var value = ${p}(${o});
              var pad = 0;
              ${g}
              ${m}
              ${y}
              ${i}

              output[global_idx] = value;
            }`}else{if(h)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let m=r.kernelShape.length,g=r.pads.length,y="";return l?y=`
                if (xIndices[j] >= uniforms.x_shape[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${e.indicesToOffset("xIndices")}];
                ${a}
              }`:y=`
              }
              let x_val = x[${e.indicesToOffset("xIndices")}];
              ${a}
            `,`
            ${t.registerUniforms(u).declareVariables(e,f)}

            ${t.mainStart()}
              ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
              let indices = ${f.offsetToIndices("global_idx")};
              var xIndices = ${f.offsetToIndices("global_idx")};

              var offsets: array<u32, ${m}>;

              var value = ${p}(${o});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {
                var offset = i;
                for (var j = 0u; j < ${m-1}u; j++) {
                  offsets[j] = offset / ${Se("uniforms.kernelStrides","j",m)};
                  offset -= offsets[j] * ${Se("uniforms.kernelStrides","j",m)};
                }
                offsets[${m-1}] = offset;

                isPad = false;
                for (var j = ${n-m}u; j < ${n}u; j++) {
                  xIndices[j] = indices[j] * ${Se("uniforms.strides",`j - ${n-m}u`,m)}
                    + offsets[j - ${n-m}u] - ${Se("uniforms.pads","j - 2u",g)};
                  ${y}
              }
              ${i}

              output[global_idx] = value;
            }`}},Uf=t=>`${t.format};${t.ceilMode};${t.autoPad};${t.kernelShape.length}`,vS=t=>`${Uf(t)};${t.countIncludePad}`,SS=t=>`${Uf(t)};${t.storageOrder};${t.dilations}`,Gf=t=>({format:t.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][t.auto_pad],ceilMode:t.ceil_mode,kernelShape:t.kernel_shape,strides:t.strides,pads:t.pads}),Hf=(t,e,n,s)=>{let[r,a]=Mf(e,s,n),i=ue("x",e.dataType,e.dims.length),o=i.type.value,u="value += x_val;",l="";r.countIncludePad?l+=`value /= ${o}(uniforms.kernelSize);`:l+=`value /= ${o}(i32(uniforms.kernelSize) - pad);`;let[c,d,h,p,f]=Vf(a,r);c.push(...Ce(e.dims,a));let m=["rank"];return{name:t,shaderCache:{hint:`${s.cacheKey};${h};${p};${f}`,inputDependencies:m},getRunData:()=>({outputs:[{dims:a,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(re.size(a)/64)},programUniforms:c}),getShaderSource:g=>Wf(g,i,e.dims.length,a.length,r,u,l,0,d,h,p,f)}},mO=t=>{let e=t.count_include_pad!==0,n=Gf(t);if(n.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let s={countIncludePad:e,...n,cacheKey:""};return{...s,cacheKey:vS(s)}},gO=(t,e)=>{Mo(t.inputs),t.compute(Hf("AveragePool",t.inputs[0],!1,e))},qf={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},yO=t=>{let e=t.format;return{format:e,...qf,cacheKey:e}},bO=(t,e)=>{Mo(t.inputs),t.compute(Hf("GlobalAveragePool",t.inputs[0],!0,e))},jf=(t,e,n,s)=>{let[r,a]=Mf(e,s,n),i=`
      value = max(x_val, value);
    `,o="",u=ue("x",e.dataType,e.dims.length),l=["rank"],[c,d,h,p,f]=Vf(a,r);return c.push(...Ce(e.dims,a)),{name:t,shaderCache:{hint:`${s.cacheKey};${h};${p};${f}`,inputDependencies:l},getRunData:()=>({outputs:[{dims:a,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(re.size(a)/64)},programUniforms:c}),getShaderSource:m=>Wf(m,u,e.dims.length,a.length,r,i,o,e.dataType===10?-65504:-1e5,d,h,p,f)}},xO=(t,e)=>{Mo(t.inputs),t.compute(jf("MaxPool",t.inputs[0],!1,e))},wO=t=>{let e=t.storage_order,n=t.dilations,s=Gf(t);if(e!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(s.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let r={storageOrder:e,dilations:n,...s,cacheKey:""};return{...r,cacheKey:SS(r)}},$O=t=>{let e=t.format;return{format:e,...qf,cacheKey:e}},vO=(t,e)=>{Mo(t.inputs),t.compute(jf("GlobalMaxPool",t.inputs[0],!0,e))}}),IS,_S,SO,IO,Ple=he(()=>{De(),Be(),Ot(),Me(),IS=(t,e)=>{if(t.length<2||t.length>3)throw new Error("DequantizeLinear requires 2 or 3 inputs.");if(t.length===3&&t[1].dims===t[2].dims)throw new Error("x-scale and x-zero-point must have the same shape.");if(t.length===3&&t[0].dataType!==t[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(t[0].dataType===6&&t.length>2)throw new Error("In the case of dequantizing int32 there is no zero point.");if(t[1].dims.length!==0&&t[1].dims.length!==1&&t[1].dims.length!==t[0].dims.length)throw new Error("scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.");if(t.length>2){if(t[0].dataType!==t[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(t[1].dims.length!==t[2].dims.length)throw new Error("scale and zero-point inputs must have the same rank.");if(!t[1].dims.map((n,s)=>n===t[2].dims[s]).reduce((n,s)=>n&&s,!0))throw new Error("scale and zero-point inputs must have the same shape.")}if(e.blockSize>0){if(t[1].dims.length===0||t[1].dims.length===1&&t[1].dims[0]===1)throw new Error("blockSize must be set only for block quantization.");if(!t[1].dims.map((r,a)=>a===e.axis||r===t[0].dims[a]).reduce((r,a)=>r&&a,!0))throw new Error("For block qunatization, scale input shape to match the input shape except for the axis");if(t[1].dims.length!==t[0].dims.length)throw new Error("For block qunatization the scale input rank must be the same as the x rank.");let n=t[0].dims[e.axis],s=t[1].dims[e.axis];if(e.blockSize<Math.ceil(n/s)||e.blockSize>Math.ceil(n/(s-1)-1))throw new Error("blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].")}},_S=(t,e)=>{let n=re.normalizeAxis(e.axis,t[0].dims.length),s=t[0].dataType,r=s===3,a=t[0].dims,i=t[1].dataType,o=re.size(a),u=s===3||s===2,l=u?[Math.ceil(re.size(t[0].dims)/4)]:t[0].dims,c=t[1].dims,d=t.length>2?t[2]:void 0,h=d?u?[Math.ceil(re.size(d.dims)/4)]:d.dims:void 0,p=c.length===0||c.length===1&&c[0]===1,f=p===!1&&c.length===1,m=Nt(o),g=p&&(!u||m===4),y=g?m:1,b=g&&!u?m:1,$=ue("input",u?12:s,l.length,b),w=ue("scale",i,c.length),v=d?ue("zero_point",u?12:s,h.length):void 0,k=ve("output",i,a.length,y),C=[$,w];v&&C.push(v);let N=[l,c];d&&N.push(h);let A=[{type:12,data:o/y},{type:12,data:n},{type:12,data:e.blockSize},...Ce(...N,a)],I=E=>{let z=[{name:"output_size",type:"u32"},{name:"axis",type:"u32"},{name:"block_size",type:"u32"}];return`
      ${E.registerUniforms(z).declareVariables(...C,k)}
      ${E.mainStart()}
          ${E.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let output_indices = ${k.offsetToIndices("global_idx")};

          // Set input x
          ${u?`
            let input = ${$.getByOffset("global_idx / 4")};
            let x_vec = ${r?"unpack4xI8(input)":"unpack4xU8(input)"};
            let x_value = ${y===1?"x_vec[global_idx % 4]":"x_vec"};`:`let x_value = ${$.getByOffset("global_idx")};`};

          // Set scale input
          ${p?`let scale_value= ${w.getByOffset("0")}`:f?`
            let scale_index = ${k.indicesGet("output_indices","uniforms.axis")};
            let scale_value= ${w.getByOffset("scale_index")};`:`
            var scale_indices: ${w.type.indices} = output_indices;
            let index = ${w.indicesGet("scale_indices","uniforms.axis")} / uniforms.block_size;
            ${w.indicesSet("scale_indices","uniforms.axis","index")};
            let scale_value= ${w.getByIndices("scale_indices")};`};

          // Set zero-point input
          ${v?p?u?`
                let zero_point_input = ${v.getByOffset("0")};
                let zero_point_vec =  ${r?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value= zero_point_vec[0]`:`let zero_point_value = ${v.getByOffset("0")}`:f?u?`
                let zero_point_index = ${k.indicesGet("output_indices","uniforms.axis")};
                let zero_point_input = ${v.getByOffset("zero_point_index / 4")};
                let zero_point_vec =  ${r?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_index % 4]`:`
                let zero_point_index = ${k.indicesGet("output_indices","uniforms.axis")};
                let zero_point_value = ${v.getByOffset("zero_point_index")};`:u?`
                let zero_point_offset = ${w.indicesToOffset("scale_indices")};
                let zero_point_input = ${v.getByOffset("zero_point_offset / 4")};
                let zero_point_vec = ${r?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_offset % 4];`:`let zero_point_value = ${v.getByIndices("scale_indices")};`:`let zero_point_value = ${u?r?"i32":"u32":$.type.value}(0);`};
      // Compute and write output
      ${k.setByOffset("global_idx",`${k.type.value}(x_value - zero_point_value) * scale_value`)};
      }`};return{name:"DequantizeLinear",shaderCache:{hint:e.cacheKey,inputDependencies:v?["rank","rank","rank"]:["rank","rank"]},getShaderSource:I,getRunData:()=>({outputs:[{dims:a,dataType:i}],dispatchGroup:{x:Math.ceil(o/y/64),y:1,z:1},programUniforms:A})}},SO=(t,e)=>{IS(t.inputs,e),t.compute(_S(t.inputs,e))},IO=t=>lt({axis:t.axis,blockSize:t.blockSize})}),kS,CS,_O,Ble=he(()=>{Ts(),De(),Me(),kS=(t,e,n)=>{let s=t===e,r=t<e&&n<0,a=t>e&&n>0;if(s||r||a)throw new Error("Range these inputs' contents are invalid.")},CS=(t,e,n,s)=>{let r=Math.abs(Math.ceil((e-t)/n)),a=[r],i=r,o=[{type:12,data:i},{type:s,data:t},{type:s,data:n},...Ce(a)],u=l=>{let c=ve("output",s,a.length),d=c.type.value,h=[{name:"outputSize",type:"u32"},{name:"start",type:d},{name:"delta",type:d}];return`
        ${l.registerUniforms(h).declareVariables(c)}
        ${l.mainStart()}
        ${l.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        output[global_idx] = uniforms.start + ${d}(global_idx) * uniforms.delta;
      }`};return{name:"Range",shaderCache:{hint:`${s}`},getShaderSource:u,getRunData:()=>({outputs:[{dims:a,dataType:s}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:o})}},_O=t=>{let e=0,n=0,s=0;t.inputs[0].dataType===6?(e=t.inputs[0].getInt32Array()[0],n=t.inputs[1].getInt32Array()[0],s=t.inputs[2].getInt32Array()[0]):t.inputs[0].dataType===1&&(e=t.inputs[0].getFloat32Array()[0],n=t.inputs[1].getFloat32Array()[0],s=t.inputs[2].getFloat32Array()[0]),gt.webgpu.validateInputContent&&kS(e,n,s),t.compute(CS(e,n,s,t.inputs[0].dataType),{inputs:[]})}}),TS,NS,kO,CO,Mle=he(()=>{De(),Be(),Ot(),Me(),TS=(t,e,n,s)=>{if(t!=="none"&&s!=="i32"&&s!=="u32"&&s!=="f32")throw new Error(`Input ${s} is not supported with reduction ${t}.`);let r=`{
                var oldValue = 0;
                loop {
                  let newValueF32 =`,a=`;
                  let newValue = bitcast<i32>(newValueF32);
                  let res = atomicCompareExchangeWeak(&${e}, oldValue, newValue);
                  if res.exchanged {
                    break;
                  }
                  oldValue = res.old_value;
                }
              }`;switch(t){case"none":return`${e}=${n};`;case"add":return s==="i32"||s==="u32"?`atomicAdd(&${e}, bitcast<${s}>(${n}));`:`
              ${r}bitcast<${s}>(oldValue) + (${n})${a}`;case"max":return s==="i32"||s==="u32"?`atomicMax(&${e}, bitcast<${s}>(${n}));`:`
                ${r}max(bitcast<f32>(oldValue), (${n}))${a}`;case"min":return s==="i32"||s==="u32"?`atomicMin(&${e}, bitcast<${s}>(${n}));`:`${r}min(bitcast<${s}>(oldValue), (${n}))${a}`;case"mul":return`${r}(bitcast<${s}>(oldValue) * (${n}))${a}`;default:throw new Error(`Reduction ${t} is not supported.`)}},NS=(t,e)=>{let n=t[0].dims,s=t[1].dims,r=n,a=1,i=Math.ceil(re.sizeToDimension(s,s.length-1)/a),o=s[s.length-1],u=re.sizeFromDimension(n,o),l=[{type:12,data:i},{type:12,data:o},{type:12,data:u},...Ce(t[1].dims,t[2].dims,r)],c=d=>{let h=ue("indices",t[1].dataType,t[1].dims.length),p=ue("updates",t[2].dataType,t[2].dims.length,a),f=e.reduction!=="none"&&e.reduction!==""?tR("output",t[0].dataType,r.length):ve("output",t[0].dataType,r.length,a);return`
      ${d.registerUniform("output_size","u32").registerUniform("last_index_dimension","u32").registerUniform("num_updates_elements","u32").declareVariables(h,p,f)}
      ${d.mainStart()}
        ${d.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
  var data_offset = 0u;
  let indices_start = uniforms.last_index_dimension * global_idx;
  let indices_end = indices_start + uniforms.last_index_dimension;
  for (var i = indices_start; i < indices_end; i++) {
    var index = i32(indices[i].x);
    ${t[0].dims.length===1?`
    let element_count_dim = uniforms.output_strides;
    let dim_value = uniforms.output_shape;`:`
    let element_count_dim = uniforms.output_strides[i - indices_start];
    let dim_value = uniforms.output_shape[i - indices_start];`}
    if (index >= 0) {
      if (index >= i32(dim_value)) {
        index = i32(dim_value - 1);
      }
    } else {
      if (index < -i32(dim_value)) {
        index = 0;
      } else {
        index += i32(dim_value);
      }
    }
    data_offset += u32((u32(index) * element_count_dim));
  }

  for (var i = 0u; i < uniforms.num_updates_elements; i++) {
    let value = updates[uniforms.num_updates_elements * global_idx + i];
    ${TS(e.reduction,"output[data_offset + i]","value",f.type.value)}
  }

      }`};return{name:"ScatterND",shaderCache:{hint:`${e.cacheKey}_${e.reduction}`,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:r,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:l}),getShaderSource:c}},kO=t=>lt({reduction:t.reduction}),CO=(t,e)=>{t.compute(NS(t.inputs,e),{inputs:[t.inputs[1],t.inputs[2]],outputs:[]})}}),ES,AS,RS,Kf,DS,OS,FS,zS,LS,PS,BS,MS,Xf,VS,WS,US,GS,HS,TO,NO,Vle=he(()=>{De(),Be(),Ot(),Me(),ES=(t,e)=>{if(t.every(n=>n>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),t.length>0){if(e.mode==="linear"){if(!(t.length===2||t.length===3||t.length===4&&t[0]===1&&t[1]===1||t.length===4&&t[0]===1&&t[3]===1||t.length===5&&t[0]===1&&t[1]===1))throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and
            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`)}else if(e.mode==="cubic"&&!(t.length===2||t.length===4&&t[0]===1&&t[1]===1||t.length===4&&t[0]===1&&t[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},AS=(t,e,n)=>{e.every(r=>r>=0&&r<n||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let s=new Array(n).fill(1);return e.forEach((r,a)=>s[r]=t[a]),s},RS=(t,e,n,s,r,a)=>{let[i,o,u]=n>10?[1,2,3]:[-1,t.length>1?1:-1,-1],l=t[0].dims.length;if(i>0&&t.length>i&&t[i].dims.length>0)t[i].getFloat32Array().forEach(c=>a.push(c));else if(e.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(o>0&&t.length>o&&t[o].dims.length===1&&t[o].dims[0]>0){if(t[o].getFloat32Array().forEach(c=>s.push(c)),s.length!==0&&s.length!==l&&n>=18&&s.length!==e.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");ES(s,e),e.axes.length>0&&AS(s,e.axes,l).forEach((c,d)=>s[d]=c)}if(u>0&&t.length>u&&t[u].dims.length===1&&t[u].dims[0]>0&&(t[u].getBigInt64Array().forEach(c=>r.push(Number(c))),r.length!==0&&r.length!==l&&n>=18&&r.length!==e.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(e.axes.length>0){if(s.length!==0&&s.length!==e.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(r.length!==0&&r.length!==e.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof s<"u"&&typeof r<"u"&&s.length>0&&r.length>l)throw new Error("Resize requires only of scales or sizes to be specified")},Kf=(t,e,n,s)=>`
  // The whole part and the fractional part are calculated separately due to inaccuracy of floating
  // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an
  // offset-by-one error later in floor().
  let big = (${t}) * (${e});
  let whole = ${s}(big / (${n}));
  let fract = ${s}(big % (${n})) / ${s}(${n});
  return whole + fract;
`,DS=(t,e)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,
     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${e} { `+(()=>{switch(t){case"asymmetric":return`
          if (xScale < 1.0 || floor(xScale) != xScale) {
            return ${e}(xResized) / ${e}(xScale);
          } else {
            ${Kf("xResized","lengthOriginal","lengthResized",e)}
          }
        `;case"pytorch_half_pixel":return`if (lengthResized > 1) {
                    return (${e}(xResized) + 0.5) / ${e}(xScale) - 0.5;
                  } else {
                    return 0.0;
                  }`;case"tf_half_pixel_for_nn":return`return (${e}(xResized) + 0.5) / ${e}(xScale);`;case"align_corners":return`if (lengthResized == 1) {
                    return 0.0;
                  } else {
                    ${Kf("xResized","lengthOriginal - 1","lengthResized - 1",e)}
                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {
                    return ${e}(roiStart) * ${e}(lengthOriginal - 1) +
                        (${e}(xResized) * ${e}(roiEnd - roiStart) * ${e}(lengthOriginal - 1)) /
                        ${e}(lengthResized - 1);
                  } else {
                    return 0.5 * ${e}(roiStart + roiEnd) * ${e}(lengthOriginal - 1);
                  }`;case"half_pixel_symmetric":return`const outputWidth = ${e}xScale * ${e}(lengthResized);
                  const adjustment = ${e}(lengthResized) / outputWidth;
                  const center = ${e}(lengthOriginal) / 2;
                  const offset = center * (1 - adjustment);
                  return offset + ((${e}(xResized) + 0.5) / ${e}(xScale)) - 0.5;`;case"half_pixel":return`return ((${e}(xResized) + 0.5) / ${e}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${t} is not supported`)}})()+"}",OS=(t,e,n)=>`fn getNearestPixelFromOriginal(xOriginal: ${n}, isDownSample: bool) -> ${n} {`+(()=>{switch(t){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(e<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${t} is not supported`)}})()+"}",FS=(t,e,n)=>{let s=new Array(n).fill(0).concat(new Array(n).fill(1)),r=t.length===0?s:t.slice();return e.length>0?(e.forEach((a,i)=>{s[a]=r[i],s[i+n]=r[e.length+i]}),s):r},zS=(t,e,n,s)=>{let r=[];if(n.length>0)if(s.length>0){if(t.forEach(a=>r.push(a)),Math.max(...s)>t.length)throw new Error("axes is out of bound");s.forEach((a,i)=>r[a]=n[i])}else n.forEach(a=>r.push(a));else{if(e.length===0)throw new Error("Resize requires either scales or sizes.");r=t.map((a,i)=>Math.round(a*e[i]))}return r},LS=(t,e,n)=>{let s=(()=>{switch(n.keepAspectRatioPolicy){case"not_larger":return n.axes.length>0?Math.min(...n.axes.map(a=>e[a]),Number.MAX_VALUE):Math.min(...e,Number.MAX_VALUE);case"not_smaller":return n.axes.length>0?Math.max(...n.axes.map(a=>e[a]),Number.MIN_VALUE):Math.max(...e,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${n.keepAspectRatioPolicy} is not supported`)}})();e.fill(1,0,e.length);let r=t.slice();return n.axes.length>0?(n.axes.forEach(a=>e[a]=s),n.axes.forEach(a=>r[a]=Math.round(t[a]*e[a]))):(e.fill(s,0,e.length),r.forEach((a,i)=>r[i]=Math.round(a*e[i]))),r},PS=(t,e,n,s,r)=>`
    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${t.type.indices}) -> array<${t.type.value}, ${n.length}> {
      var original_indices: array<${t.type.value}, ${n.length}>;
      for (var i:u32 = 0; i < ${n.length}; i++) {
        var output_index = ${t.indicesGet("output_indices","i")};
        var scale = ${Se("uniforms.scales","i",s)};
        var roi_low = ${Se("uniforms.roi","i",r)};
        var roi_hi = ${Se("uniforms.roi",`i + ${e.length}`,r)};
        if (scale == 1.0) {
          original_indices[i] = ${t.type.value}(output_index);
        } else {
          var input_shape_i = ${Se("uniforms.input_shape","i",e.length)};
          var output_shape_i = ${Se("uniforms.output_shape","i",n.length)};
          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                           input_shape_i, roi_low, roi_hi);
        }
      }
      return original_indices;
    }`,BS=(t,e,n,s,r,a,i)=>`
    fn calculateInputIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> ${t.type.indices} {
      var input_indices: ${t.type.indices};
      for (var i:u32 = 0; i < ${s.length}; i++) {
        var output_index = ${e.indicesGet("output_indices","i")};
        var input_index: u32;
        var scale = ${Se("uniforms.scales","i",r)};
        if (scale == 1.0) {
          input_index = output_index;
        } else {
          var roi_low = ${Se("uniforms.roi","i",a)};
          var roi_hi = ${Se("uniforms.roi",`i + ${n.length}`,a)};
          var input_shape_i = ${Se("uniforms.input_shape","i",n.length)};
          var output_shape_i = ${Se("uniforms.output_shape","i",s.length)};
          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                        input_shape_i, roi_low, roi_hi);
          if (!${i} || (original_idx >= 0 && original_idx < ${e.type.value}(input_shape_i))) {
            if (original_idx < 0) {
              input_index = 0;
            } else if (original_idx > ${e.type.value}(input_shape_i - 1)) {
              input_index = input_shape_i - 1;
            } else {
              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));
            }
          } else {
            input_index = u32(original_idx);
          }
        }
        ${t.indicesSet("input_indices","i","input_index")}
      }
      return input_indices;
    }`,MS=(t,e)=>`
    fn checkInputIndices(input_indices: ${t.type.indices}) -> bool {
      for (var i:u32 = 0; i < ${e.length}; i++) {
        var input_index = ${t.indicesGet("input_indices","i")};
        if (input_index < 0 || input_index >= ${Se("uniforms.input_shape","i",e.length)}) {
          return false;
        }
      }
      return true;
    }`,Xf=(t,e,n,s)=>t.rank>s?`
    ${t.indicesSet("input_indices",e,"channel")};
    ${t.indicesSet("input_indices",n,"batch")};
`:"",VS=(t,e,n,s,r)=>{let[a,i,o,u]=n.length===2?[-1,0,1,-1]:[0,2,3,1],l=t.type.value;return`
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${l} {
      var input_indices: ${t.type.indices};
      ${t.indicesSet("input_indices",i,`max(0, min(row, ${n[i]} - 1))`)};
      ${t.indicesSet("input_indices",o,`max(0, min(col, ${n[o]} - 1))`)};
      ${Xf(t,u,a,2)}
      return ${t.getByIndices("input_indices")};
    }

    fn bilinearInterpolation(output_indices: ${e.type.indices}) -> ${l} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var row:${l} = originalIndices[${i}];
      var col:${l} = originalIndices[${o}];
      ${s?`if (row < 0 || row > (${n[i]} - 1) || col < 0 || col > (${n[o]} - 1)) {
        return ${r};
      }`:""};
      row = max(0, min(row, ${n[i]} - 1));
      col = max(0, min(col, ${n[o]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = ${n.length>2?`u32(originalIndices[${u}])`:"0"};
      var batch: u32 =  ${n.length>2?`u32(originalIndices[${a}])`:"0"};
      var x11: ${l} = getInputValue(batch, channel, row1, col1);
      var x12: ${l} = getInputValue(batch, channel, row1, col2);
      var x21: ${l} = getInputValue(batch, channel, row2, col1);
      var x22: ${l} = getInputValue(batch, channel, row2, col2);
      var dx1: ${l} = abs(row - ${l}(row1));
      var dx2: ${l} = abs(${l}(row2) - row);
      var dy1: ${l} = abs(col - ${l}(col1));
      var dy2: ${l} = abs(${l}(col2) - col);
      if (row1 == row2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (col1 == col2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`},WS=(t,e,n,s,r,a,i,o,u,l)=>{let c=n.length===2,[d,h]=c?[0,1]:[2,3],p=t.type.value,f=m=>{let g=m===d?"row":"col";return`
      fn ${g}CubicInterpolation(input_indices: ${t.type.indices}, output_indices: ${e.type.indices}) -> ${p} {
        var output_index = ${e.indicesGet("output_indices",m)};
        var originalIdx: ${p} = getOriginalCoordinateFromResizedCoordinate(output_index, ${r[m]},
        ${s[m]}, ${n[m]}, ${a[m]}, ${a[m]} + ${n.length});
        var fractOriginalIdx: ${p} = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${o} && (originalIdx < 0 || originalIdx > (${n[m]} - 1))) {
          return ${u};
        }
        var data: array<${p}, 4> = array<${p}, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${g}: ${p} = originalIdx + ${p}(i);
          if (${g} < 0 || ${g} >= ${n[m]}) {
            ${l?`coefs[i + 1] = 0.0;
                        continue;`:o?`return ${u};`:`${g} = max(0, min(${g}, ${n[m]} - 1));`};
          }
        var input_indices_copy: ${t.type.indices} = input_indices;
          ${t.indicesSet("input_indices_copy",m,`u32(${g})`)};
          data[i + 1] = ${m===d?t.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};
        }
        return cubicInterpolation1D(data, coefs);
      }`};return`
    ${f(d)};
    ${f(h)};
  fn getCubicInterpolationCoefs(s: ${p}) -> array<${p}, 4> {
    var absS = abs(s);
    var coeffs: array<${p}, 4> = array<${p}, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: ${p} = 1.0 - absS;
    var twoMinusAbsS: ${p} = 2.0 - absS;
    var onePlusAbsS: ${p} = 1.0 + absS;
    coeffs[0] = ((${i} * onePlusAbsS - 5 * ${i}) * onePlusAbsS + 8 * ${i}) * onePlusAbsS - 4 * ${i};
    coeffs[1] = ((${i} + 2) * absS - (${i} + 3)) * absS * absS + 1;
    coeffs[2] = ((${i} + 2) * oneMinusAbsS - (${i} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${i} * twoMinusAbsS - 5 * ${i}) * twoMinusAbsS + 8 * ${i}) * twoMinusAbsS - 4 * ${i};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<${p}, 4>, coefs: array<${p}, 4>) -> ${p} {
    var coefsSum: ${p} = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(output_indices: ${e.type.indices}) -> ${p} {
    var input_indices: ${t.type.indices} = output_indices;
    return colCubicInterpolation(input_indices, output_indices);
  }
    `},US=(t,e,n,s,r)=>{let[a,i,o,u,l]=n.length===3?[-1,0,1,2,-1]:[0,2,3,4,1],c=t.type.value;return`
    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${c} {
      var input_indices: ${t.type.indices};
      ${t.indicesSet("input_indices",i,`max(0, min(depth, ${n[i]} - 1))`)};
      ${t.indicesSet("input_indices",o,`max(0, min(height, ${n[o]} - 1))`)};
      ${t.indicesSet("input_indices",u,`max(0, min(width, ${n[u]} - 1))`)};
      ${Xf(t,l,a,3)}
      return ${t.getByIndices("input_indices")};
    }

    fn trilinearInterpolation(output_indices: ${e.type.indices}) -> ${c} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var depth:${c} = originalIndices[${i}];
      var height:${c} = originalIndices[${o}];
      var width:${c} = originalIndices[${u}];
      ${s?`if (depth < 0 || depth > (${n[i]} - 1) || height < 0 || height > (${n[o]} - 1) || width < 0 || (width > ${n[u]} - 1)) {
      return ${r};
        }`:""};

    depth = max(0, min(depth, ${n[i]} - 1));
      height = max(0, min(height, ${n[o]} - 1));
      width = max(0, min(width, ${n[u]} - 1));
      var depth1: u32 = u32(depth);
      var height1: u32 = u32(height);
      var width1: u32 = u32(width);
      var depth2: u32 = u32(depth + 1);
      var height2: u32 = u32(height + 1);
      var width2: u32 = u32(width + 1);
      var channel: u32 = ${n.length>3?`u32(originalIndices[${l}])`:"0"};
      var batch: u32 =  ${n.length>3?`u32(originalIndices[${a}])`:"0"};

      var x111: ${c} = getInputValue(batch, channel, depth1, height1, width1);
      var x112: ${c} = getInputValue(batch, channel, depth1, height1, width2);
      var x121: ${c} = getInputValue(batch, channel, depth1, height2, width1);
      var x122: ${c} = getInputValue(batch, channel, depth1, height2, width2);
      var x211: ${c} = getInputValue(batch, channel, depth2, height1, width1);
      var x212: ${c} = getInputValue(batch, channel, depth2, height1, width2);
      var x221: ${c} = getInputValue(batch, channel, depth2, height2, width1);
      var x222: ${c} = getInputValue(batch, channel, depth2, height2, width2);
      var dx1: ${c} = abs(depth - ${c}(depth1));
      var dx2: ${c} = abs(${c}(depth2) - depth);
      var dy1: ${c} = abs(height - ${c}(height1));
      var dy2: ${c} = abs(${c}(height2) - height);
      var dz1: ${c} = abs(width - ${c}(width1));
      var dz2: ${c} = abs(${c}(width2) - width);
      if (depth1 == depth2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (height1 == height2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      if (width1 == width2) {
        dz1 = 0.5;
        dz2 = 0.5;
      }
      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +
              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);
    }`},GS=(t,e,n,s,r,a)=>{let i=t.dims,o=FS(a,e.axes,i.length),u=zS(i,s,r,e.axes),l=s.slice();s.length===0&&(l=i.map((b,$)=>b===0?1:u[$]/b),e.keepAspectRatioPolicy!=="stretch"&&(u=LS(i,l,e)));let c=ve("output",t.dataType,u.length),d=ue("input",t.dataType,i.length),h=re.size(u),p=i.length===u.length&&i.every((b,$)=>b===u[$]),f=e.coordinateTransformMode==="tf_crop_and_resize",m=e.extrapolationValue,g=d.type.value,y=b=>`
      ${p?"":`
      ${DS(e.coordinateTransformMode,g)};
      ${(()=>{switch(e.mode){case"nearest":return`
              ${MS(d,i)};
              ${OS(e.nearestMode,n,g)};
              ${BS(d,c,i,u,l.length,o.length,f)};
              `;case"linear":return`
              ${PS(c,i,u,l.length,o.length)};
              ${(()=>{if(i.length===2||i.length===4)return`${VS(d,c,i,f,m)}`;if(i.length===3||i.length===5)return`${US(d,c,i,f,m)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};
            `;case"cubic":return`
            ${(()=>{if(i.length===2||i.length===4)return`${WS(d,c,i,u,l,o,e.cubicCoeffA,f,e.extrapolationValue,e.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};
            `;default:throw Error("Invalid resize mode")}})()};
      `}
      ${b.registerUniform("output_size","u32").registerUniform("scales","f32",l.length).registerUniform("roi","f32",o.length).declareVariables(d,c)}
      ${b.mainStart()}
        ${b.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
        ${p?"output[global_idx] = input[global_idx];":`
        let output_indices = ${c.offsetToIndices("global_idx")};
        var input_indices: ${d.type.indices};
        ${(()=>{switch(e.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);
                if (checkInputIndices(input_indices)) {
                  output[global_idx] = ${d.getByIndices("input_indices")};
                } else {
                  output[global_idx] = ${e.extrapolationValue};
                }`;case"linear":return`output[global_idx] = ${i.length===2||i.length===4?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${e.mode}`)}})()};
`}
      }`;return{name:"Resize",shaderCache:{hint:`${e.cacheKey}|${n}|${l.length>0?e.mode==="cubic"?l:l.length:""}|${r.length>0?r:""}|${o.length>0?o:""}|${p}|${e.mode==="nearest"?i.length:i}`,inputDependencies:["rank"]},getShaderSource:y,getRunData:()=>({outputs:[{dims:u,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:[{type:12,data:h},{type:1,data:l},{type:1,data:o},...Ce(i,u)]})}},HS=t=>{let e=t.customDataBuffer;return new Uint32Array(e,e.byteOffset,1)[0]},TO=(t,e)=>{let n=[],s=[],r=[],a=HS(t);if(e.antialias!==0)throw Error("Only default value (0) for Antialias attribute is supported");RS(t.inputs,e,a,n,s,r),t.compute(GS(t.inputs[0],e,a,n,s,r),{inputs:[0]})},NO=t=>{let e=t.antialias,n=t.axes,s=t.coordinateTransformMode,r=t.cubicCoeffA,a=t.excludeOutside!==0,i=t.extrapolationValue,o=t.keepAspectRatioPolicy,u=t.mode,l=t.nearestMode===""?"simple":t.nearestMode;return lt({antialias:e,axes:n,coordinateTransformMode:s,cubicCoeffA:r,excludeOutside:a,extrapolationValue:i,keepAspectRatioPolicy:o,mode:u,nearestMode:l})}}),qS,jS,EO,Wle=he(()=>{De(),Be(),Me(),qS=t=>{if(!t||t.length<3)throw new Error("layerNorm requires at least 3 inputs.");let e=t[0],n=t[1],s=t[2];if(e.dataType!==n.dataType||e.dataType!==s.dataType)throw new Error("All inputs must have the same data type");if(e.dims.length!==3&&e.dims.length!==2)throw new Error("Input must be 2D or 3D");if(n.dims.length!==3&&n.dims.length!==2)throw new Error("Skip must be 2D or 3D");let r=e.dims[e.dims.length-1],a=e.dims[e.dims.length-2];if(n.dims[n.dims.length-1]!==r)throw new Error("Skip must have the same hidden size as input");if(n.dims[n.dims.length-2]!==a)throw new Error("Skip must have the same sequence length as input");if(s.dims.length!==1)throw new Error("Gamma must be 1D");if(s.dims[s.dims.length-1]!==r)throw new Error("Gamma must have the same hidden size as input");if(t.length>3){let i=t[3];if(i.dims.length!==1)throw new Error("Beta must be 1D");if(i.dims[i.dims.length-1]!==r)throw new Error("Beta must have the same hidden size as input")}if(t.length>4){let i=t[4];if(i.dims.length!==1)throw new Error("Bias must be 1D");if(i.dims[i.dims.length-1]!==r)throw new Error("Bias must have the same hidden size as input")}},jS=(t,e,n,s)=>{let r=e.simplified,a=t[0].dims,i=re.size(a),o=a,u=i,l=a.slice(-1)[0],c=s?a.slice(0,-1).concat(1):[],d=!r&&t.length>3,h=t.length>4,p=s&&n>1,f=s&&n>2,m=n>3,g=64,y=Nt(l),b=[{type:12,data:u},{type:12,data:y},{type:12,data:l},{type:1,data:e.epsilon}],$=v=>{let k=[{name:"output_size",type:"u32"},{name:"components",type:"u32"},{name:"hidden_size",type:"u32"},{name:"epsilon",type:"f32"}],C=[ue("x",t[0].dataType,t[0].dims,y),ue("skip",t[1].dataType,t[1].dims,y),ue("gamma",t[2].dataType,t[2].dims,y)];d&&C.push(ue("beta",t[3].dataType,t[3].dims,y)),h&&C.push(ue("bias",t[4].dataType,t[4].dims,y)),C.push(ve("output",t[0].dataType,o,y)),p&&C.push(ve("mean_output",1,c)),f&&C.push(ve("inv_std_output",1,c)),m&&C.push(ve("input_skip_bias_sum",t[0].dataType,o,y));let N=sn(t[0].dataType),A=sn(1,y);return`

      ${v.registerUniforms(k).declareVariables(...C)}
      var<workgroup> sum_shared : array<${A}, ${g}>;
      var<workgroup> sum_squared_shared : array<${A}, ${g}>;

      ${v.mainStart([g,1,1])}
        let ix = local_id.x;
        let iy = global_id.x / ${g};

        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;
        var stride = hidden_size_vectorized / ${g};
        let offset = ix * stride + iy * hidden_size_vectorized;
        let offset1d = stride * ix;
        if (ix == ${g-1}) {
          stride = hidden_size_vectorized - stride * ix;
        }
        for (var i: u32 = 0; i < stride; i++) {
          let skip_value = skip[offset + i];
          let bias_value = ${h?"bias[offset1d + i]":N+"(0.0)"};
          let input_value = x[offset + i];
          let value = input_value + skip_value + bias_value;
          ${m?"input_skip_bias_sum[offset + i] = value;":""}
          output[offset + i] = value;
          let f32_value = ${Pi(N,y,"value")};
          sum_shared[ix] += f32_value;
          sum_squared_shared[ix] += f32_value * f32_value;
        }
        workgroupBarrier();

        var reduce_size : u32 = ${g};
        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {
          reduce_size = curr_size + (reduce_size & 1);
          if (ix < curr_size) {
            sum_shared[ix] += sum_shared[ix + reduce_size];
            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];
          }
          workgroupBarrier();
        }

        let sum = sum_shared[0];
        let square_sum = sum_squared_shared[0];
        let mean = ${pa("sum",y)} / f32(uniforms.hidden_size);
        let inv_std_dev = inverseSqrt(${pa("square_sum",y)} / f32(uniforms.hidden_size) ${r?"":"- mean * mean"} + uniforms.epsilon);
        ${p?"mean_output[global_idx] = mean;":""}
        ${f?"inv_std_output[global_idx] = inv_std_dev;":""}

        for (var i: u32 = 0; i < stride; i++) {
          output[offset + i] = (output[offset + i] ${r?"":`- ${N}(mean)`}) *
            ${N}(inv_std_dev) * gamma[offset1d + i]
            ${d?"+ beta[offset1d + i]":""};
        }
      }`},w=[{dims:o,dataType:t[0].dataType}];return n>1&&w.push({dims:c,dataType:1}),n>2&&w.push({dims:c,dataType:1}),n>3&&w.push({dims:a,dataType:t[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:`${y};${p};${f};${m}`,inputDependencies:t.map((v,k)=>"type")},getShaderSource:$,getRunData:()=>({outputs:w,dispatchGroup:{x:Math.ceil(u/l)},programUniforms:b})}},EO=(t,e)=>{qS(t.inputs);let n=[0];t.outputCount>1&&n.push(-3),t.outputCount>2&&n.push(-3),t.outputCount>3&&n.push(3),t.compute(jS(t.inputs,e,t.outputCount,!1),{outputs:n})}}),KS,Vo,XS,Yf,YS,ZS,AO,RO,Ule=he(()=>{De(),Be(),Ot(),Me(),KS=(t,e)=>{if(!t||t.length<1)throw new Error("too few inputs");if(e.axes.length!==0){if(e.axes.length!==e.starts.length||e.axes.length!==e.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(e.starts.length!==e.ends.length)throw new Error("starts and ends must have the same length");t.slice(1).forEach((n,s)=>{if(t[s+1].dataType!==6&&t[s+1].dataType!==7)throw new Error(`Input ${s} must be an array of int32 or int64`)})},Vo=(t,e)=>{let n=[];if(t.length>e)if(t[e].dataType===7)t[e].getBigInt64Array().forEach(s=>n.push(Number(s)));else if(t[e].dataType===6)t[e].getInt32Array().forEach(s=>n.push(Number(s)));else throw new Error(`Input ${e} must be an array of int32 or int64`);return n},XS=(t,e)=>{if(t.length>1){let n=Vo(t,1),s=Vo(t,2),r=Vo(t,3);return r.length===0&&(r=[...Array(t[0].dims.length).keys()]),lt({starts:n,ends:s,axes:r})}else return e},Yf=(t,e,n,s,r)=>{let a=t;return t<0&&(a+=n[s[e]]),r[e]<0?Math.max(0,Math.min(a,n[s[e]]-1)):Math.max(0,Math.min(a,n[s[e]]))},YS=(t,e,n)=>`fn calculateInputIndices(output_indices: ${e.type.indices}) -> ${t.type.indices} {
          var input_indices: ${t.type.indices};
          var carry = 0u;
          for (var i = ${n.length-1}; i >= 0; i--) {
            let input_shape_i = ${Se("uniforms.input_shape","i",n.length)};
            let steps_i = ${Se("uniforms.steps","i",n.length)};
            let signs_i = ${Se("uniforms.signs","i",n.length)};
            let starts_i = ${Se("uniforms.starts","i",n.length)};
            var output_index = ${e.indicesGet("output_indices","i")};
            var input_index = output_index * steps_i + starts_i + carry;
            carry = input_index / input_shape_i;
            input_index = input_index % input_shape_i;
            if (signs_i < 0) {
              input_index = input_shape_i - input_index - 1u + starts_i;
            }
            ${t.indicesSet("input_indices","i","input_index")};
          }
          return input_indices;
      }`,ZS=(t,e)=>{let n=t[0].dims,s=re.size(n),r=e.axes.length>0?re.normalizeAxes(e.axes,n.length):[...Array(n.length).keys()],a=Vo(t,4);a.forEach(y=>y!==0||(()=>{throw new Error("step cannot be 0")})),a.length===0&&(a=Array(r.length).fill(1));let i=e.starts.map((y,b)=>Yf(y,b,n,r,a)),o=e.ends.map((y,b)=>Yf(y,b,n,r,a));if(r.length!==i.length||r.length!==o.length)throw new Error("start, ends and axes should have the same number of elements");if(r.length!==n.length)for(let y=0;y<n.length;++y)r.includes(y)||(i.splice(y,0,0),o.splice(y,0,n[y]),a.splice(y,0,1));let u=a.map(y=>Math.sign(y));a.forEach((y,b,$)=>{if(y<0){let w=(o[b]-i[b])/y,v=i[b],k=v+w*a[b];i[b]=k,o[b]=v,$[b]=-y}});let l=n.slice(0);r.forEach((y,b)=>{l[y]=Math.ceil((o[y]-i[y])/a[y])});let c={dims:l,dataType:t[0].dataType},d=ve("output",t[0].dataType,l.length),h=ue("input",t[0].dataType,t[0].dims.length),p=re.size(l),f=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:i.length},{name:"signs",type:"i32",length:u.length},{name:"steps",type:"u32",length:a.length}],m=[{type:12,data:p},{type:12,data:i},{type:6,data:u},{type:12,data:a},...Ce(t[0].dims,l)],g=y=>`
      ${y.registerUniforms(f).declareVariables(h,d)}
        ${YS(h,d,n)}
        ${y.mainStart()}
          ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let output_indices = ${d.offsetToIndices("global_idx")};
          let input_indices = calculateInputIndices(output_indices);
          ${d.setByOffset("global_idx",h.getByIndices("input_indices"))}
      }`;return{name:"Slice",shaderCache:{hint:`${u.length}_${i.length}_${a.length}`,inputDependencies:["rank"]},getShaderSource:g,getRunData:()=>({outputs:[c],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:m})}},AO=(t,e)=>{KS(t.inputs,e);let n=XS(t.inputs,e);t.compute(ZS(t.inputs,n),{inputs:[0]})},RO=t=>{let e=t.starts,n=t.ends,s=t.axes;return lt({starts:e,ends:n,axes:s})}}),QS,JS,DO,OO,Gle=he(()=>{De(),Be(),Ot(),ka(),Me(),QS=t=>{if(!t||t.length!==1)throw new Error("Softmax op requires 1 input.")},JS=(t,e)=>{let n=t.inputs[0],s=n.dims,r=re.size(s),a=s.length,i=re.normalizeAxis(e.axis,a),o=i<s.length-1,u,l=[];o?(l=Array.from({length:a},(C,N)=>N),l[i]=a-1,l[a-1]=i,u=t.compute(ss(n,l),{inputs:[n],outputs:[-1]})[0]):u=n;let c=u.dims,d=c[a-1],h=r/d,p=Nt(d),f=d/p,m=64;h===1&&(m=256);let g=(C,N)=>N===4?`max(max(${C}.x, ${C}.y), max(${C}.z, ${C}.w))`:N===2?`max(${C}.x, ${C}.y)`:N===3?`max(max(${C}.x, ${C}.y), ${C}.z)`:C,y=ue("x",u.dataType,u.dims,p),b=ve("result",u.dataType,u.dims,p),$=y.type.value,w=sn(u.dataType)==="f32"?`var threadMax = ${$}(-3.402823e+38f);`:`var threadMax = ${$}(-65504.0h);`,v=C=>`
      var<workgroup> rowMaxShared : ${$};
      var<workgroup> rowSumShared : ${$};
      var<workgroup> threadShared : array<${$}, ${m}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${$} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${$}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${C.registerUniform("packedCols","i32").declareVariables(y,b)}
      ${C.mainStart(m)}
        let gindex = i32(global_idx);
        let lindex = i32(local_idx);
        const wg = ${m};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${w}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${$}(${g("threadShared[0]",p)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${$}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${$}(${pa("threadShared[0]",p)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          var value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          // max operation protects against NaN since all values should be >=0
          value = max(value, ${$}(0.0));
          setValue(row, col, row_stride, value);
        }
      }`,k=t.compute({name:"Softmax",shaderCache:{hint:`${p};${m}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:c,dataType:u.dataType}],dispatchGroup:{x:h},programUniforms:[{type:6,data:f}]}),getShaderSource:v},{inputs:[u],outputs:[o?-1:0]})[0];o&&t.compute(ss(k,l),{inputs:[k]})},DO=(t,e)=>{QS(t.inputs),JS(t,e)},OO=t=>lt({axis:t.axis})}),Zf,eI,tI,nI,FO,Hle=he(()=>{De(),Be(),Me(),Zf=t=>Array.from(t.getBigInt64Array(),Number),eI=t=>{if(!t||t.length!==2)throw new Error("Tile requires 2 inputs.");if(t[0].dataType!==1&&t[0].dataType!==10&&t[0].dataType!==6&&t[0].dataType!==12)throw new Error("Tile only support float, float16, int32, and uint32 data types");if(t[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(t[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(Zf(t[1]).length!==t[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},tI=(t,e)=>{let n=[];for(let s=0;s<t.length;++s)n.push(t[s]*e[s]);return n},nI=(t,e)=>{let n=t[0].dims,s=e??Zf(t[1]),r=tI(n,s),a=re.size(r),i=t[0].dataType,o=ue("input",i,n.length),u=ve("output",i,r.length),l=c=>`
      const inputShape = ${o.indices(...n)};
      ${c.registerUniform("output_size","u32").declareVariables(o,u)}
      ${c.mainStart()}
      ${c.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let output_indices = ${u.offsetToIndices("global_idx")};
      var input_indices: ${o.type.indices};
      for (var i = 0; i < ${n.length}; i++) {
        let input_dim_i = ${o.indicesGet("uniforms.input_shape","i")};
        let input_dim_value = ${u.indicesGet("output_indices","i")}  % input_dim_i;

        ${o.indicesSet("input_indices","i","input_dim_value")}
      }
      ${u.setByOffset("global_idx",o.getByIndices("input_indices"))}
    }`;return{name:"Tile",shaderCache:{hint:`${s}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:r,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:[{type:12,data:a},...Ce(t[0].dims,r)]}),getShaderSource:l}},FO=t=>{eI(t.inputs),t.compute(nI(t.inputs),{inputs:[0]})}}),sI,rI,zO,qle=he(()=>{De(),Be(),Me(),sI=(t,e,n,s,r)=>{let a=ve("output_data",r,n.length,4),i=ue("a_data",e[1].dataType,e[1].dims.length,4),o=ue("b_data",e[2].dataType,e[2].dims.length,4),u=ue("c_data",e[0].dataType,e[0].dims.length,4),l,c=(d,h,p)=>`select(${h}, ${d}, ${p})`;if(!s)l=a.setByOffset("global_idx",c(i.getByOffset("global_idx"),o.getByOffset("global_idx"),u.getByOffset("global_idx")));else{let d=(h,p,f="")=>{let m=`a_data[index_a${p}][component_a${p}]`,g=`b_data[index_b${p}][component_b${p}]`,y=`bool(c_data[index_c${p}] & (0xffu << (component_c${p} * 8)))`;return`
            let output_indices${p} = ${a.offsetToIndices(`global_idx * 4u + ${p}u`)};
            let offset_a${p} = ${i.broadcastedIndicesToOffset(`output_indices${p}`,a)};
            let offset_b${p} = ${o.broadcastedIndicesToOffset(`output_indices${p}`,a)};
            let offset_c${p} = ${u.broadcastedIndicesToOffset(`output_indices${p}`,a)};
            let index_a${p} = offset_a${p} / 4u;
            let index_b${p} = offset_b${p} / 4u;
            let index_c${p} = offset_c${p} / 4u;
            let component_a${p} = offset_a${p} % 4u;
            let component_b${p} = offset_b${p} % 4u;
            let component_c${p} = offset_c${p} % 4u;
            ${h}[${p}] = ${f}(${c(m,g,y)});
          `};r===9?l=`
            var data = vec4<u32>(0);
            ${d("data",0,"u32")}
            ${d("data",1,"u32")}
            ${d("data",2,"u32")}
            ${d("data",3,"u32")}
            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:l=`
            ${d("output_data[global_idx]",0)}
            ${d("output_data[global_idx]",1)}
            ${d("output_data[global_idx]",2)}
            ${d("output_data[global_idx]",3)}
          `}return`
        ${t.registerUniform("vec_size","u32").declareVariables(u,i,o,a)}
        ${t.mainStart()}
        ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${l}
      }`},rI=t=>{let e=t[1].dims,n=t[2].dims,s=t[0].dims,r=t[1].dataType,a=!(re.areEqual(e,n)&&re.areEqual(n,s)),i=e,o=re.size(e);if(a){let l=ro.calcShape(ro.calcShape(e,n,!1),s,!1);if(!l)throw new Error("Can't perform where op on the given tensors");i=l,o=re.size(i)}let u=Math.ceil(o/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:l=>sI(l,t,i,a,r),getRunData:()=>({outputs:[{dims:i,dataType:r}],dispatchGroup:{x:Math.ceil(o/64/4)},programUniforms:[{type:12,data:u},...Ce(s,e,n,i)]})}},zO=t=>{t.compute(rI(t.inputs))}}),LO,jle=he(()=>{ole(),M0(),ule(),lle(),cle(),dle(),hle(),yle(),xle(),wle(),$le(),vle(),Sle(),Ile(),_le(),kle(),Cle(),Tle(),Nle(),Ele(),Ale(),Rle(),Dle(),Ole(),Fle(),nO(),zle(),Lle(),Ple(),Ble(),Mle(),B0(),Vle(),oO(),Wle(),Ule(),Gle(),aO(),Hle(),ka(),V0(),qle(),LO=new Map([["Abs",[ER]],["Acos",[AR]],["Acosh",[RR]],["Add",[hD]],["ArgMax",[kR,ig]],["ArgMin",[_R,ig]],["Asin",[DR]],["Asinh",[OR]],["Atan",[FR]],["Atanh",[zR]],["Attention",[CR]],["AveragePool",[gO,mO]],["BatchNormalization",[TR]],["BiasAdd",[NR]],["BiasSplitGelu",[dD]],["Cast",[PR,LR]],["Ceil",[MR]],["Clip",[BR]],["Concat",[vD,SD]],["Conv",[hg,dg]],["ConvTranspose",[DD,RD]],["Cos",[VR]],["Cosh",[WR]],["CumSum",[OD,FD]],["DepthToSpace",[zD,LD]],["DequantizeLinear",[SO,IO]],["Div",[pD]],["Einsum",[PD,BD]],["Elu",[UR,Qo]],["Equal",[fD]],["Erf",[GR]],["Exp",[HR]],["Expand",[MD]],["FastGelu",[VD]],["Floor",[qR]],["FusedConv",[hg,dg]],["Gather",[UD,WD]],["GatherElements",[XD,KD]],["GatherBlockQuantized",[qD,jD]],["GatherND",[GD,HD]],["Gelu",[jR]],["Gemm",[ZD,YD]],["GlobalAveragePool",[bO,yO]],["GlobalMaxPool",[vO,$O]],["Greater",[bD]],["GreaterOrEqual",[wD]],["GridSample",[QD,JD]],["GroupQueryAttention",[uO]],["HardSigmoid",[tD,eD]],["InstanceNormalization",[lO]],["LayerNormalization",[cO]],["LeakyRelu",[KR,Qo]],["Less",[xD]],["LessOrEqual",[$D]],["Log",[lD]],["MatMul",[dO]],["MatMulNBits",[hO,pO]],["MaxPool",[xO,wO]],["Mul",[mD]],["MultiHeadAttention",[tO,eO]],["Neg",[YR]],["Not",[XR]],["Pad",[fO]],["Pow",[gD]],["QuickGelu",[cD,Qo]],["Range",[_O]],["Reciprocal",[ZR]],["ReduceMin",[wR]],["ReduceMean",[mR]],["ReduceMax",[xR]],["ReduceSum",[vR]],["ReduceProd",[$R]],["ReduceL1",[gR]],["ReduceL2",[yR]],["ReduceLogSum",[IR]],["ReduceLogSumExp",[bR]],["ReduceSumSquare",[SR]],["Relu",[QR]],["Resize",[TO,NO]],["RotaryEmbedding",[iO]],["ScatterND",[CO,kO]],["Sigmoid",[JR]],["Sin",[nD]],["Sinh",[sD]],["Slice",[AO,RO]],["SkipLayerNormalization",[EO]],["Split",[sO,rO]],["Sqrt",[rD]],["Softmax",[DO,OO]],["Sub",[yD]],["Tan",[aD]],["Tanh",[iD]],["ThresholdedRelu",[uD,Qo]],["Tile",[FO]],["Transpose",[sR,rR]],["Where",[zO]]])}),PO,Kle=he(()=>{Ts(),Br(),Me(),PO=class{constructor(t){this.backend=t,this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,e){this.repo.set(t,e)}run(t,e,n,s,r){br(t.programInfo.name);let a=this.backend.device,i=this.backend.getComputePassEncoder();this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2);let o=[];for(let l of e)o.push({binding:o.length,resource:{buffer:l.buffer}});for(let l of n)o.push({binding:o.length,resource:{buffer:l.buffer}});r&&o.push({binding:o.length,resource:r});let u=a.createBindGroup({layout:t.computePipeline.getBindGroupLayout(0),entries:o,label:t.programInfo.name});if(this.backend.sessionStatus==="capturing"){let l={kernelId:this.backend.currentKernelId,computePipeline:t.computePipeline,bindGroup:u,dispatchGroup:s};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(l)}i.setPipeline(t.computePipeline),i.setBindGroup(0,u),i.dispatchWorkgroups(...s),this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||this.backend.queryType==="at-passes")&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),js(t.programInfo.name)}dispose(){}build(t,e){br(t.name);let n=this.backend.device,s=[];[{feature:"shader-f16",extension:"f16"},{feature:"subgroups",extension:"subgroups"}].forEach(l=>{n.features.has(l.feature)&&s.push(`enable ${l.extension};`)});let r=nR(e,this.backend.device.limits),a=t.getShaderSource(r),i=`${s.join(`
`)}
${r.additionalImplementations}
${a}`,o=n.createShaderModule({code:i,label:t.name});et("verbose",()=>`[WebGPU] ${t.name} shader code: ${i}`);let u=n.createComputePipeline({compute:{module:o,entryPoint:"main"},layout:"auto",label:t.name});return js(t.name),{programInfo:t,computePipeline:u,uniformVariablesInfo:r.variablesInfo}}normalizeDispatchGroupSize(t){let e=typeof t=="number"?t:t.x,n=typeof t=="number"?1:t.y||1,s=typeof t=="number"?1:t.z||1,r=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(e<=r&&n<=r&&s<=r)return[e,n,s];let a=e*n*s,i=Math.ceil(Math.sqrt(a));if(i>r){if(i=Math.ceil(Math.cbrt(a)),i>r)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[i,i,i]}else return[i,i,1]}}}),BO={};_o(BO,{WebGpuBackend:()=>MO});var aI,iI,oI,MO,Xle=he(()=>{Ts(),De(),Br(),ZA(),ale(),jle(),Kle(),aI=(t,e)=>{if(e.length!==t.length)throw new Error(`inputDependencies length ${e.length} is not equal to inputTensors length ${t.length}.`);let n=[];for(let s=0;s<t.length;++s){let r=t[s].dataType;switch(e[s]){case"none":{n.push("");break}case"type":{n.push(`${r}`);break}case"rank":{let a=t[s].dims.length;n.push(`${r};${a}`);break}case"dims":{let a=t[s].dims.join(",");n.push(`${r};${a}`);break}default:throw new Error(`unsupported input dependency: ${e[s]}`)}}return n.join("|")},iI=(t,e,n)=>{var r,a;let s=t.name;return(r=t.shaderCache)!=null&&r.hint&&(s+="["+t.shaderCache.hint+"]"),s+=":"+n+`:${aI(e,((a=t.shaderCache)==null?void 0:a.inputDependencies)??new Array(e.length).fill("dims"))}`,s},oI=class{constructor(t){t&&(this.architecture=t.architecture,this.vendor=t.vendor)}isArchitecture(t){return this.architecture===t}isVendor(t){return this.vendor===t}},MO=class{constructor(){this.currentSessionId=null,this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.maxDispatchNumber=16,this.pendingDispatchNumber=0,this.pendingKernels=[],this.pendingQueries=new Map,this.sessionStatus="default",this.capturedCommandList=new Map,this.capturedPendingKernels=new Map,this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let t=this.kernelCustomData.get(this.currentKernelId);return t||(t={},this.kernelCustomData.set(this.currentKernelId,t)),t}async initialize(t,e){this.env=t;let n=[],s={requiredLimits:{maxComputeWorkgroupStorageSize:e.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:e.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:e.limits.maxStorageBufferBindingSize,maxBufferSize:e.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:e.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:e.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:e.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:e.limits.maxComputeWorkgroupSizeZ},requiredFeatures:n},r=a=>e.features.has(a)&&n.push(a)&&!0;r("chromium-experimental-timestamp-query-inside-passes")||r("timestamp-query"),r("shader-f16"),r("subgroups"),this.device=await e.requestDevice(s),this.adapterInfo=new oI(e.info||await e.requestAdapterInfo()),this.gpuDataManager=eR(this),this.programManager=new PO(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,F0(t.logLevel,!!t.debug),this.device.onuncapturederror=a=>{a.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${a.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,"adapter",{value:e,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let t=this.getCommandEncoder(),e={};this.queryType==="at-passes"&&(e.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispatchNumber*2,endOfPassWriteIndex:this.pendingDispatchNumber*2+1}),this.computePassEncoder=t.beginComputePass(e)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;br(),this.endComputePass();let t;this.queryType!=="none"&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispatchNumber*2,this.queryResolveBuffer,0),t=this.device.createBuffer({size:this.pendingDispatchNumber*2*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(t,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,t,0,this.pendingDispatchNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,this.queryType!=="none"&&t.mapAsync(GPUMapMode.READ).then(()=>{var s;let e=new BigUint64Array(t.getMappedRange()),n=this.pendingQueries.get(t);for(let r=0;r<e.length/2;r++){let a=n[r],i=a.kernelId,o=this.kernels.get(i),u=o.kernelType,l=o.kernelName,c=a.programName,d=a.inputTensorViews,h=a.outputTensorViews,p=e[r*2],f=e[r*2+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=p);let m=Number(p-this.queryTimeBase),g=Number(f-this.queryTimeBase);if(!Number.isSafeInteger(m)||!Number.isSafeInteger(g))throw new RangeError("incorrect timestamp range");if((s=this.env.webgpu.profiling)!=null&&s.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:d.map(y=>({dims:y.dims,dataType:Cr(y.dataType)})),outputsMetadata:h.map(y=>({dims:y.dims,dataType:Cr(y.dataType)})),kernelId:i,kernelType:u,kernelName:l,programName:c,startTime:m,endTime:g});else{let y="";d.forEach(($,w)=>{y+=`input[${w}]: [${$.dims}] | ${Cr($.dataType)}, `});let b="";h.forEach(($,w)=>{b+=`output[${w}]: [${$.dims}] | ${Cr($.dataType)}, `}),console.log(`[profiling] kernel "${i}|${u}|${l}|${c}" ${y}${b}start time: ${m} ns, execution time: ${g-m} ns`)}hd("GPU",`${c}::${p}::${f}`)}t.unmap(),this.pendingQueries.delete(t)}),js()}run(t,e,n,s,r,a){br(t.name);let i=[];for(let b=0;b<e.length;++b){let $=e[b].data;if($===0)continue;let w=this.gpuDataManager.get($);if(!w)throw new Error(`no GPU data for input: ${$}`);i.push(w)}let{outputs:o,dispatchGroup:u,programUniforms:l}=t.getRunData(e),c=n.length===0?o.map((b,$)=>$):n;if(c.length!==o.length)throw new Error(`Output size ${c.length} must be equal to ${o.length}.`);let d=[],h=[];for(let b=0;b<o.length;++b){if(!Number.isInteger(c[b])||c[b]<-3||c[b]>=a)throw new Error(`Invalid output index: ${c[b]}`);if(c[b]===-3)continue;let $=c[b]===-1,w=c[b]===-2,v=$||w?r(o[b].dataType,o[b].dims):s(c[b],o[b].dataType,o[b].dims);if(d.push(v),v.data===0)continue;let k=this.gpuDataManager.get(v.data);if(!k)throw new Error(`no GPU data for output: ${v.data}`);if($&&this.temporaryData.push(k),w){let C=this.kernelPersistentData.get(this.currentKernelId);C||(C=[],this.kernelPersistentData.set(this.currentKernelId,C)),C.push(k)}h.push(k)}if(i.length!==e.length||h.length!==d.length){if(h.length===0)return js(t.name),d;throw new Error(`Program ${t.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}let p;if(l){let b=0,$=[];l.forEach(C=>{let N=typeof C.data=="number"?[C.data]:C.data;if(N.length===0)return;let A=C.type===10?2:4,I,E;C.type===10?(E=N.length>4?16:N.length>2?8:N.length*A,I=N.length>4?16:A*N.length):(E=N.length<=2?N.length*A:16,I=16),b=Math.ceil(b/E)*E,$.push(b);let z=C.type===10?8:4;b+=N.length>4?Math.ceil(N.length/z)*I:N.length*A});let w=16;b=Math.ceil(b/w)*w;let v=new ArrayBuffer(b);l.forEach((C,N)=>{let A=$[N],I=typeof C.data=="number"?[C.data]:C.data;if(C.type===6)new Int32Array(v,A,I.length).set(I);else if(C.type===12)new Uint32Array(v,A,I.length).set(I);else if(C.type===10)new Uint16Array(v,A,I.length).set(I);else if(C.type===1)new Float32Array(v,A,I.length).set(I);else throw new Error(`Unsupported uniform type: ${Cr(C.type)}`)});let k=this.gpuDataManager.create(b,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(k.buffer,0,v,0,b),this.gpuDataManager.release(k.id),p={offset:0,size:b,buffer:k.buffer}}let f=this.programManager.normalizeDispatchGroupSize(u),m=f[1]===1&&f[2]===1,g=iI(t,e,m),y=this.programManager.getArtifact(g);if(y||(y=this.programManager.build(t,f),this.programManager.setArtifact(g,y),et("info",()=>`[artifact] key: ${g}, programName: ${t.name}`)),l&&y.uniformVariablesInfo){if(l.length!==y.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${y.uniformVariablesInfo.length}, got ${l.length} in program "${y.programInfo.name}".`);for(let b=0;b<l.length;b++){let $=l[b],w=$.type,v=typeof $.data=="number"?1:$.data.length,[k,C]=y.uniformVariablesInfo[b];if(w!==k||v!==C)throw new Error(`Uniform variable ${b} mismatch: expect type ${k} with size ${C}, got type ${w} with size ${v} in program "${y.programInfo.name}".`)}}if(et("info",()=>`[ProgramManager] run "${t.name}" (key=${g}) with ${f[0]}x${f[1]}x${f[2]}`),this.queryType!=="none"||this.sessionStatus==="capturing"){let b={kernelId:this.currentKernelId,programName:y.programInfo.name,inputTensorViews:e,outputTensorViews:d};this.pendingKernels.push(b),this.sessionStatus==="capturing"&&this.capturedPendingKernels.get(this.currentSessionId).push(b)}return this.programManager.run(y,i,h,f,p),js(t.name),d}upload(t,e){this.gpuDataManager.upload(t,e)}memcpy(t,e){this.gpuDataManager.memcpy(t,e)}async download(t,e){await this.gpuDataManager.download(t,e)}alloc(t){return this.gpuDataManager.create(t).id}free(t){return this.gpuDataManager.release(t)}createKernel(t,e,n,s){let r=LO.get(t);if(!r)throw new Error(`kernel not implemented: ${t}`);let a={kernelType:t,kernelName:s,kernelEntry:r[0],attributes:[r[1],n]};this.kernels.set(e,a)}releaseKernel(t){let e=this.kernelPersistentData.get(t);if(e){for(let n of e)this.gpuDataManager.release(n.id);this.kernelPersistentData.delete(t)}this.kernelCustomData.delete(t),this.kernels.delete(t)}computeKernel(t,e,n){let s=this.kernels.get(t);if(!s)throw new Error(`kernel not created: ${t}`);let r=s.kernelType,a=s.kernelName,i=s.kernelEntry,o=s.attributes;if(this.currentKernelId!==null)throw new Error(`kernel "[${r}] ${a}" is not allowed to be called recursively`);this.currentKernelId=t,o[0]&&(o[1]=o[0](o[1]),o[0]=void 0),et("info",()=>`[WebGPU] Start to run kernel "[${r}] ${a}"...`);let u=this.env.debug;this.temporaryData=[];try{return u&&this.device.pushErrorScope("validation"),i(e,o[1]),0}catch(l){return n.push(Promise.resolve(`[WebGPU] Kernel "[${r}] ${a}" failed. ${l}`)),1}finally{u&&n.push(this.device.popErrorScope().then(l=>l?`GPU validation error for kernel "[${r}] ${a}": ${l.message}`:null));for(let l of this.temporaryData)this.gpuDataManager.release(l.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(t,e,n,s){let r=this.sessionExternalDataMapping.get(t);r||(r=new Map,this.sessionExternalDataMapping.set(t,r));let a=r.get(e),i=this.gpuDataManager.registerExternalBuffer(n,s,a);return r.set(e,[i,n]),i}unregisterBuffers(t){let e=this.sessionExternalDataMapping.get(t);e&&(e.forEach(n=>this.gpuDataManager.unregisterExternalBuffer(n[0])),this.sessionExternalDataMapping.delete(t))}getBuffer(t){let e=this.gpuDataManager.get(t);if(!e)throw new Error(`no GPU data for buffer: ${t}`);return e.buffer}createDownloader(t,e,n){return async()=>{let s=await sg(this,t,e);return z0(s.buffer,n)}}writeTimestamp(t){this.queryType==="inside-passes"&&this.computePassEncoder.writeTimestamp(this.querySet,t)}setQueryType(){var t;this.queryType="none",(((t=this.env.webgpu.profiling)==null?void 0:t.mode)==="default"||(typeof this.env.trace>"u"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"),this.queryType!=="none"&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.maxDispatchNumber*2}),this.queryResolveBuffer=this.device.createBuffer({size:this.maxDispatchNumber*2*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){et("info","captureBegin"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus="capturing"}captureEnd(){et("info","captureEnd"),this.flush(),this.sessionStatus="default"}replay(){et("info","replay"),this.sessionStatus="replaying";let t=this.capturedCommandList.get(this.currentSessionId),e=this.capturedPendingKernels.get(this.currentSessionId),n=t.length;this.pendingKernels=[];for(let s=0;s<n;s++){let r=this.getComputePassEncoder(),a=t[s];this.writeTimestamp(this.pendingDispatchNumber*2),r.setPipeline(a.computePipeline),r.setBindGroup(0,a.bindGroup),r.dispatchWorkgroups(...a.dispatchGroup),this.writeTimestamp(this.pendingDispatchNumber*2+1),this.pendingDispatchNumber++,this.queryType!=="none"&&this.pendingKernels.push(e[s]),(this.pendingDispatchNumber>=this.maxDispatchNumber||this.queryType==="at-passes")&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus="default"}onCreateSession(){this.gpuDataManager.onCreateSession()}onReleaseSession(t){this.unregisterBuffers(t),this.capturedCommandList.has(t)&&this.capturedCommandList.delete(t),this.capturedPendingKernels.has(t)&&this.capturedPendingKernels.delete(t),this.gpuDataManager.onReleaseSession(t)}onRunStart(t){this.currentSessionId=t,this.setQueryType()}}}),VO={};_o(VO,{init:()=>WO});var $c,uI,WO,Yle=he(()=>{De(),Br(),Be(),rle(),$c=class UO{constructor(e,n,s,r){this.module=e,this.dataType=n,this.data=s,this.dims=r}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let e=re.size(this.dims);return e===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,e)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let e=re.size(this.dims);return e===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,e)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let e=re.size(this.dims);return e===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,e)}getUint16Array(){if(this.dataType!==10&&this.dataType!==4)throw new Error("Invalid data type");let e=re.size(this.dims);return e===0?new Uint16Array:new Uint16Array(this.module.HEAP8.buffer,this.data,e)}reshape(e){if(re.size(e)!==re.size(this.dims))throw new Error("Invalid new shape");return new UO(this.module,this.dataType,this.data,e)}},uI=class{constructor(t,e,n){this.module=t,this.backend=e,this.customDataOffset=0,this.customDataSize=0,this.adapterInfo=e.adapterInfo;let s=t.PTR_SIZE,r=n/t.PTR_SIZE,a=s===4?"i32":"i64";this.opKernelContext=Number(t.getValue(s*r++,a));let i=Number(t.getValue(s*r++,a));this.outputCount=Number(t.getValue(s*r++,a)),this.customDataOffset=Number(t.getValue(s*r++,"*")),this.customDataSize=Number(t.getValue(s*r++,a));let o=[];for(let u=0;u<i;u++){let l=Number(t.getValue(s*r++,a)),c=Number(t.getValue(s*r++,"*")),d=Number(t.getValue(s*r++,a)),h=[];for(let p=0;p<d;p++)h.push(Number(t.getValue(s*r++,a)));o.push(new $c(t,l,c,h))}this.inputs=o}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(t,e){var i;let n=((i=e==null?void 0:e.inputs)==null?void 0:i.map(o=>typeof o=="number"?this.inputs[o]:o))??this.inputs,s=(e==null?void 0:e.outputs)??[],r=(o,u,l)=>new $c(this.module,u,this.output(o,l),l),a=(o,u)=>{let l=Ga(o,u);if(!l)throw new Error(`Unsupported data type: ${o}`);let c=l>0?this.backend.gpuDataManager.create(l).id:0;return new $c(this.module,o,c,u)};return this.backend.run(t,n,s,r,a,this.outputCount)}output(t,e){let n=this.module.stackSave();try{let s=this.module.PTR_SIZE,r=s===4?"i32":"i64",a=this.module.stackAlloc((1+e.length)*s);this.module.setValue(a,e.length,r);for(let i=0;i<e.length;i++)this.module.setValue(a+s*(i+1),e[i],r);return this.module._JsepOutput(this.opKernelContext,t,a)}catch(s){throw new Error(`Failed to generate kernel's output[${t}] with dims [${e}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${s}`)}finally{this.module.stackRestore(n)}}},WO=async(t,e,n,s)=>{let r=e.jsepInit;if(!r)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");if(t==="webgpu"){let a=(Xle(),bu(BO)).WebGpuBackend,i=new a;await i.initialize(n,s),r("webgpu",[i,o=>i.alloc(Number(o)),o=>i.free(o),(o,u,l,c=!1)=>{if(c)et("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${Number(o)}, dst=${Number(u)}, size=${Number(l)}`),i.memcpy(Number(o),Number(u));else{et("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${Number(o)}, gpuDataId=${Number(u)}, size=${Number(l)}`);let d=e.HEAPU8.subarray(Number(o>>>0),Number(o>>>0)+Number(l));i.upload(Number(u),d)}},async(o,u,l)=>{et("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${o}, dataOffset=${u}, size=${l}`),await i.download(Number(o),()=>e.HEAPU8.subarray(Number(u)>>>0,Number(u+l)>>>0))},(o,u,l)=>i.createKernel(o,Number(u),l,e.UTF8ToString(e._JsepGetNodeName(Number(u)))),o=>i.releaseKernel(o),(o,u,l,c)=>{et("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${l}, kernel=${o}, contextDataOffset=${u}`);let d=new uI(e,i,Number(u));return i.computeKernel(Number(o),d,c)},()=>i.captureBegin(),()=>i.captureEnd(),()=>i.replay()])}else{let a=new JA(n);r("webnn",[a,()=>a.reserveTensorId(),i=>a.releaseTensorId(i),async(i,o,u,l,c)=>a.ensureTensor(i,o,u,l,c),(i,o)=>{a.uploadTensor(i,o)},async(i,o)=>a.downloadTensor(i,o),(i,o)=>a.registerMLContext(i,o),!!n.trace])}}}),lI,j0,K0,jr,cI,Qf,xd,X0,Y0,Jf,Z0,Q0,J0,GO=he(()=>{Ts(),tle(),nle(),De(),ki(),A0(),jA(),lI=(t,e)=>{bt()._OrtInit(t,e)!==0&&dt("Can't initialize onnxruntime.")},j0=async t=>{lI(t.wasm.numThreads,fd(t.logLevel))},K0=async(t,e)=>{var s,r;(r=(s=bt()).asyncInit)==null||r.call(s);let n=t.webgpu.adapter;if(e==="webgpu"){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");if(n){if(typeof n.limits!="object"||typeof n.features!="object"||typeof n.requestDevice!="function")throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let a=t.webgpu.powerPreference;if(a!==void 0&&a!=="low-power"&&a!=="high-performance")throw new Error(`Invalid powerPreference setting: "${a}"`);let i=t.webgpu.forceFallbackAdapter;if(i!==void 0&&typeof i!="boolean")throw new Error(`Invalid forceFallbackAdapter setting: "${i}"`);if(n=await navigator.gpu.requestAdapter({powerPreference:a,forceFallbackAdapter:i}),!n)throw new Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.')}}if(e==="webnn"&&(typeof navigator>"u"||!navigator.ml))throw new Error("WebNN is not supported in current environment");{let a=(Yle(),bu(VO)).init;e==="webgpu"&&await a("webgpu",bt(),t,n),e==="webnn"&&await a("webnn",bt(),t)}},jr=new Map,cI=t=>{let e=bt(),n=e.stackSave();try{let s=e.PTR_SIZE,r=e.stackAlloc(2*s);e._OrtGetInputOutputCount(t,r,r+s)!==0&&dt("Can't get session input/output count.");let a=s===4?"i32":"i64";return[Number(e.getValue(r,a)),Number(e.getValue(r+s,a))]}finally{e.stackRestore(n)}},Qf=(t,e)=>{let n=bt(),s=n.stackSave(),r=0;try{let a=n.PTR_SIZE,i=n.stackAlloc(2*a);n._OrtGetInputOutputMetadata(t,e,i,i+a)!==0&&dt("Can't get session input/output metadata.");let o=Number(n.getValue(i,"*"));r=Number(n.getValue(i+a,"*"));let u=n.HEAP32[r/4];if(u===0)return[o,0];let l=n.HEAPU32[r/4+1],c=[];for(let d=0;d<l;d++){let h=Number(n.getValue(r+8+d*a,"*"));c.push(h!==0?n.UTF8ToString(h):Number(n.getValue(r+8+(d+l)*a,"*")))}return[o,u,c]}finally{n.stackRestore(s),r!==0&&n._OrtFree(r)}},xd=t=>{let e=bt(),n=e._malloc(t.byteLength);if(n===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${t.byteLength}.`);return e.HEAPU8.set(t,n),[n,t.byteLength]},X0=async(t,e)=>{var d,h,p,f;let n,s,r=bt();Array.isArray(t)?[n,s]=t:t.buffer===r.HEAPU8.buffer?[n,s]=[t.byteOffset,t.byteLength]:[n,s]=xd(t);let a=0,i=0,o=0,u=[],l=[],c=[];try{if([i,u]=await qA(e),(e==null?void 0:e.externalData)&&r.mountExternalData){let N=[];for(let A of e.externalData){let I=typeof A=="string"?A:A.path;N.push(O0(typeof A=="string"?A:A.data).then(E=>{r.mountExternalData(I,E)}))}await Promise.all(N)}for(let N of(e==null?void 0:e.executionProviders)??[])if((typeof N=="string"?N:N.name)==="webnn"){if(r.shouldTransferToMLTensor=!1,typeof N!="string"){let A=N,I=A==null?void 0:A.context,E=A==null?void 0:A.gpuDevice,z=A==null?void 0:A.deviceType,P=A==null?void 0:A.powerPreference;I?r.currentContext=I:E?r.currentContext=await r.webnnCreateMLContext(E):r.currentContext=await r.webnnCreateMLContext({deviceType:z,powerPreference:P})}else r.currentContext=await r.webnnCreateMLContext();break}a=await r._OrtCreateSession(n,s,i),(d=r.webgpuOnCreateSession)==null||d.call(r,a),a===0&&dt("Can't create a session."),(h=r.jsepOnCreateSession)==null||h.call(r),r.currentContext&&(r.webnnRegisterMLContext(a,r.currentContext),r.currentContext=void 0,r.shouldTransferToMLTensor=!0);let[m,g]=cI(a),y=!!(e!=null&&e.enableGraphCapture),b=[],$=[],w=[],v=[],k=[];for(let N=0;N<m;N++){let[A,I,E]=Qf(a,N);A===0&&dt("Can't get an input name."),l.push(A);let z=r.UTF8ToString(A);b.push(z),w.push(I===0?{name:z,isTensor:!1}:{name:z,isTensor:!0,type:Cr(I),shape:E})}for(let N=0;N<g;N++){let[A,I,E]=Qf(a,N+m);A===0&&dt("Can't get an output name."),c.push(A);let z=r.UTF8ToString(A);$.push(z),v.push(I===0?{name:z,isTensor:!1}:{name:z,isTensor:!0,type:Cr(I),shape:E});{if(y&&(e==null?void 0:e.preferredOutputLocation)===void 0){k.push("gpu-buffer");continue}let P=typeof(e==null?void 0:e.preferredOutputLocation)=="string"?e.preferredOutputLocation:((p=e==null?void 0:e.preferredOutputLocation)==null?void 0:p[z])??"cpu",H=r.webnnIsGraphOutput;if(P==="cpu"&&H&&H(a,z)){k.push("ml-tensor-cpu-output");continue}if(P!=="cpu"&&P!=="cpu-pinned"&&P!=="gpu-buffer"&&P!=="ml-tensor")throw new Error(`Not supported preferred output location: ${P}.`);if(y&&P!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${P}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);k.push(P)}}let C=null;return k.some(N=>N==="gpu-buffer"||N==="ml-tensor"||N==="ml-tensor-cpu-output")&&(o=r._OrtCreateBinding(a),o===0&&dt("Can't create IO binding."),C={handle:o,outputPreferredLocations:k,outputPreferredLocationsEncoded:k.map(N=>N==="ml-tensor-cpu-output"?"ml-tensor":N).map(N=>tg(N))}),jr.set(a,[a,l,c,C,y,!1]),[a,b,$,w,v]}catch(m){throw l.forEach(g=>r._OrtFree(g)),c.forEach(g=>r._OrtFree(g)),o!==0&&r._OrtReleaseBinding(o)!==0&&dt("Can't release IO binding."),a!==0&&r._OrtReleaseSession(a)!==0&&dt("Can't release session."),m}finally{r._free(n),i!==0&&r._OrtReleaseSessionOptions(i)!==0&&dt("Can't release session options."),u.forEach(m=>r._free(m)),(f=r.unmountExternalData)==null||f.call(r)}},Y0=t=>{var u,l,c;let e=bt(),n=jr.get(t);if(!n)throw new Error(`cannot release session. invalid session id: ${t}`);let[s,r,a,i,o]=n;i&&(o&&e._OrtClearBoundOutputs(i.handle)!==0&&dt("Can't clear bound outputs."),e._OrtReleaseBinding(i.handle)!==0&&dt("Can't release IO binding.")),(u=e.jsepOnReleaseSession)==null||u.call(e,t),(l=e.webnnOnReleaseSession)==null||l.call(e,t),(c=e.webgpuOnReleaseSession)==null||c.call(e,t),r.forEach(d=>e._OrtFree(d)),a.forEach(d=>e._OrtFree(d)),e._OrtReleaseSession(s)!==0&&dt("Can't release session."),jr.delete(t)},Jf=async(t,e,n,s,r,a,i=!1)=>{if(!t){e.push(0);return}let o=bt(),u=o.PTR_SIZE,l=t[0],c=t[1],d=t[3],h=d,p,f;if(l==="string"&&(d==="gpu-buffer"||d==="ml-tensor"))throw new Error("String tensor is not supported on GPU.");if(i&&d!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${a} when enableGraphCapture is true.`);if(d==="gpu-buffer"){let y=t[2].gpuBuffer;f=Ga(Ua(l),c);{let b=o.jsepRegisterBuffer;if(!b)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');p=b(s,a,y,f)}}else if(d==="ml-tensor"){let y=t[2].mlTensor;f=Ga(Ua(l),c);let b=o.webnnRegisterMLTensor;if(!b)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');p=b(s,y,Ua(l),c)}else{let y=t[2];if(Array.isArray(y)){f=u*y.length,p=o._malloc(f),n.push(p);for(let b=0;b<y.length;b++){if(typeof y[b]!="string")throw new TypeError(`tensor data at index ${b} is not a string`);o.setValue(p+b*u,Us(y[b],n),"*")}}else{let b=o.webnnIsGraphInput,$=o.webnnIsGraphOutput;if(l!=="string"&&b&&$){let w=o.UTF8ToString(r);if(b(s,w)||$(s,w)){let v=Ua(l);f=Ga(v,c),h="ml-tensor";let k=o.webnnCreateTemporaryTensor,C=o.webnnUploadTensor;if(!k||!C)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');let N=await k(s,v,c);C(N,new Uint8Array(y.buffer,y.byteOffset,y.byteLength)),p=N}else f=y.byteLength,p=o._malloc(f),n.push(p),o.HEAPU8.set(new Uint8Array(y.buffer,y.byteOffset,f),p)}else f=y.byteLength,p=o._malloc(f),n.push(p),o.HEAPU8.set(new Uint8Array(y.buffer,y.byteOffset,f),p)}}let m=o.stackSave(),g=o.stackAlloc(4*c.length);try{c.forEach((b,$)=>o.setValue(g+$*u,b,u===4?"i32":"i64"));let y=o._OrtCreateTensor(Ua(l),p,f,g,c.length,tg(h));y===0&&dt(`Can't create tensor for input/output. session=${s}, index=${a}.`),e.push(y)}finally{o.stackRestore(m)}},Z0=async(t,e,n,s,r,a)=>{var E,z,P,H;let i=bt(),o=i.PTR_SIZE,u=jr.get(t);if(!u)throw new Error(`cannot run inference. invalid session id: ${t}`);let l=u[0],c=u[1],d=u[2],h=u[3],p=u[4],f=u[5],m=e.length,g=s.length,y=0,b=[],$=[],w=[],v=[],k=i.stackSave(),C=i.stackAlloc(m*o),N=i.stackAlloc(m*o),A=i.stackAlloc(g*o),I=i.stackAlloc(g*o);try{[y,b]=HA(a),Xa("wasm prepareInputOutputTensor");for(let B=0;B<m;B++)await Jf(n[B],$,v,t,c[e[B]],e[B],p);for(let B=0;B<g;B++)await Jf(r[B],w,v,t,d[s[B]],m+s[B],p);Ya("wasm prepareInputOutputTensor");for(let B=0;B<m;B++)i.setValue(C+B*o,$[B],"*"),i.setValue(N+B*o,c[e[B]],"*");for(let B=0;B<g;B++)i.setValue(A+B*o,w[B],"*"),i.setValue(I+B*o,d[s[B]],"*");if(h&&!f){let{handle:B,outputPreferredLocations:Y,outputPreferredLocationsEncoded:ne}=h;if(c.length!==m)throw new Error(`input count from feeds (${m}) is expected to be always equal to model's input count (${c.length}).`);Xa("wasm bindInputsOutputs");for(let M=0;M<m;M++){let Z=e[M];await i._OrtBindInput(B,c[Z],$[M])!==0&&dt(`Can't bind input[${M}] for session=${t}.`)}for(let M=0;M<g;M++){let Z=s[M];(E=r[M])!=null&&E[3]?i._OrtBindOutput(B,d[Z],w[M],0)!==0&&dt(`Can't bind pre-allocated output[${M}] for session=${t}.`):i._OrtBindOutput(B,d[Z],0,ne[Z])!==0&&dt(`Can't bind output[${M}] to ${Y[M]} for session=${t}.`)}Ya("wasm bindInputsOutputs"),jr.set(t,[l,c,d,h,p,!0])}(z=i.jsepOnRunStart)==null||z.call(i,l),(P=i.webnnOnRunStart)==null||P.call(i,l);let G;h?G=await i._OrtRunWithBinding(l,h.handle,g,A,y):G=await i._OrtRun(l,N,C,m,I,g,A,y),G!==0&&dt("failed to call OrtRun().");let W=[],L=[];Xa("wasm ProcessOutputTensor");for(let B=0;B<g;B++){let Y=Number(i.getValue(A+B*o,"*"));if(Y===w[B]){W.push(r[B]);continue}let ne=i.stackSave(),M=i.stackAlloc(4*o),Z=!1,J,oe=0;try{i._OrtGetTensorData(Y,M,M+o,M+2*o,M+3*o)!==0&&dt(`Can't access output tensor data on index ${B}.`);let de=o===4?"i32":"i64",fe=Number(i.getValue(M,de));oe=i.getValue(M+o,"*");let xe=i.getValue(M+o*2,"*"),Ne=Number(i.getValue(M+o*3,de)),$e=[];for(let Oe=0;Oe<Ne;Oe++)$e.push(Number(i.getValue(xe+Oe*o,de)));i._OrtFree(xe)!==0&&dt("Can't free memory for tensor dims.");let Ee=$e.reduce((Oe,Fe)=>Oe*Fe,1);J=Cr(fe);let ze=h==null?void 0:h.outputPreferredLocations[s[B]];if(J==="string"){if(ze==="gpu-buffer"||ze==="ml-tensor")throw new Error("String tensor is not supported on GPU.");let Oe=[];for(let Fe=0;Fe<Ee;Fe++){let Je=i.getValue(oe+Fe*o,"*"),ct=i.getValue(oe+(Fe+1)*o,"*"),Ke=Fe===Ee-1?void 0:ct-Je;Oe.push(i.UTF8ToString(Je,Ke))}W.push([J,$e,Oe,"cpu"])}else if(ze==="gpu-buffer"&&Ee>0){let Oe=i.jsepGetBuffer;if(!Oe)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let Fe=Oe(oe),Je=Ga(fe,Ee);if(Je===void 0||!R0(J))throw new Error(`Unsupported data type: ${J}`);Z=!0,W.push([J,$e,{gpuBuffer:Fe,download:i.jsepCreateDownloader(Fe,Je,J),dispose:()=>{i._OrtReleaseTensor(Y)!==0&&dt("Can't release tensor.")}},"gpu-buffer"])}else if(ze==="ml-tensor"&&Ee>0){let Oe=i.webnnEnsureTensor,Fe=i.webnnIsGraphInputOutputTypeSupported;if(!Oe||!Fe)throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(Ga(fe,Ee)===void 0||!D0(J))throw new Error(`Unsupported data type: ${J}`);if(!Fe(t,J,!1))throw new Error(`preferredLocation "ml-tensor" for ${J} output is not supported by current WebNN Context.`);let Je=await Oe(t,oe,fe,$e,!1);Z=!0,W.push([J,$e,{mlTensor:Je,download:i.webnnCreateMLTensorDownloader(oe,J),dispose:()=>{i.webnnReleaseTensorId(oe),i._OrtReleaseTensor(Y)}},"ml-tensor"])}else if(ze==="ml-tensor-cpu-output"&&Ee>0){let Oe=i.webnnCreateMLTensorDownloader(oe,J)(),Fe=W.length;Z=!0,L.push((async()=>{let Je=[Fe,await Oe];return i.webnnReleaseTensorId(oe),i._OrtReleaseTensor(Y),Je})()),W.push([J,$e,[],"cpu"])}else{let Oe=pp(J),Fe=new Oe(Ee);new Uint8Array(Fe.buffer,Fe.byteOffset,Fe.byteLength).set(i.HEAPU8.subarray(oe,oe+Fe.byteLength)),W.push([J,$e,Fe,"cpu"])}}finally{i.stackRestore(ne),J==="string"&&oe&&i._free(oe),Z||i._OrtReleaseTensor(Y)}}h&&!p&&(i._OrtClearBoundOutputs(h.handle)!==0&&dt("Can't clear bound outputs."),jr.set(t,[l,c,d,h,p,!1]));for(let[B,Y]of await Promise.all(L))W[B][2]=Y;return Ya("wasm ProcessOutputTensor"),W}finally{(H=i.webnnOnRunEnd)==null||H.call(i,l),i.stackRestore(k),$.forEach(G=>i._OrtReleaseTensor(G)),w.forEach(G=>i._OrtReleaseTensor(G)),v.forEach(G=>i._free(G)),y!==0&&i._OrtReleaseRunOptions(y),b.forEach(G=>i._free(G))}},Q0=t=>{let e=bt(),n=jr.get(t);if(!n)throw new Error("invalid session id");let s=n[0],r=e._OrtEndProfiling(s);r===0&&dt("Can't get an profile file name."),e._OrtFree(r)},J0=t=>{let e=[];for(let n of t){let s=n[2];!Array.isArray(s)&&"buffer"in s&&e.push(s.buffer)}return e}}),Kr,Bn,Ri,Wo,Uo,vc,em,Sc,Fa,za,dI,HO,qO,jO,KO,XO,YO,ZO,QO=he(()=>{Ts(),GO(),ki(),N0(),Kr=()=>!!gt.wasm.proxy&&typeof document<"u",Ri=!1,Wo=!1,Uo=!1,Sc=new Map,Fa=(t,e)=>{let n=Sc.get(t);n?n.push(e):Sc.set(t,[e])},za=()=>{if(Ri||!Wo||Uo||!Bn)throw new Error("worker not ready")},dI=t=>{switch(t.data.type){case"init-wasm":Ri=!1,t.data.err?(Uo=!0,em[1](t.data.err)):(Wo=!0,em[0]()),vc&&(URL.revokeObjectURL(vc),vc=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let e=Sc.get(t.data.type);t.data.err?e.shift()[1](t.data.err):e.shift()[0](t.data.out);break}}},HO=async()=>{if(!Wo){if(Ri)throw new Error("multiple calls to 'initWasm()' detected.");if(Uo)throw new Error("previous call to 'initWasm()' failed.");if(Ri=!0,Kr())return new Promise((t,e)=>{Bn==null||Bn.terminate(),UA().then(([n,s])=>{try{Bn=s,Bn.onerror=a=>e(a),Bn.onmessage=dI,em=[t,e];let r={type:"init-wasm",in:gt};!r.in.wasm.wasmPaths&&(n||eg)&&(r.in.wasm.wasmPaths={wasm:new URL(""+new URL("ort-wasm-simd-threaded.jsep-Bvhpdk4G.wasm",import.meta.url).href,import.meta.url).href}),Bn.postMessage(r),vc=n}catch(r){e(r)}},e)});try{await E0(gt.wasm),await j0(gt),Wo=!0}catch(t){throw Uo=!0,t}finally{Ri=!1}}},qO=async t=>{if(Kr())return za(),new Promise((e,n)=>{Fa("init-ep",[e,n]);let s={type:"init-ep",in:{epName:t,env:gt}};Bn.postMessage(s)});await K0(gt,t)},jO=async t=>Kr()?(za(),new Promise((e,n)=>{Fa("copy-from",[e,n]);let s={type:"copy-from",in:{buffer:t}};Bn.postMessage(s,[t.buffer])})):xd(t),KO=async(t,e)=>{if(Kr()){if(e!=null&&e.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return za(),new Promise((n,s)=>{Fa("create",[n,s]);let r={type:"create",in:{model:t,options:{...e}}},a=[];t instanceof Uint8Array&&a.push(t.buffer),Bn.postMessage(r,a)})}else return X0(t,e)},XO=async t=>{if(Kr())return za(),new Promise((e,n)=>{Fa("release",[e,n]);let s={type:"release",in:t};Bn.postMessage(s)});Y0(t)},YO=async(t,e,n,s,r,a)=>{if(Kr()){if(n.some(i=>i[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(r.some(i=>i))throw new Error("pre-allocated output tensor is not supported for proxy.");return za(),new Promise((i,o)=>{Fa("run",[i,o]);let u=n,l={type:"run",in:{sessionId:t,inputIndices:e,inputs:u,outputIndices:s,options:a}};Bn.postMessage(l,J0(u))})}else return Z0(t,e,n,s,r,a)},ZO=async t=>{if(Kr())return za(),new Promise((e,n)=>{Fa("end-profiling",[e,n]);let s={type:"end-profiling",in:t};Bn.postMessage(s)});Q0(t)}}),tm,hI,JO,Zle=he(()=>{Ts(),QO(),De(),T0(),jA(),tm=(t,e)=>{switch(t.location){case"cpu":return[t.type,t.dims,t.data,"cpu"];case"gpu-buffer":return[t.type,t.dims,{gpuBuffer:t.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[t.type,t.dims,{mlTensor:t.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${t.location} for ${e()}`)}},hI=t=>{switch(t[3]){case"cpu":return new Gs(t[0],t[2],t[1]);case"gpu-buffer":{let e=t[0];if(!R0(e))throw new Error(`not supported data type: ${e} for deserializing GPU tensor`);let{gpuBuffer:n,download:s,dispose:r}=t[2];return Gs.fromGpuBuffer(n,{dataType:e,dims:t[1],download:s,dispose:r})}case"ml-tensor":{let e=t[0];if(!D0(e))throw new Error(`not supported data type: ${e} for deserializing MLTensor tensor`);let{mlTensor:n,download:s,dispose:r}=t[2];return Gs.fromMLTensor(n,{dataType:e,dims:t[1],download:s,dispose:r})}default:throw new Error(`invalid data location: ${t[3]}`)}},JO=class{async fetchModelAndCopyToWasmMemory(t){return jO(await O0(t))}async loadModel(t,e){br();let n;typeof t=="string"?n=await this.fetchModelAndCopyToWasmMemory(t):n=t,[this.sessionId,this.inputNames,this.outputNames,this.inputMetadata,this.outputMetadata]=await KO(n,e),js()}async dispose(){return XO(this.sessionId)}async run(t,e,n){br();let s=[],r=[];Object.entries(t).forEach(d=>{let h=d[0],p=d[1],f=this.inputNames.indexOf(h);if(f===-1)throw new Error(`invalid input '${h}'`);s.push(p),r.push(f)});let a=[],i=[];Object.entries(e).forEach(d=>{let h=d[0],p=d[1],f=this.outputNames.indexOf(h);if(f===-1)throw new Error(`invalid output '${h}'`);a.push(p),i.push(f)});let o=s.map((d,h)=>tm(d,()=>`input "${this.inputNames[r[h]]}"`)),u=a.map((d,h)=>d?tm(d,()=>`output "${this.outputNames[i[h]]}"`):null),l=await YO(this.sessionId,r,o,i,u,n),c={};for(let d=0;d<l.length;d++)c[this.outputNames[i[d]]]=a[d]??hI(l[d]);return js(),c}startProfiling(){}endProfiling(){ZO(this.sessionId)}}}),e3={};_o(e3,{OnnxruntimeWebAssemblyBackend:()=>mg,initializeFlags:()=>fg,wasmBackend:()=>t3});var fg,mg,t3,Qle=he(()=>{Ts(),QO(),Zle(),fg=()=>{(typeof gt.wasm.initTimeout!="number"||gt.wasm.initTimeout<0)&&(gt.wasm.initTimeout=0);let t=gt.wasm.simd;if(typeof t!="boolean"&&t!==void 0&&t!=="fixed"&&t!=="relaxed"&&(console.warn(`Property "env.wasm.simd" is set to unknown value "${t}". Reset it to \`false\` and ignore SIMD feature checking.`),gt.wasm.simd=!1),typeof gt.wasm.proxy!="boolean"&&(gt.wasm.proxy=!1),typeof gt.wasm.trace!="boolean"&&(gt.wasm.trace=!1),typeof gt.wasm.numThreads!="number"||!Number.isInteger(gt.wasm.numThreads)||gt.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)gt.wasm.numThreads=1;else{let e=typeof navigator>"u"?Lue("node:os").cpus().length:navigator.hardwareConcurrency;gt.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},mg=class{async init(t){fg(),await HO(),await qO(t)}async createInferenceSessionHandler(t,e){let n=new JO;return await n.loadModel(t,e),n}},t3=new mg});Ts();Ts();Ts();var Jle="1.23.0-dev.20250731-e753643480";{let t=(Qle(),bu(e3)).wasmBackend;Li("webgpu",t,5),Li("webnn",t,5),Li("cpu",t,10),Li("wasm",t,10)}Object.defineProperty(gt.versions,"web",{value:Jle,enumerable:!0});/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2025 Nicolas Wang. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
uu distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ece{constructor(){Ln(this,"model",null)}async load(){await sL();const e="./models/crazy_matching/model.json";this.model=await fK(e),console.log("Custom model loaded from:",e)}async detect(e){if(!this.model)return console.log("Model not loaded."),[];const n=xk(e),s=ys.resizeBilinear(n,[224,224]),r=s.expandDims(0),a=r.div(255),i=this.model.execute(a);let o;if(Array.isArray(i)){if(!i[0])return console.error("模型推理结果为空或格式不正确:",i),Ve([n,s,r,a]),[];o=i[0].squeeze()}else if(i instanceof _t)o=i.squeeze();else return console.error("模型推理结果类型未知:",i),Ve([n,s,r,a]),[];const u=o.arraySync(),l=e.videoWidth,c=e.videoHeight;let d=!1;const h=u;if(u.length===10){const[y,b,$,w,v,k,C,N,A,I]=u,E=y>=0&&y<=l&&b>=0&&b<=c&&$>0&&$<=l&&w>0&&w<=c,z=k>=0&&k<=l&&C>=0&&C<=c&&N>0&&N<=l&&A>0&&A<=c,P=v>=-Math.PI&&v<=Math.PI,H=I>=-Math.PI&&I<=Math.PI,G=p(y,b,$,w,v),W=p(k,C,N,A,I),L=!f(G,W);d=E&&z&&P&&H&&L}return Array.isArray(i)?Ve([n,s,r,a,...i,o]):Ve([n,s,r,a,i,o]),[{raw:h,success:d}];function p(y,b,$,w,v){const k=$/2,C=w/2;return[{x:-k,y:-C},{x:k,y:-C},{x:k,y:C},{x:-k,y:C}].map(A=>{const I=A.x*Math.cos(v)-A.y*Math.sin(v)+y,E=A.x*Math.sin(v)+A.y*Math.cos(v)+b;return{x:I,y:E}})}function f(y,b){const $=m(y).concat(m(b));for(const w of $){const[v,k]=g(y,w),[C,N]=g(b,w);if(k<C||N<v)return!1}return!0}function m(y){const b=[];for(let $=0;$<y.length;$++){const w=y[$],v=y[($+1)%y.length],k={x:v.x-w.x,y:v.y-w.y};b.push({x:-k.y,y:k.x})}return b}function g(y,b){const $=Math.sqrt(b.x*b.x+b.y*b.y),w=b.x/$,v=b.y/$;let k=1/0,C=-1/0;for(const N of y){const A=N.x*w+N.y*v;k=Math.min(k,A),C=Math.max(C,A)}return[k,C]}}}function tce(t,e){const n=Math.max(t[0],e[0]),s=Math.max(t[1],e[1]),r=Math.min(t[2],e[2]),a=Math.min(t[3],e[3]),i=Math.max(0,r-n),o=Math.max(0,a-s),u=i*o,l=(t[2]-t[0])*(t[3]-t[1]),c=(e[2]-e[0])*(e[3]-e[1]),d=l+c-u;return d===0?0:u/d}function nce(t,e,n){const s=e.map((i,o)=>({score:i,index:o})).sort((i,o)=>o.score-i.score).map(i=>i.index),r=[],a=new Array(t.length).fill(!1);for(const i of s){if(a[i])continue;r.push(i);const o=t[i];for(let u=0;u<t.length;u++){if(u===i||a[u])continue;const l=t[u];tce(o,l)>n&&(a[u]=!0)}}return r}class sce{constructor(){Ln(this,"session",null);Ln(this,"inputShape",[1,3,320,320])}async load(){gt.wasm.numThreads=1,gt.wasm.simd=!0,gt.wasm.proxy=!0;const e="./models/crazy_matching.onnx";try{if(this.session=await C0.create(e,{executionProviders:["wasm"],graphOptimizationLevel:"all"}),console.log("ONNX model loaded from:",e),this.session.inputNames.length>0){const n=this.session.inputMetadata[0];n&&n.isTensor&&n.shape&&n.shape.length===4&&(this.inputShape=n.shape)}}catch(n){console.error("Failed to load ONNX model:",n)}}async detect(e){if(!this.session)return console.log("ONNX Model not loaded."),[];const n=e.videoWidth,s=e.videoHeight;console.log(`Input video dimensions: ${n}x${s}`);const r=xk(e);console.log(`Input video dimensions: ${r}`);const a=ys.resizeBilinear(r,[this.inputShape[2],this.inputShape[3]]),i=a.div(255),o=i.transpose([2,0,1]),u=o.expandDims(0),l=new Float32Array(u.dataSync());Ve([r,a,i,o,u]);const c=this.session.inputNames[0],d={};d[c]=new Gs("float32",l,this.inputShape),console.log("Running ONNX inference with feeds:",d,c);try{const h=await this.session.run(d),p=h.boxes.data,f=h.labels.data,m=h.scores.data,g=[];for(let N=0;N<f.length;N++){const A=m[N];if(A>.5){const I=[p[N*4]*n,p[N*4+1]*s,p[N*4+2]*n,p[N*4+3]*s];g.push({box:I,label:f[N],score:A})}}const y=g.map(N=>N.box),b=g.map(N=>N.score),w=nce(y,b,.45).map(N=>g[N]),v={};for(const N of w)N.label!==0&&(v[N.label]||(v[N.label]=[]),v[N.label].push(N));let k=!1,C=[];for(const N in v){const A=v[N];if(A.length>=2){const I=A[0],E=A[1],z=M=>{const Z=M[0],J=M[1],oe=M[2],de=M[3],fe=oe-Z,xe=de-J,Ne=Z+fe/2,$e=J+xe/2;return[Ne,$e,fe,xe]},[P,H,G,W]=z(I.box),[L,B,Y,ne]=z(E.box);C=[P,H,G,W,0,L,B,Y,ne,0],k=!0;break}}return[{raw:C,success:k}]}catch(h){return console.error("Failed to run ONNX inference:",h),[]}}}class rce{constructor(){Ln(this,"video");Ln(this,"canvas");Ln(this,"tfjsModel");Ln(this,"onnxModel");Ln(this,"currentModel");Ln(this,"activeModelType","onnx");Ln(this,"isDetecting",!1);Ln(this,"videoDevices",[]);Ln(this,"currentStream",null);this.video=document.getElementById("video"),this.canvas=document.getElementById("canvas"),this.tfjsModel=new ece,this.onnxModel=new sce,this.currentModel=this.onnxModel;const e=document.getElementById("toggle-algo");e&&e.addEventListener("click",()=>{if(this.isDetecting=!this.isDetecting,e.textContent=this.isDetecting?"Stop":"Start",this.isDetecting)this.detect();else{const s=this.canvas.getContext("2d");s&&s.clearRect(0,0,this.canvas.width,this.canvas.height)}});const n=document.getElementById("switch-model-btn");n&&n.addEventListener("click",async()=>{this.activeModelType=this.activeModelType==="tfjs"?"onnx":"tfjs",n.textContent=`Switch to ${this.activeModelType==="tfjs"?"ONNX":"TF.js"} Model`,this.currentModel=this.activeModelType==="tfjs"?this.tfjsModel:this.onnxModel,console.log(`Switching to ${this.activeModelType} model...`),await this.currentModel.load(),console.log(`${this.activeModelType} model loaded.`)})}async run(){await this.currentModel.load(),await this.setupCamera()}async setupCamera(){const e=await navigator.mediaDevices.enumerateDevices();this.videoDevices=e.filter(r=>r.kind==="videoinput"),this.videoDevices.sort((r,a)=>r.label.localeCompare(a.label)),console.log("Available video devices:",this.videoDevices.map(r=>({label:r.label,deviceId:r.deviceId})));const n=this.videoDevices.find(r=>r.label.toLowerCase().includes("wide")),s=n?n.deviceId:this.videoDevices.length>0?this.videoDevices[0].deviceId:void 0;console.log("Initial camera selected:",s),s?await this.startStream(s):await this.startStream(),this.setupCameraSelectorUI()}setupCameraSelectorUI(){var s;const e=document.getElementById("right-controls");if(!e||this.videoDevices.length<=1)return;e.innerHTML="",this.videoDevices.forEach(r=>{const a=document.createElement("button");a.classList.add("camera-select-button"),a.dataset.deviceId=r.deviceId,a.title=r.label,a.addEventListener("click",()=>this.startStream(r.deviceId)),e.appendChild(a)}),e.style.display="flex";const n=(s=this.currentStream)==null?void 0:s.getVideoTracks()[0].getSettings().deviceId;n&&this.updateActiveButton(n)}async startStream(e){this.currentStream&&this.currentStream.getTracks().forEach(s=>s.stop());const n=e?{deviceId:{exact:e}}:{facingMode:"environment"};try{this.currentStream=await navigator.mediaDevices.getUserMedia({video:n,audio:!1}),this.video.srcObject=this.currentStream,await new Promise(r=>{this.video.onloadedmetadata=()=>r(!0)}),await this.video.play(),this.canvas.width=this.video.videoWidth,this.canvas.height=this.video.videoHeight;const s=this.currentStream.getVideoTracks()[0].getSettings().deviceId;s&&this.updateActiveButton(s),this.setupZoomSlider()}catch(s){console.error(`Error starting stream for device ${e}:`,s)}}updateActiveButton(e){document.querySelectorAll(".camera-select-button").forEach(n=>{const s=n;s.classList.toggle("active",s.dataset.deviceId===e)})}setupZoomSlider(){var r;if(!this.currentStream)return;const[e]=this.currentStream.getVideoTracks(),n=e.getCapabilities(),s=document.getElementById("zoom");n.zoom&&s?(s.min=n.zoom.min.toString(),s.max=n.zoom.max.toString(),s.step=n.zoom.step.toString(),s.value=((r=e.getSettings().zoom)==null?void 0:r.toString())??n.zoom.min.toString(),s.disabled=!1,s.oninput=a=>{e.applyConstraints({advanced:[{zoom:a.target.valueAsNumber}]})}):s.disabled=!0}async detect(){if(!this.isDetecting)return;const e=await this.currentModel.detect(this.video),n=this.canvas.getContext("2d");if(n){if(n.clearRect(0,0,this.canvas.width,this.canvas.height),Array.isArray(e)&&e.length>0&&Array.isArray(e[0].raw)){const s=e[0].raw;if(s.length===10){const[r,a,i,o,u,l,c,d,h,p]=s,f=this.canvas.clientWidth,m=this.canvas.clientHeight;pI(n,r*f,a*m,i*f,o*m,u,"#00FFFF"),n.fillText("1",r*f,a*m),pI(n,l*f,c*m,d*f,h*m,p,"#FF00FF"),n.fillText("2",l*f,c*m)}}requestAnimationFrame(()=>this.detect())}}}const ace=new rce;ace.run();function pI(t,e,n,s,r,a,i){t.save(),t.translate(e,n),t.rotate(a),t.strokeStyle=i,t.lineWidth=4,t.strokeRect(-s/2,-r/2,s,r),t.restore()}
